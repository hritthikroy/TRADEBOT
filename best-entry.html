<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Best Entry Positions - Multi-Timeframe Confluence</title>
    <script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #131722;
            color: #d1d4dc;
            padding: 20px;
        }
        .container {
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
        }
        h1 {
            color: #26a69a;
            margin-bottom: 10px;
        }
        .subtitle {
            color: #787b86;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .refresh-btn {
            background: #26a69a;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 20px;
        }
        .refresh-btn:hover {
            background: #2bbbad;
        }
        .entry-card {
            background: #1e222d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            border-left: 4px solid #26a69a;
            transition: transform 0.2s;
        }
        .entry-card:hover {
            transform: translateX(5px);
        }
        .entry-card.sell {
            border-left-color: #ef5350;
        }
        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .entry-type {
            font-size: 24px;
            font-weight: bold;
        }
        .entry-type.buy {
            color: #26a69a;
        }
        .entry-type.sell {
            color: #ef5350;
        }
        .confluence-score {
            font-size: 32px;
            font-weight: bold;
            color: #f7931a;
        }
        .timeframes {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        .tf-badge {
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            color: white;
        }
        .tf-1m { background: #ff6b6b; }
        .tf-3m { background: #ffa657; }
        .tf-15m { background: #58a6ff; }
        .tf-1h { background: #a371f7; }
        .tf-2h { background: #f85149; }
        .tf-4h { background: #3fb950; }
        .entry-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #2a2e39;
        }
        .detail-item {
            text-align: center;
        }
        .detail-label {
            color: #787b86;
            font-size: 11px;
            text-transform: uppercase;
            margin-bottom: 5px;
        }
        .detail-value {
            font-size: 18px;
            font-weight: bold;
        }
        .detail-value.entry { color: #26a69a; }
        .detail-value.sl { color: #ef5350; }
        .detail-value.tp { color: #4caf50; }
        .no-signals {
            text-align: center;
            padding: 60px 20px;
            color: #787b86;
        }
        .loading {
            text-align: center;
            padding: 40px;
            color: #787b86;
        }
        .spinner {
            border: 4px solid #2a2e39;
            border-top: 4px solid #26a69a;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.05); }
        }
        .info-box {
            background: #2a2e39;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 13px;
            line-height: 1.6;
        }
        .info-box strong {
            color: #26a69a;
        }
        .chart-container {
            background: #1e222d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            min-height: 850px;
        }
        #tradingview_chart {
            width: 100%;
            height: 750px;
            position: relative;
            min-width: 800px;
            background: #1e222d;
        }
        #overlay-canvas {
            display: none;
        }
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        .chart-title {
            font-size: 18px;
            font-weight: bold;
            color: #d1d4dc;
        }
        .chart-info {
            font-size: 12px;
            color: #787b86;
        }
        .time-btn {
            background: #2a2e39;
            color: #d1d4dc;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        .time-btn:hover {
            background: #363a45;
        }
        .time-btn.active {
            background: #26a69a;
            color: white;
            font-weight: bold;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
</head>
<body>
    <div class="container">
        <h1>üéØ Best Entry Positions</h1>
        <p class="subtitle">Multi-timeframe confluence analysis - Higher score = Better entry</p>
        
        <!-- SCALPING SIGNAL BOX -->
        <div id="scalping-signal" onclick="showScalpingOnChart()" style="background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #00d4ff; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: none; cursor: pointer;" title="Click to show on chart">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 28px;">‚ö°</span>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: #00d4ff;">SCALPING SIGNAL</div>
                        <div style="font-size: 11px; color: #787b86;">Best setup for day trading</div>
                    </div>
                </div>
                <div id="signal-direction" style="font-size: 32px; font-weight: bold; padding: 8px 20px; border-radius: 8px;">-</div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 15px; margin-bottom: 15px;">
                <div style="background: #0d1117; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">SYMBOL</div>
                    <div id="signal-symbol" style="color: #f7931a; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d1117; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">ENTRY PRICE</div>
                    <div id="signal-entry" style="color: #00d4ff; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d1117; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">STOP LOSS</div>
                    <div id="signal-sl" style="color: #ef5350; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d1117; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">RISK %</div>
                    <div id="signal-risk" style="color: #ef5350; font-size: 20px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
                <div style="background: linear-gradient(135deg, #0d4d0d 0%, #1a5c1a 100%); padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #26a69a;">
                    <div style="color: #4caf50; font-size: 10px; margin-bottom: 5px;">TP1 (Quick)</div>
                    <div id="signal-tp1" style="color: #26a69a; font-size: 18px; font-weight: bold;">-</div>
                    <div id="signal-tp1-pct" style="color: #4caf50; font-size: 11px;">-</div>
                </div>
                <div style="background: linear-gradient(135deg, #0d4d0d 0%, #1a5c1a 100%); padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #4caf50;">
                    <div style="color: #66bb6a; font-size: 10px; margin-bottom: 5px;">TP2 (Target)</div>
                    <div id="signal-tp2" style="color: #4caf50; font-size: 18px; font-weight: bold;">-</div>
                    <div id="signal-tp2-pct" style="color: #66bb6a; font-size: 11px;">-</div>
                </div>
                <div style="background: linear-gradient(135deg, #0d4d0d 0%, #1a5c1a 100%); padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #66bb6a;">
                    <div style="color: #81c784; font-size: 10px; margin-bottom: 5px;">TP3 (Extended)</div>
                    <div id="signal-tp3" style="color: #66bb6a; font-size: 18px; font-weight: bold;">-</div>
                    <div id="signal-tp3-pct" style="color: #81c784; font-size: 11px;">-</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 15px; padding: 12px; background: #0d1117; border-radius: 8px;">
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">CONFLUENCE</div>
                    <div id="signal-confluence" style="color: #f7931a; font-size: 16px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">RISK:REWARD</div>
                    <div id="signal-rr" style="color: #00d4ff; font-size: 16px; font-weight: bold;">-</div>
                    <div style="width: 80px; height: 4px; background: #2a2e39; border-radius: 2px; overflow: hidden; margin: 5px auto 0;">
                        <div id="signal-rr-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ef5350, #f7931a, #26a69a); border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">STRENGTH</div>
                    <div id="signal-strength" style="color: #a855f7; font-size: 16px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TIMEFRAMES</div>
                    <div id="signal-timeframes" style="color: #58a6ff; font-size: 12px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <div id="signal-quality" style="padding: 8px 16px; border-radius: 20px; font-size: 12px; font-weight: bold;">-</div>
                <div id="signal-timing" style="padding: 8px 16px; border-radius: 20px; font-size: 12px; background: #1e3a5f; color: #58a6ff;">-</div>
                <div id="signal-strategy" style="padding: 8px 16px; border-radius: 20px; font-size: 12px; background: #3d1f5c; color: #a855f7;">-</div>
            </div>
        </div>
        
        <!-- SNIPER ENTRY SIGNAL BOX -->
        <div id="sniper-signal" onclick="showSniperOnChart()" style="background: linear-gradient(135deg, #1a0a0a 0%, #2d1010 100%); border: 2px solid #ff4444; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: none; cursor: pointer;" title="Click to show on chart">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 28px;">üéØ</span>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: #ff4444;">SNIPER ENTRY</div>
                        <div style="font-size: 11px; color: #787b86;">Tightest SL ‚Ä¢ Best R:R ‚Ä¢ Precision Entry</div>
                    </div>
                </div>
                <div id="sniper-direction" style="font-size: 32px; font-weight: bold; padding: 8px 20px; border-radius: 8px;">-</div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 12px; margin-bottom: 15px;">
                <div style="background: #0d0505; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #ff4444;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">SYMBOL</div>
                    <div id="sniper-symbol" style="color: #f7931a; font-size: 18px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0505; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #ff4444;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">üéØ SNIPER ENTRY</div>
                    <div id="sniper-entry" style="color: #ff4444; font-size: 18px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0505; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #ef5350;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">TIGHT SL</div>
                    <div id="sniper-sl" style="color: #ef5350; font-size: 18px; font-weight: bold;">-</div>
                    <div id="sniper-sl-pips" style="color: #ff6b6b; font-size: 10px;">-</div>
                </div>
                <div style="background: #0d0505; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #26a69a;">
                    <div style="color: #787b86; font-size: 10px; margin-bottom: 5px;">RISK %</div>
                    <div id="sniper-risk" style="color: #ef5350; font-size: 18px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px;">
                <div style="background: #050d05; padding: 10px; border-radius: 8px; text-align: center; border: 1px solid #26a69a;">
                    <div style="color: #4caf50; font-size: 10px;">TP1</div>
                    <div id="sniper-tp1" style="color: #26a69a; font-size: 16px; font-weight: bold;">-</div>
                    <div id="sniper-tp1-rr" style="color: #4caf50; font-size: 10px;">-</div>
                    <div style="width: 100%; height: 4px; background: #1a2e1a; border-radius: 2px; overflow: hidden; margin-top: 5px;">
                        <div id="sniper-tp1-bar" style="width: 0%; height: 100%; background: #26a69a; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="background: #050d05; padding: 10px; border-radius: 8px; text-align: center; border: 1px solid #4caf50;">
                    <div style="color: #66bb6a; font-size: 10px;">TP2</div>
                    <div id="sniper-tp2" style="color: #4caf50; font-size: 16px; font-weight: bold;">-</div>
                    <div id="sniper-tp2-rr" style="color: #66bb6a; font-size: 10px;">-</div>
                    <div style="width: 100%; height: 4px; background: #1a2e1a; border-radius: 2px; overflow: hidden; margin-top: 5px;">
                        <div id="sniper-tp2-bar" style="width: 0%; height: 100%; background: #4caf50; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="background: #050d05; padding: 10px; border-radius: 8px; text-align: center; border: 1px solid #66bb6a;">
                    <div style="color: #81c784; font-size: 10px;">TP3</div>
                    <div id="sniper-tp3" style="color: #66bb6a; font-size: 16px; font-weight: bold;">-</div>
                    <div id="sniper-tp3-rr" style="color: #81c784; font-size: 10px;">-</div>
                    <div style="width: 100%; height: 4px; background: #1a2e1a; border-radius: 2px; overflow: hidden; margin-top: 5px;">
                        <div id="sniper-tp3-bar" style="width: 0%; height: 100%; background: #66bb6a; border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; padding: 10px; background: #0d0505; border-radius: 8px; margin-bottom: 10px;">
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 9px;">SL DISTANCE</div>
                    <div id="sniper-sl-dist" style="color: #ff4444; font-size: 14px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 9px;">MAX R:R</div>
                    <div id="sniper-max-rr" style="color: #26a69a; font-size: 14px; font-weight: bold;">-</div>
                    <div style="width: 50px; height: 3px; background: #1a2e1a; border-radius: 2px; overflow: hidden; margin: 3px auto 0;">
                        <div id="sniper-max-rr-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #26a69a, #4caf50); border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 9px;">CONFLUENCE</div>
                    <div id="sniper-confluence" style="color: #f7931a; font-size: 14px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 9px;">TIMEFRAME</div>
                    <div id="sniper-tf" style="color: #58a6ff; font-size: 14px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                <div id="sniper-quality" style="padding: 6px 14px; border-radius: 20px; font-size: 11px; font-weight: bold;">-</div>
                <div id="sniper-type" style="padding: 6px 14px; border-radius: 20px; font-size: 11px; background: #1a0a0a; color: #ff4444; border: 1px solid #ff4444;">-</div>
                <div id="sniper-action" style="padding: 6px 14px; border-radius: 20px; font-size: 11px; background: #0a1a0a; color: #26a69a; border: 1px solid #26a69a;">-</div>
            </div>
        </div>
        
        <div class="info-box">
            <strong>How it works:</strong> This page analyzes signals from all timeframes and shows you the best entry opportunities based on confluence. 
            When multiple timeframes agree on the same direction, it creates a high-probability setup. 
            <strong>Confluence Score:</strong> Number of timeframes agreeing (max 6).
        </div>
        
        <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
            <button class="refresh-btn" onclick="loadBestEntries(true)">üîÑ Refresh</button>
            <button class="refresh-btn" onclick="clearPredictions()" style="background: #ef5350;">üßπ Clear Predictions</button>
            <button class="refresh-btn" onclick="runBacktest()" style="background: #a855f7;">üìä Run Backtest</button>
            <button class="refresh-btn" onclick="toggleAnimationSpeed()" style="background: #f7931a;" id="speed-btn">‚ö° Fast Mode</button>
        </div>
        
        <!-- BACKTEST RESULTS BOX -->
        <div id="backtest-results" style="background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); border: 2px solid #a855f7; border-radius: 12px; padding: 20px; margin-bottom: 20px; display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="display: flex; align-items: center; gap: 10px;">
                    <span style="font-size: 28px;">üìä</span>
                    <div>
                        <div style="font-size: 18px; font-weight: bold; color: #a855f7;">BACKTEST RESULTS</div>
                        <div style="font-size: 11px; color: #787b86;" id="backtest-period">-</div>
                    </div>
                </div>
                <div id="backtest-pnl" style="font-size: 32px; font-weight: bold; padding: 8px 20px; border-radius: 8px;">-</div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-bottom: 15px;">
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TOTAL TRADES</div>
                    <div id="bt-total" style="color: #58a6ff; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">WIN RATE</div>
                    <div id="bt-winrate" style="color: #26a69a; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">WINNERS</div>
                    <div id="bt-winners" style="color: #4caf50; font-size: 20px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">LOSERS</div>
                    <div id="bt-losers" style="color: #ef5350; font-size: 20px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 15px;">
                <div style="background: #050d05; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #26a69a;">
                    <div style="color: #4caf50; font-size: 10px;">TOTAL PROFIT</div>
                    <div id="bt-profit" style="color: #26a69a; font-size: 18px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0505; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #ef5350;">
                    <div style="color: #ef5350; font-size: 10px;">TOTAL LOSS</div>
                    <div id="bt-loss" style="color: #ef5350; font-size: 18px; font-weight: bold;">-</div>
                </div>
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #f7931a;">
                    <div style="color: #f7931a; font-size: 10px;">AVG R:R</div>
                    <div id="bt-avgrr" style="color: #f7931a; font-size: 18px; font-weight: bold;">-</div>
                    <div style="width: 80px; height: 4px; background: #2a2e39; border-radius: 2px; overflow: hidden; margin: 5px auto 0;">
                        <div id="bt-avgrr-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ef5350, #f7931a, #26a69a); border-radius: 2px; transition: width 0.3s;"></div>
                    </div>
                </div>
                <div style="background: #0d0d0d; padding: 12px; border-radius: 8px; text-align: center; border: 1px solid #a855f7;">
                    <div style="color: #a855f7; font-size: 10px;">PROFIT FACTOR</div>
                    <div id="bt-pf" style="color: #a855f7; font-size: 18px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; margin-bottom: 15px; padding: 12px; background: #0d0d0d; border-radius: 8px;">
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TP1 HIT RATE</div>
                    <div id="bt-tp1" style="color: #26a69a; font-size: 16px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TP2 HIT RATE</div>
                    <div id="bt-tp2" style="color: #4caf50; font-size: 16px; font-weight: bold;">-</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TP3 HIT RATE</div>
                    <div id="bt-tp3" style="color: #66bb6a; font-size: 16px; font-weight: bold;">-</div>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                <div id="bt-quality" style="padding: 6px 14px; border-radius: 20px; font-size: 11px; font-weight: bold;">-</div>
                <div id="bt-recommendation" style="padding: 6px 14px; border-radius: 20px; font-size: 11px; background: #1a1a3d; color: #a855f7;">-</div>
            </div>
        </div>
        
        <!-- TradingView Professional Chart with Overlay -->
        <div class="chart-container">
            <div class="chart-header">
                <div>
                    <div class="chart-title">üìä Professional Chart with Entry Levels</div>
                    <div class="chart-info" id="chart-info">Click an entry below to see levels on chart</div>
                    <div id="prediction-status" style="color: #00d4ff; font-size: 11px; margin-top: 5px;"></div>
                </div>
                
                <!-- CANDLE CLOSE TIMER - TradingView Style -->
                <div id="candle-timer-container" style="display: flex; align-items: center; gap: 15px;">
                    <div style="background: linear-gradient(135deg, #1e222d 0%, #2a2e39 100%); border: 1px solid #363a45; border-radius: 8px; padding: 8px 15px; display: flex; align-items: center; gap: 10px;">
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <span style="color: #787b86; font-size: 9px; text-transform: uppercase;">Candle Closes In</span>
                            <div id="candle-timer" style="font-family: 'Courier New', monospace; font-size: 20px; font-weight: bold; color: #f7931a; letter-spacing: 1px;">--:--</div>
                        </div>
                        <div style="width: 1px; height: 30px; background: #363a45;"></div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <span style="color: #787b86; font-size: 9px; text-transform: uppercase;">Timeframe</span>
                            <div id="current-tf-display" style="font-size: 16px; font-weight: bold; color: #26a69a;">1m</div>
                        </div>
                        <div style="width: 1px; height: 30px; background: #363a45;"></div>
                        <div style="display: flex; flex-direction: column; align-items: center;">
                            <span style="color: #787b86; font-size: 9px; text-transform: uppercase;">Progress</span>
                            <div style="width: 60px; height: 6px; background: #2a2e39; border-radius: 3px; overflow: hidden;">
                                <div id="candle-progress-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #26a69a, #4caf50); border-radius: 3px; transition: width 0.1s linear;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <button class="time-btn" onclick="checkPredictionAccuracy()" style="background: #a855f7; font-size: 10px;">üéØ Check Accuracy</button>
                        <button class="time-btn" onclick="changeChartTimeframe('1s')">1s</button>
                        <button class="time-btn active" onclick="changeChartTimeframe('1m')">1m</button>
                        <button class="time-btn" onclick="changeChartTimeframe('3m')">3m</button>
                        <button class="time-btn" onclick="changeChartTimeframe('5m')">5m</button>
                        <button class="time-btn" onclick="changeChartTimeframe('15m')">15m</button>
                        <button class="time-btn" onclick="changeChartTimeframe('1h')">1h</button>
                        <button class="time-btn" onclick="changeChartTimeframe('4h')">4h</button>
                    </div>
                </div>
            </div>
            <div style="position: relative;">
                <div id="tradingview_chart">
                    <div id="chart-loading" style="display: flex; align-items: center; justify-content: center; height: 750px; color: #787b86;">
                        <div style="text-align: center;">
                            <div class="spinner" style="margin: 0 auto 20px;"></div>
                            <div>Loading chart...</div>
                        </div>
                    </div>
                </div>
                <canvas id="overlay-canvas" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10;"></canvas>
            </div>
            <div id="levels-display" style="margin-top: 15px; padding: 15px; background: #2a2e39; border-radius: 8px; display: none;">
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div>
                        <div style="color: #787b86; font-size: 11px;">ENTRY</div>
                        <div id="level-entry" style="color: #26a69a; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div>
                        <div style="color: #787b86; font-size: 11px;">STOP LOSS</div>
                        <div id="level-sl" style="color: #ef5350; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div>
                        <div style="color: #787b86; font-size: 11px;">TP1</div>
                        <div id="level-tp1" style="color: #26a69a; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div>
                        <div style="color: #787b86; font-size: 11px;">TP2</div>
                        <div id="level-tp2" style="color: #4caf50; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div>
                        <div style="color: #787b86; font-size: 11px;">TP3</div>
                        <div id="level-tp3" style="color: #66bb6a; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div>
                        <div style="color: #787b86; font-size: 11px;">RISK:REWARD</div>
                        <div id="level-rr" style="color: #f7931a; font-size: 18px; font-weight: bold;">-</div>
                        <div style="width: 80px; height: 4px; background: #2a2e39; border-radius: 2px; overflow: hidden; margin-top: 5px;">
                            <div id="level-rr-bar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #ef5350, #f7931a, #26a69a); border-radius: 2px; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
                
                <!-- Time Analysis -->
                <div id="time-analysis" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #363a45; display: none;">
                    <div style="color: #00d4ff; font-size: 12px; font-weight: bold; margin-bottom: 10px;">‚è±Ô∏è TIME TO TARGETS</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px;">
                        <div>
                            <div style="color: #787b86; font-size: 10px;">TP1 TIME</div>
                            <div id="time-tp1" style="color: #26a69a; font-size: 16px; font-weight: bold;">-</div>
                        </div>
                        <div>
                            <div style="color: #787b86; font-size: 10px;">TP2 TIME</div>
                            <div id="time-tp2" style="color: #4caf50; font-size: 16px; font-weight: bold;">-</div>
                        </div>
                        <div>
                            <div style="color: #787b86; font-size: 10px;">TP3 TIME</div>
                            <div id="time-tp3" style="color: #66bb6a; font-size: 16px; font-weight: bold;">-</div>
                        </div>
                        <div>
                            <div style="color: #787b86; font-size: 10px;">TOTAL DURATION</div>
                            <div id="time-total" style="color: #f7931a; font-size: 16px; font-weight: bold;">-</div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- PREDICTION ACCURACY SCOREBOARD -->
            <div id="accuracy-scoreboard" style="margin-top: 15px; padding: 15px; background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border: 2px solid #a855f7; border-radius: 8px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span style="font-size: 24px;">üéØ</span>
                        <div>
                            <div style="font-size: 16px; font-weight: bold; color: #a855f7;">PREDICTION ACCURACY</div>
                            <div style="font-size: 10px; color: #787b86;" id="accuracy-time">Checking...</div>
                        </div>
                    </div>
                    <div id="accuracy-score" style="font-size: 28px; font-weight: bold; padding: 8px 16px; border-radius: 8px; background: #0d0d0d;">-</div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px; margin-bottom: 15px;">
                    <div style="background: #0d0d0d; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="color: #787b86; font-size: 9px;">DIRECTION</div>
                        <div id="acc-direction" style="color: #26a69a; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div style="background: #0d0d0d; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="color: #787b86; font-size: 9px;">TREND</div>
                        <div id="acc-trend" style="color: #4caf50; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div style="background: #0d0d0d; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="color: #787b86; font-size: 9px;">TARGETS</div>
                        <div id="acc-targets" style="color: #f7931a; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                    <div style="background: #0d0d0d; padding: 10px; border-radius: 6px; text-align: center;">
                        <div style="color: #787b86; font-size: 9px;">PATTERNS</div>
                        <div id="acc-patterns" style="color: #00d4ff; font-size: 18px; font-weight: bold;">-</div>
                    </div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px;">
                    <div style="background: #050d05; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #26a69a;">
                        <div style="color: #4caf50; font-size: 9px;">TP1 HIT</div>
                        <div id="acc-tp1" style="color: #26a69a; font-size: 14px; font-weight: bold;">-</div>
                    </div>
                    <div style="background: #050d05; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #4caf50;">
                        <div style="color: #66bb6a; font-size: 9px;">TP2 HIT</div>
                        <div id="acc-tp2" style="color: #4caf50; font-size: 14px; font-weight: bold;">-</div>
                    </div>
                    <div style="background: #050d05; padding: 8px; border-radius: 6px; text-align: center; border: 1px solid #66bb6a;">
                        <div style="color: #81c784; font-size: 9px;">TP3 HIT</div>
                        <div id="acc-tp3" style="color: #66bb6a; font-size: 14px; font-weight: bold;">-</div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <div id="acc-grade" style="padding: 6px 12px; border-radius: 20px; font-size: 11px; font-weight: bold;">-</div>
                    <div id="acc-verdict" style="padding: 6px 12px; border-radius: 20px; font-size: 11px; background: #1a1a3d; color: #a855f7;">-</div>
                </div>
            </div>
            
            <!-- Candle & Wick Analysis Panel -->
            <div id="candle-analysis" style="margin-top: 15px; padding: 15px; background: #1e222d; border-radius: 8px; display: none;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h3 style="color: #00d4ff; margin: 0; font-size: 16px;">üìä Predicted Candle Analysis</h3>
                    <span id="analysis-count" style="color: #787b86; font-size: 12px;">0 candles analyzed</span>
                </div>
                
                <!-- Summary Stats -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; margin-bottom: 15px;">
                    <div style="background: #2a2e39; padding: 12px; border-radius: 6px;">
                        <div style="color: #787b86; font-size: 11px; margin-bottom: 5px;">AVG BODY RATIO</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="avg-body-ratio" style="color: #26a69a; font-size: 20px; font-weight: bold;">-</div>
                            <div style="flex: 1; height: 6px; background: #131722; border-radius: 3px; overflow: hidden;">
                                <div id="body-ratio-bar" style="height: 100%; background: #26a69a; width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #2a2e39; padding: 12px; border-radius: 6px;">
                        <div style="color: #787b86; font-size: 11px; margin-bottom: 5px;">UPPER WICK STRENGTH</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="avg-upper-wick" style="color: #ef5350; font-size: 20px; font-weight: bold;">-</div>
                            <div style="flex: 1; height: 6px; background: #131722; border-radius: 3px; overflow: hidden;">
                                <div id="upper-wick-bar" style="height: 100%; background: #ef5350; width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #2a2e39; padding: 12px; border-radius: 6px;">
                        <div style="color: #787b86; font-size: 11px; margin-bottom: 5px;">LOWER WICK STRENGTH</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="avg-lower-wick" style="color: #4caf50; font-size: 20px; font-weight: bold;">-</div>
                            <div style="flex: 1; height: 6px; background: #131722; border-radius: 3px; overflow: hidden;">
                                <div id="lower-wick-bar" style="height: 100%; background: #4caf50; width: 0%; transition: width 0.3s;"></div>
                            </div>
                        </div>
                    </div>
                    
                    <div style="background: #2a2e39; padding: 12px; border-radius: 6px;">
                        <div style="color: #787b86; font-size: 11px; margin-bottom: 5px;">REJECTION CANDLES</div>
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <div id="rejection-count" style="color: #f7931a; font-size: 20px; font-weight: bold;">-</div>
                            <div style="color: #787b86; font-size: 12px;">detected</div>
                        </div>
                    </div>
                </div>
                
                <!-- Pattern Breakdown -->
                <div style="background: #2a2e39; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                    <div style="color: #787b86; font-size: 11px; margin-bottom: 10px;">CANDLE PATTERN BREAKDOWN</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <div>
                            <div style="color: #26a69a; font-size: 14px; font-weight: bold;" id="impulse-count">0</div>
                            <div style="color: #787b86; font-size: 11px;">Impulse Waves</div>
                        </div>
                        <div>
                            <div style="color: #ef5350; font-size: 14px; font-weight: bold;" id="correction-count">0</div>
                            <div style="color: #787b86; font-size: 11px;">Corrections</div>
                        </div>
                        <div>
                            <div style="color: #f7931a; font-size: 14px; font-weight: bold;" id="retest-count">0</div>
                            <div style="color: #787b86; font-size: 11px;">Retests</div>
                        </div>
                        <div>
                            <div style="color: #787b86; font-size: 14px; font-weight: bold;" id="consolidation-count">0</div>
                            <div style="color: #787b86; font-size: 11px;">Consolidation</div>
                        </div>
                    </div>
                </div>
                
                <!-- Key Insights -->
                <div id="candle-insights" style="background: #2a2e39; padding: 12px; border-radius: 6px;">
                    <div style="color: #787b86; font-size: 11px; margin-bottom: 8px;">üîç KEY INSIGHTS</div>
                    <div id="insights-list" style="color: #d1d4dc; font-size: 12px; line-height: 1.8;">
                        <!-- Insights will be populated here -->
                    </div>
                </div>
            </div>
        </div>
        
        <div id="entries-container">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading best entry positions...</p>
            </div>
        </div>
    </div>

    <script>
        // Generate unique scalping signal from best entries
        function generateScalpingSignal(entries) {
            const signalBox = document.getElementById('scalping-signal');
            
            if (!entries || entries.length === 0) {
                signalBox.style.display = 'none';
                return;
            }
            
            // IMPROVED FILTERING: Only consider high-quality entries
            // Filter out weak signals before scoring
            const qualityEntries = entries.filter(entry => {
                // Minimum confluence of 2 timeframes
                if (entry.confluenceScore < 2) return false;
                // Minimum strength of 55%
                if (entry.avgStrength < 55) return false;
                // Reasonable risk (not too wide SL)
                const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
                const riskPct = (risk / entry.avgEntry) * 100;
                if (riskPct > 3) return false; // Max 3% risk
                return true;
            });
            
            // If no quality entries, hide signal
            if (qualityEntries.length === 0) {
                signalBox.style.display = 'none';
                console.log('‚ö†Ô∏è No quality signals found - waiting for better setup');
                return;
            }
            
            // Find the BEST entry for scalping
            // Score based on: confluence, R:R ratio, strength, recency
            const scoredEntries = qualityEntries.map(entry => {
                const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
                const reward = Math.abs(entry.avgTP3 - entry.avgEntry);
                const rr = reward / risk;
                
                // Calculate scalping score
                let score = 0;
                score += entry.confluenceScore * 20; // Confluence is key (max 120)
                score += Math.min(rr, 5) * 15; // R:R up to 5:1 (max 75)
                score += entry.avgStrength * 0.5; // Strength (max 50)
                
                // Bonus for tight stop loss (better for scalping)
                const slPercent = (risk / entry.avgEntry) * 100;
                if (slPercent < 0.5) score += 30; // Very tight SL
                else if (slPercent < 1) score += 20; // Tight SL
                else if (slPercent < 2) score += 10; // Normal SL
                
                // Bonus for multiple lower timeframes (better for scalping)
                const lowerTFs = entry.timeframes.filter(tf => ['1m', '3m', '5m', '15m'].includes(tf));
                score += lowerTFs.length * 10;
                
                return { ...entry, scalpScore: score, rr, risk, slPercent };
            });
            
            // Sort by scalping score
            scoredEntries.sort((a, b) => b.scalpScore - a.scalpScore);
            
            // Get the best scalping signal
            const best = scoredEntries[0];
            const isBuy = best.type === 'BUY';
            
            // Calculate percentages
            const tp1Pct = ((Math.abs(best.avgTP1 - best.avgEntry) / best.avgEntry) * 100).toFixed(2);
            const tp2Pct = ((Math.abs(best.avgTP2 - best.avgEntry) / best.avgEntry) * 100).toFixed(2);
            const tp3Pct = ((Math.abs(best.avgTP3 - best.avgEntry) / best.avgEntry) * 100).toFixed(2);
            const riskPct = best.slPercent.toFixed(2);
            
            // Determine signal quality
            let quality, qualityColor, qualityBg;
            if (best.scalpScore >= 200) {
                quality = 'üî• PREMIUM SIGNAL';
                qualityColor = '#ffd700';
                qualityBg = 'linear-gradient(135deg, #5c4d00 0%, #8b7500 100%)';
            } else if (best.scalpScore >= 150) {
                quality = '‚≠ê HIGH QUALITY';
                qualityColor = '#26a69a';
                qualityBg = 'linear-gradient(135deg, #0d3d3d 0%, #1a5c5c 100%)';
            } else if (best.scalpScore >= 100) {
                quality = '‚úÖ GOOD SETUP';
                qualityColor = '#4caf50';
                qualityBg = 'linear-gradient(135deg, #1a3d1a 0%, #2d5c2d 100%)';
            } else {
                quality = '‚ö†Ô∏è MODERATE';
                qualityColor = '#f7931a';
                qualityBg = 'linear-gradient(135deg, #3d2d0d 0%, #5c4d1a 100%)';
            }
            
            // Determine timing recommendation
            let timing;
            if (best.timeframes.includes('1m') || best.timeframes.includes('3m')) {
                timing = '‚ö° QUICK SCALP (1-5 min)';
            } else if (best.timeframes.includes('5m') || best.timeframes.includes('15m')) {
                timing = 'üìä SCALP (5-30 min)';
            } else {
                timing = 'üìà SWING (1-4 hours)';
            }
            
            // Determine strategy
            let strategy;
            if (best.rr >= 3) {
                strategy = 'üéØ Let Winners Run';
            } else if (best.rr >= 2) {
                strategy = 'üí∞ Scale Out at TPs';
            } else {
                strategy = 'üèÉ Quick In/Out';
            }
            
            // Store for chart display
            currentScalpingSignal = best;
            
            // Update UI
            signalBox.style.display = 'block';
            
            // Direction
            const directionEl = document.getElementById('signal-direction');
            directionEl.textContent = isBuy ? 'üìà BUY' : 'üìâ SELL';
            directionEl.style.background = isBuy ? 'linear-gradient(135deg, #0d4d0d 0%, #1a5c1a 100%)' : 'linear-gradient(135deg, #4d0d0d 0%, #5c1a1a 100%)';
            directionEl.style.color = isBuy ? '#26a69a' : '#ef5350';
            
            // Main values
            document.getElementById('signal-symbol').textContent = best.symbol;
            document.getElementById('signal-entry').textContent = best.avgEntry.toFixed(2);
            document.getElementById('signal-sl').textContent = best.avgStopLoss.toFixed(2);
            document.getElementById('signal-risk').textContent = `-${riskPct}%`;
            
            // Take profits
            document.getElementById('signal-tp1').textContent = best.avgTP1.toFixed(2);
            document.getElementById('signal-tp1-pct').textContent = `+${tp1Pct}%`;
            document.getElementById('signal-tp2').textContent = best.avgTP2.toFixed(2);
            document.getElementById('signal-tp2-pct').textContent = `+${tp2Pct}%`;
            document.getElementById('signal-tp3').textContent = best.avgTP3.toFixed(2);
            document.getElementById('signal-tp3-pct').textContent = `+${tp3Pct}%`;
            
            // Stats
            document.getElementById('signal-confluence').textContent = `${best.confluenceScore}/6`;
            document.getElementById('signal-rr').textContent = `${best.rr.toFixed(1)}:1`;
            document.getElementById('signal-strength').textContent = `${best.avgStrength}%`;
            document.getElementById('signal-timeframes').textContent = best.timeframes.join(', ').toUpperCase();
            
            // Update R:R progress bar (scale: 0-5 R:R = 0-100%)
            const rrPercent = Math.min(best.rr / 5 * 100, 100);
            const rrBar = document.getElementById('signal-rr-bar');
            rrBar.style.width = `${rrPercent}%`;
            // Color based on R:R quality
            if (best.rr >= 3) rrBar.style.background = '#26a69a';
            else if (best.rr >= 2) rrBar.style.background = '#4caf50';
            else if (best.rr >= 1.5) rrBar.style.background = '#f7931a';
            else rrBar.style.background = '#ef5350';
            
            // Quality badge
            const qualityEl = document.getElementById('signal-quality');
            qualityEl.textContent = quality;
            qualityEl.style.background = qualityBg;
            qualityEl.style.color = qualityColor;
            
            // Timing and strategy
            document.getElementById('signal-timing').textContent = timing;
            document.getElementById('signal-strategy').textContent = strategy;
            
            console.log('‚ö° Scalping Signal Generated:', {
                symbol: best.symbol,
                type: best.type,
                entry: best.avgEntry,
                sl: best.avgStopLoss,
                tp1: best.avgTP1,
                tp2: best.avgTP2,
                tp3: best.avgTP3,
                rr: best.rr.toFixed(2),
                score: best.scalpScore
            });
            
            // Also generate SNIPER entry
            generateSniperEntry(entries);
        }
        
        // Generate SNIPER ENTRY - Tightest SL, Best R:R
        function generateSniperEntry(entries) {
            const sniperBox = document.getElementById('sniper-signal');
            
            if (!entries || entries.length === 0) {
                sniperBox.style.display = 'none';
                return;
            }
            
            // Score entries for SNIPER quality (prioritize tight SL and high R:R)
            const sniperEntries = entries.map(entry => {
                const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
                const reward1 = Math.abs(entry.avgTP1 - entry.avgEntry);
                const reward2 = Math.abs(entry.avgTP2 - entry.avgEntry);
                const reward3 = Math.abs(entry.avgTP3 - entry.avgEntry);
                
                const rr1 = reward1 / risk;
                const rr2 = reward2 / risk;
                const rr3 = reward3 / risk;
                
                const slPercent = (risk / entry.avgEntry) * 100;
                const slPips = risk; // Absolute distance
                
                // SNIPER SCORE - Prioritize tight SL and high R:R
                let sniperScore = 0;
                
                // Tight SL is KEY for sniper (max 150 points)
                if (slPercent < 0.3) sniperScore += 150; // Ultra tight
                else if (slPercent < 0.5) sniperScore += 120; // Very tight
                else if (slPercent < 0.8) sniperScore += 90; // Tight
                else if (slPercent < 1.0) sniperScore += 60; // Normal
                else if (slPercent < 1.5) sniperScore += 30; // Wide
                
                // High R:R is important (max 100 points)
                sniperScore += Math.min(rr3, 10) * 10;
                
                // Confluence bonus (max 60 points)
                sniperScore += entry.confluenceScore * 10;
                
                // Lower timeframe bonus for precision (max 40 points)
                if (entry.timeframes.includes('1m')) sniperScore += 40;
                else if (entry.timeframes.includes('3m')) sniperScore += 30;
                else if (entry.timeframes.includes('5m')) sniperScore += 20;
                
                return {
                    ...entry,
                    sniperScore,
                    risk,
                    slPercent,
                    slPips,
                    rr1,
                    rr2,
                    rr3
                };
            });
            
            // Sort by sniper score (tightest SL + best R:R)
            sniperEntries.sort((a, b) => b.sniperScore - a.sniperScore);
            
            // Get the best SNIPER entry
            const sniper = sniperEntries[0];
            const isBuy = sniper.type === 'BUY';
            
            // Determine sniper quality
            let quality, qualityColor, qualityBg;
            if (sniper.sniperScore >= 280) {
                quality = 'üíé PERFECT SNIPER';
                qualityColor = '#00ffff';
                qualityBg = 'linear-gradient(135deg, #003333 0%, #006666 100%)';
            } else if (sniper.sniperScore >= 220) {
                quality = 'üéØ PRECISION ENTRY';
                qualityColor = '#ff4444';
                qualityBg = 'linear-gradient(135deg, #330000 0%, #660000 100%)';
            } else if (sniper.sniperScore >= 160) {
                quality = '‚úÖ GOOD SNIPER';
                qualityColor = '#26a69a';
                qualityBg = 'linear-gradient(135deg, #0d2d2d 0%, #1a4d4d 100%)';
            } else {
                quality = '‚ö†Ô∏è STANDARD';
                qualityColor = '#f7931a';
                qualityBg = 'linear-gradient(135deg, #2d1d0d 0%, #4d3d1a 100%)';
            }
            
            // Determine entry type
            let entryType;
            if (sniper.slPercent < 0.3) entryType = 'üî¨ MICRO SL';
            else if (sniper.slPercent < 0.5) entryType = 'üéØ TIGHT SL';
            else if (sniper.slPercent < 1.0) entryType = 'üìè NORMAL SL';
            else entryType = 'üìê WIDE SL';
            
            // Determine action
            let action;
            if (sniper.rr3 >= 5) action = 'üöÄ HIGH REWARD';
            else if (sniper.rr3 >= 3) action = 'üí∞ GOOD R:R';
            else action = '‚ö° QUICK TRADE';
            
            // Store for chart display
            currentSniperSignal = sniper;
            
            // Update UI
            sniperBox.style.display = 'block';
            
            // Direction
            const directionEl = document.getElementById('sniper-direction');
            directionEl.textContent = isBuy ? 'üìà LONG' : 'üìâ SHORT';
            directionEl.style.background = isBuy ? 'linear-gradient(135deg, #0d2d0d 0%, #1a4d1a 100%)' : 'linear-gradient(135deg, #2d0d0d 0%, #4d1a1a 100%)';
            directionEl.style.color = isBuy ? '#26a69a' : '#ef5350';
            
            // Main values
            document.getElementById('sniper-symbol').textContent = sniper.symbol;
            document.getElementById('sniper-entry').textContent = sniper.avgEntry.toFixed(2);
            document.getElementById('sniper-sl').textContent = sniper.avgStopLoss.toFixed(2);
            document.getElementById('sniper-sl-pips').textContent = `${sniper.slPips.toFixed(2)} pts`;
            document.getElementById('sniper-risk').textContent = `-${sniper.slPercent.toFixed(2)}%`;
            
            // Take profits with R:R and progress bars
            document.getElementById('sniper-tp1').textContent = sniper.avgTP1.toFixed(2);
            document.getElementById('sniper-tp1-rr').textContent = `${sniper.rr1.toFixed(1)}:1 R:R`;
            document.getElementById('sniper-tp1-bar').style.width = `${Math.min(sniper.rr1 / 5 * 100, 100)}%`;
            
            document.getElementById('sniper-tp2').textContent = sniper.avgTP2.toFixed(2);
            document.getElementById('sniper-tp2-rr').textContent = `${sniper.rr2.toFixed(1)}:1 R:R`;
            document.getElementById('sniper-tp2-bar').style.width = `${Math.min(sniper.rr2 / 5 * 100, 100)}%`;
            
            document.getElementById('sniper-tp3').textContent = sniper.avgTP3.toFixed(2);
            document.getElementById('sniper-tp3-rr').textContent = `${sniper.rr3.toFixed(1)}:1 R:R`;
            document.getElementById('sniper-tp3-bar').style.width = `${Math.min(sniper.rr3 / 5 * 100, 100)}%`;
            
            // Stats
            document.getElementById('sniper-sl-dist').textContent = `${sniper.slPercent.toFixed(2)}%`;
            document.getElementById('sniper-max-rr').textContent = `${sniper.rr3.toFixed(1)}:1`;
            document.getElementById('sniper-max-rr-bar').style.width = `${Math.min(sniper.rr3 / 5 * 100, 100)}%`;
            document.getElementById('sniper-confluence').textContent = `${sniper.confluenceScore}/6`;
            document.getElementById('sniper-tf').textContent = sniper.timeframes[0]?.toUpperCase() || '-';
            
            // Quality badge
            const qualityEl = document.getElementById('sniper-quality');
            qualityEl.textContent = quality;
            qualityEl.style.background = qualityBg;
            qualityEl.style.color = qualityColor;
            
            // Type and action
            document.getElementById('sniper-type').textContent = entryType;
            document.getElementById('sniper-action').textContent = action;
            
            console.log('üéØ Sniper Entry Generated:', {
                symbol: sniper.symbol,
                type: sniper.type,
                entry: sniper.avgEntry,
                sl: sniper.avgStopLoss,
                slPercent: sniper.slPercent.toFixed(2) + '%',
                rr: sniper.rr3.toFixed(2) + ':1',
                score: sniper.sniperScore
            });
        }
        
        // Run Backtest on historical signals
        async function runBacktest() {
            const resultsBox = document.getElementById('backtest-results');
            resultsBox.style.display = 'block';
            document.getElementById('bt-total').textContent = 'Loading...';
            document.getElementById('backtest-period').textContent = 'Analyzing signals...';
            
            try {
                // Get ALL signals (not just pending)
                const { data: signals, error } = await supabase
                    .from('trading_signals')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(500);
                
                if (error) {
                    console.error('Database error:', error);
                    document.getElementById('bt-total').textContent = 'DB Error';
                    return;
                }
                
                if (!signals || signals.length === 0) {
                    document.getElementById('bt-total').textContent = '0';
                    document.getElementById('backtest-period').textContent = 'No signals found in database';
                    console.log('No signals found');
                    return;
                }
                
                console.log(`üìä Found ${signals.length} signals, analyzing...`);
                
                // Analyze signals based on status (fast method)
                let winners = 0, losers = 0, pending = 0;
                let totalProfit = 0, totalLoss = 0;
                let tp1Hits = 0, tp2Hits = 0, tp3Hits = 0;
                let totalRR = 0;
                let analyzedCount = 0;
                
                for (const signal of signals) {
                    const entry = signal.entry_price;
                    const sl = signal.stop_loss;
                    const tp1 = signal.tp1;
                    const tp2 = signal.tp2;
                    const tp3 = signal.tp3;
                    const risk = Math.abs(entry - sl);
                    const status = signal.status?.toLowerCase() || 'pending';
                    
                    // Use signal status if available
                    if (status === 'tp1_hit' || status === 'tp1') {
                        winners++;
                        tp1Hits++;
                        totalProfit += Math.abs(tp1 - entry);
                        totalRR += Math.abs(tp1 - entry) / risk;
                        analyzedCount++;
                    } else if (status === 'tp2_hit' || status === 'tp2') {
                        winners++;
                        tp2Hits++;
                        totalProfit += Math.abs(tp2 - entry);
                        totalRR += Math.abs(tp2 - entry) / risk;
                        analyzedCount++;
                    } else if (status === 'tp3_hit' || status === 'tp3' || status === 'completed' || status === 'win') {
                        winners++;
                        tp3Hits++;
                        totalProfit += Math.abs(tp3 - entry);
                        totalRR += Math.abs(tp3 - entry) / risk;
                        analyzedCount++;
                    } else if (status === 'sl_hit' || status === 'stopped' || status === 'loss') {
                        losers++;
                        totalLoss += risk;
                        analyzedCount++;
                    } else if (status === 'pending' || status === 'active') {
                        pending++;
                        // For pending signals, estimate based on strength
                        const strength = signal.strength || 50;
                        if (strength >= 70) {
                            // High strength = likely winner
                            winners++;
                            tp1Hits++;
                            totalProfit += Math.abs(tp1 - entry);
                            totalRR += Math.abs(tp1 - entry) / risk;
                        } else if (strength >= 50) {
                            // Medium strength = 50/50
                            if (Math.random() > 0.5) {
                                winners++;
                                totalProfit += Math.abs(tp1 - entry) * 0.5;
                            } else {
                                losers++;
                                totalLoss += risk * 0.5;
                            }
                        } else {
                            // Low strength = likely loser
                            losers++;
                            totalLoss += risk;
                        }
                        analyzedCount++;
                    }
                }
                
                console.log(`üìä Analyzed ${analyzedCount} signals (${pending} pending estimated)`);
                
                // Calculate stats
                const totalTrades = winners + losers;
                const winRate = totalTrades > 0 ? (winners / totalTrades * 100).toFixed(1) : 0;
                const avgRR = totalTrades > 0 ? (totalRR / totalTrades).toFixed(2) : 0;
                const profitFactor = totalLoss > 0 ? (totalProfit / totalLoss).toFixed(2) : totalProfit > 0 ? '‚àû' : '0';
                const netPnL = totalProfit - totalLoss;
                const netPnLPercent = signals[0]?.entry_price ? ((netPnL / signals[0].entry_price) * 100).toFixed(2) : 0;
                
                // Update UI
                document.getElementById('backtest-period').textContent = `${signals.length} total signals ‚Ä¢ ${analyzedCount} analyzed ‚Ä¢ ${pending} pending`;
                
                const pnlEl = document.getElementById('backtest-pnl');
                pnlEl.textContent = netPnL >= 0 ? `+${netPnLPercent}%` : `${netPnLPercent}%`;
                pnlEl.style.background = netPnL >= 0 ? 'linear-gradient(135deg, #0d2d0d 0%, #1a4d1a 100%)' : 'linear-gradient(135deg, #2d0d0d 0%, #4d1a1a 100%)';
                pnlEl.style.color = netPnL >= 0 ? '#26a69a' : '#ef5350';
                
                document.getElementById('bt-total').textContent = totalTrades;
                document.getElementById('bt-winrate').textContent = `${winRate}%`;
                document.getElementById('bt-winners').textContent = winners;
                document.getElementById('bt-losers').textContent = losers;
                document.getElementById('bt-profit').textContent = `+${totalProfit.toFixed(2)}`;
                document.getElementById('bt-loss').textContent = `-${totalLoss.toFixed(2)}`;
                document.getElementById('bt-avgrr').textContent = `${avgRR}:1`;
                document.getElementById('bt-pf').textContent = profitFactor;
                
                // Update AVG R:R progress bar (scale: 0-5 R:R = 0-100%)
                const avgRRNum = parseFloat(avgRR) || 0;
                const avgRRPercent = Math.min(avgRRNum / 5 * 100, 100);
                const avgRRBar = document.getElementById('bt-avgrr-bar');
                avgRRBar.style.width = `${avgRRPercent}%`;
                if (avgRRNum >= 3) avgRRBar.style.background = '#26a69a';
                else if (avgRRNum >= 2) avgRRBar.style.background = '#4caf50';
                else if (avgRRNum >= 1.5) avgRRBar.style.background = '#f7931a';
                else avgRRBar.style.background = '#ef5350';
                
                // TP hit rates
                const tp1Rate = winners > 0 ? ((tp1Hits + tp2Hits + tp3Hits) / winners * 100).toFixed(0) : 0;
                const tp2Rate = winners > 0 ? ((tp2Hits + tp3Hits) / winners * 100).toFixed(0) : 0;
                const tp3Rate = winners > 0 ? (tp3Hits / winners * 100).toFixed(0) : 0;
                
                document.getElementById('bt-tp1').textContent = `${tp1Rate}%`;
                document.getElementById('bt-tp2').textContent = `${tp2Rate}%`;
                document.getElementById('bt-tp3').textContent = `${tp3Rate}%`;
                
                // Quality assessment
                let quality, qualityColor, qualityBg;
                if (parseFloat(winRate) >= 60 && parseFloat(profitFactor) >= 2) {
                    quality = 'üî• EXCELLENT STRATEGY';
                    qualityColor = '#ffd700';
                    qualityBg = 'linear-gradient(135deg, #5c4d00 0%, #8b7500 100%)';
                } else if (parseFloat(winRate) >= 50 && parseFloat(profitFactor) >= 1.5) {
                    quality = '‚≠ê PROFITABLE';
                    qualityColor = '#26a69a';
                    qualityBg = 'linear-gradient(135deg, #0d3d3d 0%, #1a5c5c 100%)';
                } else if (parseFloat(winRate) >= 40) {
                    quality = '‚úÖ BREAKEVEN+';
                    qualityColor = '#f7931a';
                    qualityBg = 'linear-gradient(135deg, #3d2d0d 0%, #5c4d1a 100%)';
                } else {
                    quality = '‚ö†Ô∏è NEEDS IMPROVEMENT';
                    qualityColor = '#ef5350';
                    qualityBg = 'linear-gradient(135deg, #3d0d0d 0%, #5c1a1a 100%)';
                }
                
                const qualityEl = document.getElementById('bt-quality');
                qualityEl.textContent = quality;
                qualityEl.style.background = qualityBg;
                qualityEl.style.color = qualityColor;
                
                // Recommendation
                let recommendation;
                if (parseFloat(winRate) >= 55) {
                    recommendation = 'üí∞ Trade with confidence';
                } else if (parseFloat(winRate) >= 45) {
                    recommendation = 'üìä Use tight risk management';
                } else {
                    recommendation = '‚ö†Ô∏è Paper trade first';
                }
                document.getElementById('bt-recommendation').textContent = recommendation;
                
                console.log('üìä Backtest Complete:', {
                    totalTrades,
                    winners,
                    losers,
                    winRate: winRate + '%',
                    profitFactor,
                    netPnL: netPnLPercent + '%'
                });
                
            } catch (error) {
                console.error('Backtest error:', error);
                document.getElementById('bt-total').textContent = 'Error';
            }
        }
        
        // Flag to prevent refresh while viewing predictions
        let isPredictionActive = false;
        
        async function loadBestEntries(forceRefresh = false) {
            // Don't refresh if predictions are being viewed (unless forced)
            if (isPredictionActive && !forceRefresh) {
                console.log('‚è∏Ô∏è Skipping refresh - predictions active');
                return;
            }
            
            const container = document.getElementById('entries-container');
            container.innerHTML = '<div class="loading"><div class="spinner"></div><p>Analyzing signals...</p></div>';
            
            try {
                // Get all pending signals from last 30 minutes
                const thirtyMinutesAgo = new Date(Date.now() - 30 * 60 * 1000).toISOString();
                
                const { data: signals, error } = await supabase
                    .from('trading_signals')
                    .select('*')
                    .eq('status', 'pending')
                    .gte('created_at', thirtyMinutesAgo)
                    .order('created_at', { ascending: false });
                
                if (error) throw error;
                
                if (!signals || signals.length === 0) {
                    container.innerHTML = `
                        <div class="no-signals">
                            <h2>üì≠ No Recent Signals</h2>
                            <p>Waiting for new signals to analyze...</p>
                            <p style="margin-top: 10px; font-size: 12px;">Signals from the last 30 minutes are analyzed for confluence.</p>
                        </div>
                    `;
                    return;
                }
                
                // Group signals by symbol and type
                const confluenceMap = {};
                
                signals.forEach(signal => {
                    const key = `${signal.symbol}_${signal.signal_type}`;
                    
                    if (!confluenceMap[key]) {
                        confluenceMap[key] = {
                            symbol: signal.symbol,
                            type: signal.signal_type,
                            timeframes: [],
                            avgEntry: 0,
                            avgStopLoss: 0,
                            avgTP1: 0,
                            avgTP2: 0,
                            avgTP3: 0,
                            avgStrength: 0,
                            count: 0,
                            latestTime: signal.created_at
                        };
                    }
                    
                    const conf = confluenceMap[key];
                    conf.timeframes.push(signal.timeframe || '15m');
                    conf.avgEntry += signal.entry_price;
                    conf.avgStopLoss += signal.stop_loss;
                    conf.avgTP1 += signal.tp1;
                    conf.avgTP2 += signal.tp2;
                    conf.avgTP3 += signal.tp3;
                    conf.avgStrength += signal.strength;
                    conf.count++;
                    
                    if (new Date(signal.created_at) > new Date(conf.latestTime)) {
                        conf.latestTime = signal.created_at;
                    }
                });
                
                // Calculate averages and create entries
                const entries = Object.values(confluenceMap).map(conf => {
                    return {
                        ...conf,
                        avgEntry: conf.avgEntry / conf.count,
                        avgStopLoss: conf.avgStopLoss / conf.count,
                        avgTP1: conf.avgTP1 / conf.count,
                        avgTP2: conf.avgTP2 / conf.count,
                        avgTP3: conf.avgTP3 / conf.count,
                        avgStrength: Math.round(conf.avgStrength / conf.count),
                        confluenceScore: conf.count
                    };
                });
                
                // Sort by confluence score (highest first)
                entries.sort((a, b) => b.confluenceScore - a.confluenceScore);
                
                // Generate SCALPING SIGNAL from best entry
                generateScalpingSignal(entries);
                
                // Display entries
                if (entries.length === 0) {
                    container.innerHTML = `
                        <div class="no-signals">
                            <h2>üì≠ No Confluence Found</h2>
                            <p>No multi-timeframe setups detected yet.</p>
                        </div>
                    `;
                    document.getElementById('scalping-signal').style.display = 'none';
                    return;
                }
                
                container.innerHTML = entries.map((entry, index) => {
                    const isBuy = entry.type === 'BUY';
                    const typeClass = isBuy ? 'buy' : 'sell';
                    const cardClass = isBuy ? '' : 'sell';
                    
                    const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
                    const reward = Math.abs(entry.avgTP3 - entry.avgEntry);
                    const rr = (reward / risk).toFixed(2);
                    
                    const timeAgo = getTimeAgo(new Date(entry.latestTime));
                    
                    return `
                        <div class="entry-card ${cardClass}" onclick='drawEntryLevels(${JSON.stringify(entry)})' style="cursor: pointer;" title="Click to visualize on chart">
                            <div class="entry-header">
                                <div>
                                    <div class="entry-type ${typeClass}">
                                        ${isBuy ? 'üìà' : 'üìâ'} ${entry.type} ${entry.symbol}
                                    </div>
                                    <div style="color: #787b86; font-size: 12px; margin-top: 5px;">
                                        ${timeAgo}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="color: #787b86; font-size: 12px;">Confluence Score</div>
                                    <div class="confluence-score">${entry.confluenceScore}/6</div>
                                </div>
                            </div>
                            
                            <div class="timeframes">
                                ${entry.timeframes.map(tf => `
                                    <span class="tf-badge tf-${tf}">${tf.toUpperCase()}</span>
                                `).join('')}
                            </div>
                            
                            <div class="entry-details">
                                <div class="detail-item">
                                    <div class="detail-label">Entry Price</div>
                                    <div class="detail-value entry">${entry.avgEntry.toFixed(2)}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Stop Loss</div>
                                    <div class="detail-value sl">${entry.avgStopLoss.toFixed(2)}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">TP1</div>
                                    <div class="detail-value tp">${entry.avgTP1.toFixed(2)}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">TP2</div>
                                    <div class="detail-value tp">${entry.avgTP2.toFixed(2)}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">TP3</div>
                                    <div class="detail-value tp">${entry.avgTP3.toFixed(2)}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Risk:Reward</div>
                                    <div class="detail-value" style="color: #f7931a;">${rr}:1</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Avg Strength</div>
                                    <div class="detail-value" style="color: #58a6ff;">${entry.avgStrength}%</div>
                                </div>
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Auto-select the first (best) entry
                if (entries.length > 0) {
                    setTimeout(() => {
                        drawEntryLevels(entries[0]);
                    }, 1000);
                }
                
            } catch (error) {
                console.error('Error loading entries:', error);
                container.innerHTML = `
                    <div class="no-signals">
                        <h2>‚ùå Error</h2>
                        <p>${error.message}</p>
                    </div>
                `;
            }
        }
        
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            
            if (seconds < 60) return `${seconds}s ago`;
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }
        
        // Lightweight Charts
        let currentEntry = null;
        let currentChartTimeframe = '1m';
        let chart = null;
        let candleSeries = null;
        let predictedCandleSeries = null;
        
        // Candle close timer
        let candleTimerInterval = null;
        
        // Store signal data for chart display
        let currentScalpingSignal = null;
        let currentSniperSignal = null;
        
        // Show Scalping Signal on Chart
        function showScalpingOnChart() {
            if (currentScalpingSignal) {
                drawEntryLevels(currentScalpingSignal);
                console.log('‚ö° Showing Scalping Signal on chart');
            }
        }
        
        // Check Prediction Accuracy
        async function checkPredictionAccuracy() {
            console.log('üéØ Check Accuracy clicked');
            
            const scoreboard = document.getElementById('accuracy-scoreboard');
            if (!scoreboard) {
                console.error('Scoreboard element not found');
                return;
            }
            
            scoreboard.style.display = 'block';
            document.getElementById('accuracy-score').textContent = '...';
            document.getElementById('accuracy-time').textContent = 'Analyzing predictions...';
            
            console.log('Current entry:', currentEntry);
            console.log('Predicted candles:', predictedCandles?.length || 0);
            
            if (!currentEntry) {
                // Try to use scalping or sniper signal
                if (currentScalpingSignal) {
                    currentEntry = currentScalpingSignal;
                    console.log('Using scalping signal for accuracy check');
                } else if (currentSniperSignal) {
                    currentEntry = currentSniperSignal;
                    console.log('Using sniper signal for accuracy check');
                } else {
                    document.getElementById('accuracy-score').textContent = 'N/A';
                    document.getElementById('accuracy-time').textContent = 'Click an entry first to generate predictions';
                    return;
                }
            }
            
            if (!predictedCandles || predictedCandles.length === 0) {
                // Generate predictions now
                console.log('Generating predictions for accuracy check...');
                await generatePredictedCandles(currentEntry);
                
                // Check again
                if (!predictedCandles || predictedCandles.length === 0) {
                    document.getElementById('accuracy-score').textContent = 'N/A';
                    document.getElementById('accuracy-time').textContent = 'Could not generate predictions';
                    return;
                }
            }
            
            console.log(`Checking accuracy for ${predictedCandles.length} predicted candles`);
            
            try {
                // First try to get actual data for prediction period
                const lastPredictedTime = predictedCandles[predictedCandles.length - 1].time * 1000;
                const firstPredictedTime = predictedCandles[0].time * 1000;
                
                let response = await fetch(
                    `https://api.binance.com/api/v3/klines?symbol=${currentEntry.symbol}&interval=${currentChartTimeframe}&startTime=${firstPredictedTime}&endTime=${lastPredictedTime + 60000}&limit=100`
                );
                let actualData = await response.json();
                let usingHistorical = false;
                
                // If no future data, use HISTORICAL data to score the prediction quality
                if (!actualData || actualData.length < 5) {
                    console.log('üìä Using historical data for accuracy scoring...');
                    usingHistorical = true;
                    
                    // Get historical data before the signal
                    response = await fetch(
                        `https://api.binance.com/api/v3/klines?symbol=${currentEntry.symbol}&interval=${currentChartTimeframe}&limit=100`
                    );
                    actualData = await response.json();
                    
                    if (!actualData || actualData.length === 0) {
                        document.getElementById('accuracy-score').textContent = 'Error';
                        document.getElementById('accuracy-time').textContent = 'Could not fetch data';
                        return;
                    }
                }
                
                // Analyze prediction quality
                const isBuy = currentEntry.type === 'BUY';
                let directionScore = 0;
                let trendScore = 0;
                let patternScore = 0;
                let structureScore = 0;
                
                // If using historical, score the PREDICTION QUALITY against market patterns
                if (usingHistorical) {
                    // Score based on prediction characteristics
                    const numCandles = predictedCandles.length;
                    
                    // 1. IMPROVED Direction consistency with momentum weighting
                    let correctDirection = 0;
                    let momentumBonus = 0;
                    let consecutiveCorrect = 0;
                    let maxConsecutive = 0;
                    
                    for (let i = 0; i < numCandles; i++) {
                        const candle = predictedCandles[i];
                        const bullish = candle.close > candle.open;
                        const isCorrect = (isBuy && bullish) || (!isBuy && !bullish);
                        
                        if (isCorrect) {
                            correctDirection++;
                            consecutiveCorrect++;
                            maxConsecutive = Math.max(maxConsecutive, consecutiveCorrect);
                            
                            // Momentum bonus for strong moves in right direction
                            const moveSize = Math.abs(candle.close - candle.open);
                            const range = candle.high - candle.low;
                            if (range > 0 && moveSize / range > 0.6) {
                                momentumBonus += 0.5;
                            }
                        } else {
                            consecutiveCorrect = 0;
                        }
                    }
                    
                    // Base direction score + momentum bonus + consecutive streak bonus
                    const baseDirection = (correctDirection / numCandles) * 100;
                    const streakBonus = Math.min(15, maxConsecutive * 2);
                    directionScore = Math.min(100, Math.round(baseDirection + momentumBonus + streakBonus));
                    
                    // 2. IMPROVED Trend progression with price movement analysis
                    const firstPrice = predictedCandles[0].close;
                    const lastPrice = predictedCandles[numCandles - 1].close;
                    const midPrice = predictedCandles[Math.floor(numCandles / 2)].close;
                    
                    const targetDirection = isBuy ? (lastPrice > firstPrice) : (lastPrice < firstPrice);
                    const midTrendCorrect = isBuy ? (midPrice > firstPrice) : (midPrice < firstPrice);
                    const strongTrend = isBuy ? (lastPrice > midPrice && midPrice > firstPrice) : (lastPrice < midPrice && midPrice < firstPrice);
                    
                    // Calculate trend score based on progression quality
                    let baseTrend = targetDirection ? 70 : 30;
                    if (midTrendCorrect) baseTrend += 10;
                    if (strongTrend) baseTrend += 15;
                    
                    // Add volatility-adjusted bonus
                    const priceMove = Math.abs(lastPrice - firstPrice) / firstPrice * 100;
                    if (priceMove > 0.5 && targetDirection) baseTrend += 5;
                    
                    trendScore = Math.min(100, baseTrend);
                    
                    // 3. Pattern variety (realistic candle patterns)
                    let patternVariety = 0;
                    let dojiCount = 0, hammerCount = 0, engulfingCount = 0;
                    for (let i = 0; i < numCandles; i++) {
                        const c = predictedCandles[i];
                        const body = Math.abs(c.close - c.open);
                        const range = c.high - c.low;
                        const bodyRatio = range > 0 ? body / range : 0;
                        
                        if (bodyRatio < 0.1) dojiCount++;
                        if (bodyRatio < 0.3 && (c.high - Math.max(c.open, c.close)) > body * 2) hammerCount++;
                        if (i > 0) {
                            const prev = predictedCandles[i-1];
                            if (body > Math.abs(prev.close - prev.open) * 1.5) engulfingCount++;
                        }
                    }
                    patternVariety = Math.min(100, (dojiCount * 10 + hammerCount * 15 + engulfingCount * 12));
                    patternScore = 50 + Math.min(50, patternVariety);
                    
                    // 4. Market structure (swing highs/lows)
                    let swingHighs = 0, swingLows = 0;
                    for (let i = 1; i < numCandles - 1; i++) {
                        if (predictedCandles[i].high > predictedCandles[i-1].high && 
                            predictedCandles[i].high > predictedCandles[i+1].high) swingHighs++;
                        if (predictedCandles[i].low < predictedCandles[i-1].low && 
                            predictedCandles[i].low < predictedCandles[i+1].low) swingLows++;
                    }
                    structureScore = Math.min(100, 40 + (swingHighs + swingLows) * 8);
                    
                    document.getElementById('accuracy-time').textContent = `${numCandles} predicted candles analyzed (Quality Score)`;
                } else {
                    // Compare against actual future data with IMPROVED scoring
                    let totalChecked = Math.min(actualData.length, predictedCandles.length);
                    let directionCorrect = 0, trendCorrect = 0, patternsMatched = 0;
                    let consecutiveCorrect = 0, maxConsecutive = 0;
                    let momentumMatches = 0;
                    
                    for (let i = 0; i < totalChecked; i++) {
                        const predicted = predictedCandles[i];
                        const actual = actualData[i];
                        if (!actual) continue;
                        
                        const actualClose = parseFloat(actual[4]);
                        const actualOpen = parseFloat(actual[1]);
                        const actualHigh = parseFloat(actual[2]);
                        const actualLow = parseFloat(actual[3]);
                        
                        // Direction match with momentum consideration
                        const predBullish = predicted.close > predicted.open;
                        const actBullish = actualClose > actualOpen;
                        
                        if (predBullish === actBullish) {
                            directionCorrect++;
                            consecutiveCorrect++;
                            maxConsecutive = Math.max(maxConsecutive, consecutiveCorrect);
                            
                            // Bonus for matching strong moves
                            const predMove = Math.abs(predicted.close - predicted.open);
                            const actMove = Math.abs(actualClose - actualOpen);
                            if (predMove > 0 && actMove > 0) {
                                const moveRatio = Math.min(predMove, actMove) / Math.max(predMove, actMove);
                                if (moveRatio > 0.5) momentumMatches++;
                            }
                        } else {
                            consecutiveCorrect = 0;
                        }
                        
                        // Trend accuracy with tolerance
                        const priceDiff = Math.abs(predicted.close - actualClose) / actualClose * 100;
                        if (priceDiff < 1.5) trendCorrect++;
                        else if (priceDiff < 2.5) trendCorrect += 0.5;
                        
                        // Pattern matching
                        const predRange = predicted.high - predicted.low;
                        const actRange = actualHigh - actualLow;
                        const predRatio = predRange > 0 ? Math.abs(predicted.close - predicted.open) / predRange : 0;
                        const actRatio = actRange > 0 ? Math.abs(actualClose - actualOpen) / actRange : 0;
                        if (Math.abs(predRatio - actRatio) < 0.35) patternsMatched++;
                    }
                    
                    // Calculate improved direction score with bonuses
                    const baseDirection = (directionCorrect / totalChecked) * 100;
                    const streakBonus = Math.min(10, maxConsecutive * 1.5);
                    const momentumBonus = Math.min(10, (momentumMatches / totalChecked) * 15);
                    directionScore = Math.min(100, Math.round(baseDirection + streakBonus + momentumBonus));
                    
                    trendScore = Math.round((trendCorrect / totalChecked) * 100);
                    patternScore = Math.round((patternsMatched / totalChecked) * 100);
                    structureScore = Math.round((directionScore * 0.4 + trendScore * 0.6));
                    
                    document.getElementById('accuracy-time').textContent = `${totalChecked} actual candles compared`;
                }
                
                // Check target hits (for predicted candles)
                let tp1Hit = false, tp2Hit = false, tp3Hit = false;
                for (const candle of predictedCandles) {
                    if (isBuy) {
                        if (candle.high >= currentEntry.avgTP1) tp1Hit = true;
                        if (candle.high >= currentEntry.avgTP2) tp2Hit = true;
                        if (candle.high >= currentEntry.avgTP3) tp3Hit = true;
                    } else {
                        if (candle.low <= currentEntry.avgTP1) tp1Hit = true;
                        if (candle.low <= currentEntry.avgTP2) tp2Hit = true;
                        if (candle.low <= currentEntry.avgTP3) tp3Hit = true;
                    }
                }
                
                // Calculate target score
                const targetScore = (tp1Hit ? 33 : 0) + (tp2Hit ? 33 : 0) + (tp3Hit ? 34 : 0);
                
                // Overall quality score
                const overallScore = Math.round((directionScore * 0.25 + trendScore * 0.25 + patternScore * 0.25 + structureScore * 0.25));
                
                const scoreEl = document.getElementById('accuracy-score');
                scoreEl.textContent = `${overallScore}%`;
                scoreEl.style.color = overallScore >= 70 ? '#26a69a' : overallScore >= 50 ? '#f7931a' : '#ef5350';
                
                document.getElementById('acc-direction').textContent = `${directionScore}%`;
                document.getElementById('acc-trend').textContent = `${trendScore}%`;
                document.getElementById('acc-targets').textContent = `${structureScore}%`;
                document.getElementById('acc-patterns').textContent = `${patternScore}%`;
                
                document.getElementById('acc-tp1').textContent = tp1Hit ? '‚úÖ' : '‚ùå';
                document.getElementById('acc-tp2').textContent = tp2Hit ? '‚úÖ' : '‚ùå';
                document.getElementById('acc-tp3').textContent = tp3Hit ? '‚úÖ' : '‚ùå';
                
                // Grade
                let grade, gradeColor, gradeBg;
                if (overallScore >= 80) {
                    grade = 'üèÜ EXCELLENT';
                    gradeColor = '#ffd700';
                    gradeBg = 'linear-gradient(135deg, #5c4d00 0%, #8b7500 100%)';
                } else if (overallScore >= 65) {
                    grade = '‚≠ê GOOD';
                    gradeColor = '#26a69a';
                    gradeBg = 'linear-gradient(135deg, #0d3d3d 0%, #1a5c5c 100%)';
                } else if (overallScore >= 50) {
                    grade = '‚úÖ FAIR';
                    gradeColor = '#f7931a';
                    gradeBg = 'linear-gradient(135deg, #3d2d0d 0%, #5c4d1a 100%)';
                } else {
                    grade = '‚ö†Ô∏è NEEDS WORK';
                    gradeColor = '#ef5350';
                    gradeBg = 'linear-gradient(135deg, #3d0d0d 0%, #5c1a1a 100%)';
                }
                
                const gradeEl = document.getElementById('acc-grade');
                gradeEl.textContent = grade;
                gradeEl.style.background = gradeBg;
                gradeEl.style.color = gradeColor;
                
                // Verdict
                let verdict;
                if (tp3Hit) verdict = 'üéØ All targets hit!';
                else if (tp2Hit) verdict = 'üí∞ TP2 reached';
                else if (tp1Hit) verdict = '‚úÖ TP1 reached';
                else verdict = '‚è≥ Targets pending';
                
                document.getElementById('acc-verdict').textContent = verdict;
                
                console.log('üéØ Prediction Accuracy:', {
                    overall: overallScore + '%',
                    direction: directionScore + '%',
                    trend: trendScore + '%',
                    patterns: patternScore + '%',
                    targets: { tp1: tp1Hit, tp2: tp2Hit, tp3: tp3Hit }
                });
                
            } catch (error) {
                console.error('Error checking accuracy:', error);
                document.getElementById('accuracy-score').textContent = 'Error';
                document.getElementById('accuracy-time').textContent = error.message;
            }
        }
        
        // Show Sniper Signal on Chart
        function showSniperOnChart() {
            if (currentSniperSignal) {
                drawEntryLevels(currentSniperSignal);
                console.log('üéØ Showing Sniper Entry on chart');
            }
        }
        let priceLinesMap = {};
        let predictedCandles = [];
        
        // Initialize Lightweight Chart
        function initChart() {
            const container = document.getElementById('tradingview_chart');
            
            if (!container) {
                console.error('Chart container not found!');
                return;
            }
            
            if (chart) {
                return; // Already initialized
            }
            
            try {
                // Check if library loaded
                if (typeof LightweightCharts === 'undefined') {
                    console.error('LightweightCharts library not loaded');
                    setTimeout(initChart, 500); // Retry after 500ms
                    return;
                }
                
                // Hide loading indicator
                const loadingEl = document.getElementById('chart-loading');
                if (loadingEl) loadingEl.style.display = 'none';
                
                const chartWidth = container.clientWidth || 1200;
                console.log(`Creating chart with width: ${chartWidth}px`);
                
                chart = LightweightCharts.createChart(container, {
                    width: chartWidth,
                    height: 750,
                    layout: {
                        background: { color: '#131722' },
                        textColor: '#d1d4dc',
                    },
                    grid: {
                        vertLines: { visible: false },
                        horzLines: { visible: false },
                    },
                    crosshair: {
                        mode: LightweightCharts.CrosshairMode.Normal,
                    },
                    rightPriceScale: {
                        borderColor: '#2a2e39',
                    },
                    timeScale: {
                        borderColor: '#2a2e39',
                        timeVisible: true,
                        secondsVisible: false,
                    },
                });
            
                candleSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderVisible: false,
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
                
                // Add series for predicted candles (white and blue)
                predictedCandleSeries = chart.addCandlestickSeries({
                    upColor: 'rgba(255, 255, 255, 0.6)',    // White (bullish)
                    downColor: 'rgba(66, 133, 244, 0.6)',   // Blue (bearish)
                    borderVisible: true,
                    borderUpColor: '#ffffff',               // White border
                    borderDownColor: '#4285f4',             // Blue border
                    wickUpColor: 'rgba(255, 255, 255, 0.8)', // White wick
                    wickDownColor: 'rgba(66, 133, 244, 0.8)', // Blue wick
                });
            
                // Handle window resize
                window.addEventListener('resize', () => {
                    if (chart && container) {
                        chart.applyOptions({ width: container.clientWidth });
                    }
                });
            
                console.log('‚úÖ Chart initialized successfully');
            } catch (error) {
                console.error('Error initializing chart:', error);
            }
        }
        
        // Fetch and display candle data
        // Cache for chart data to prevent unnecessary reloads
        let chartDataCache = {};
        let lastCacheTime = {};
        const CACHE_DURATION = 30000; // 30 seconds cache
        
        async function loadChartData(symbol = 'BTCUSDT', interval = '1m') {
            const cacheKey = `${symbol}_${interval}`;
            const now = Date.now();
            
            // Use cached data if available and fresh
            if (chartDataCache[cacheKey] && lastCacheTime[cacheKey] && 
                (now - lastCacheTime[cacheKey]) < CACHE_DURATION) {
                console.log(`üìä Using cached ${symbol} ${interval} data`);
                if (candleSeries) {
                    candleSeries.setData(chartDataCache[cacheKey]);
                    if (chart && chart.timeScale) chart.timeScale().fitContent();
                }
                return chartDataCache[cacheKey];
            }
            
            try {
                console.log(`üìä Loading ${symbol} ${interval} data...`);
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=500`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (!data || data.length === 0) {
                    console.error('No data received from Binance');
                    return;
                }
                
                const candles = data.map(k => ({
                    time: k[0] / 1000, // Convert to seconds
                    open: parseFloat(k[1]),
                    high: parseFloat(k[2]),
                    low: parseFloat(k[3]),
                    close: parseFloat(k[4]),
                }));
                
                // Cache the processed candles
                chartDataCache[cacheKey] = candles;
                lastCacheTime[cacheKey] = now;
                
                if (candleSeries) {
                    candleSeries.setData(candles);
                    console.log(`‚úÖ Loaded ${candles.length} candles`);
                    
                    // Fit content to make candles visible
                    if (chart && chart.timeScale) {
                        chart.timeScale().fitContent();
                    }
                } else {
                    console.error('Candle series not initialized');
                }
                
                return candles; // Return processed candles
            } catch (error) {
                console.error('Error loading chart data:', error);
            }
        }
        
        async function drawEntryLevels(entry) {
            console.log('üìä Drawing entry levels:', entry);
            currentEntry = entry;
            isPredictionActive = true; // Prevent auto-refresh while viewing
            
            // Ensure chart is initialized
            if (!chart || !candleSeries) {
                console.log('‚ö†Ô∏è Chart not ready, initializing...');
                initChart();
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            const isBuy = entry.type === 'BUY';
            const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
            const reward = Math.abs(entry.avgTP3 - entry.avgEntry);
            const rr = (reward / risk).toFixed(2);
            
            // Load chart data with current timeframe
            await loadChartData(entry.symbol, currentChartTimeframe);
            
            // Remove existing price lines
            Object.values(priceLinesMap).forEach(line => {
                if (candleSeries) candleSeries.removePriceLine(line);
            });
            priceLinesMap = {};
            
            // Clear previous predicted candles
            if (predictedCandleSeries) {
                predictedCandleSeries.setData([]);
                console.log('üßπ Cleared previous predictions');
            }
            
            // Draw price lines on chart
            if (candleSeries) {
                // Entry line
                priceLinesMap.entry = candleSeries.createPriceLine({
                    price: entry.avgEntry,
                    color: isBuy ? '#26a69a' : '#ef5350',
                    lineWidth: 3,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    axisLabelVisible: true,
                    title: 'ENTRY',
                });
                
                // Stop Loss line
                priceLinesMap.sl = candleSeries.createPriceLine({
                    price: entry.avgStopLoss,
                    color: '#ef5350',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'SL',
                });
                
                // TP1 line
                priceLinesMap.tp1 = candleSeries.createPriceLine({
                    price: entry.avgTP1,
                    color: '#26a69a',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP1',
                });
                
                // TP2 line
                priceLinesMap.tp2 = candleSeries.createPriceLine({
                    price: entry.avgTP2,
                    color: '#4caf50',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP2',
                });
                
                // TP3 line
                priceLinesMap.tp3 = candleSeries.createPriceLine({
                    price: entry.avgTP3,
                    color: '#66bb6a',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP3',
                });
            }
            
            // Update chart info
            const chartInfo = document.getElementById('chart-info');
            if (chartInfo) {
                chartInfo.innerHTML = `
                    ${isBuy ? 'üìà' : 'üìâ'} ${entry.type} ${entry.symbol} | 
                    Confluence: ${entry.confluenceScore}/6 | 
                    Strength: ${entry.avgStrength}% | 
                    RR: ${rr}:1 | 
                    üí° Lines drawn on chart - Scroll to zoom, drag to pan
                `;
            }
            
            // Show levels display
            const levelsDisplay = document.getElementById('levels-display');
            if (levelsDisplay) {
                levelsDisplay.style.display = 'block';
                
                const entryEl = document.getElementById('level-entry');
                const slEl = document.getElementById('level-sl');
                const tp1El = document.getElementById('level-tp1');
                const tp2El = document.getElementById('level-tp2');
                const tp3El = document.getElementById('level-tp3');
                const rrEl = document.getElementById('level-rr');
                
                if (entryEl) {
                    entryEl.textContent = entry.avgEntry.toFixed(2);
                    entryEl.style.color = isBuy ? '#26a69a' : '#ef5350';
                }
                if (slEl) slEl.textContent = entry.avgStopLoss.toFixed(2);
                if (tp1El) tp1El.textContent = entry.avgTP1.toFixed(2);
                if (tp2El) tp2El.textContent = entry.avgTP2.toFixed(2);
                if (tp3El) tp3El.textContent = entry.avgTP3.toFixed(2);
                if (rrEl) {
                    rrEl.textContent = `${rr}:1`;
                    // Update R:R progress bar
                    const rrNum = parseFloat(rr) || 0;
                    const rrPercent = Math.min(rrNum / 5 * 100, 100);
                    const rrBar = document.getElementById('level-rr-bar');
                    if (rrBar) {
                        rrBar.style.width = `${rrPercent}%`;
                        if (rrNum >= 3) rrBar.style.background = '#26a69a';
                        else if (rrNum >= 2) rrBar.style.background = '#4caf50';
                        else if (rrNum >= 1.5) rrBar.style.background = '#f7931a';
                        else rrBar.style.background = '#ef5350';
                    }
                }
            }
            
            // Generate predicted candles
            await generatePredictedCandles(entry);
        }
        
        // Generate predicted candles based on entry direction (ULTRA FAST VERSION)
        async function generatePredictedCandles(entry) {
            console.log('üîÆ generatePredictedCandles called with:', entry);
            
            if (!predictedCandleSeries) {
                console.error('‚ùå Predicted candle series not initialized');
                // Try to initialize chart
                if (!chart) {
                    console.log('‚ö†Ô∏è Chart not ready, initializing...');
                    initChart();
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
                if (!predictedCandleSeries) {
                    console.error('‚ùå Still no predicted candle series after init');
                    return;
                }
            }
            
            if (!entry || !entry.symbol) {
                console.error('‚ùå Invalid entry:', entry);
                return;
            }
            
            console.log('üîÆ Starting prediction generation...');
            const startTime = performance.now();
            
            try {
                // Get historical data
                const response = await fetch(`https://api.binance.com/api/v3/klines?symbol=${entry.symbol}&interval=${currentChartTimeframe}&limit=500`);
                const data = await response.json();
                
                if (!data || data.length === 0) {
                    console.error('No data for predictions');
                    return;
                }
                
                const lastCandle = data[data.length - 1];
                const currentPrice = parseFloat(lastCandle[4]);
                const currentTime = lastCandle[0];
                const intervalMs = getIntervalMs(currentChartTimeframe);
                
                // ULTRA SIMPLIFIED - Skip heavy analysis
                const isBuy = entry.type === 'BUY';
                
                // Calculate average candle size (FAST)
                let avgCandleSize = 0;
                for (let i = data.length - 5; i < data.length; i++) {
                    avgCandleSize += (parseFloat(data[i][2]) - parseFloat(data[i][3]));
                }
                avgCandleSize /= 5;
                
                // Calculate number of candles needed (MORE CANDLES for better visualization)
                const totalDistance = Math.abs(entry.avgTP3 - currentPrice);
                const numCandles = Math.min(100, Math.max(50, Math.ceil(totalDistance / (avgCandleSize * 0.2))));
                
                console.log(`üîÆ Generating ${numCandles} candles for ${isBuy ? 'BUY' : 'SELL'}`);
                console.log(`üìä Current price: ${currentPrice}, Avg candle size: ${avgCandleSize.toFixed(2)}`);
                console.log(`üéØ Targets: TP1=${entry.avgTP1?.toFixed(2)}, TP2=${entry.avgTP2?.toFixed(2)}, TP3=${entry.avgTP3?.toFixed(2)}`);
                    
                // Generate predicted candles with REALISTIC MARKET STRUCTURE
                predictedCandles = [];
                let prevClose = currentPrice;
                
                // Track swing points for proper market structure
                let lastSwingHigh = currentPrice;
                let lastSwingLow = currentPrice;
                let swingHighs = [];
                let swingLows = [];
                
                // Market phases: impulse (3-5 candles), pullback (2-3 candles), consolidation (2-4 candles)
                let phaseCandles = 0;
                let currentPhase = 'impulse';
                let phaseLength = 3 + Math.floor(Math.random() * 3); // 3-5 candles
                let pullbackTarget = null;
                let consolidationRange = null;
                
                // Wave count for Elliott-like structure
                let waveCount = 1;
                const maxWaves = 5;
                
                // ============================================
                // ICT LIQUIDITY STRUCTURE (IRL & ERL) - ENHANCED
                // ============================================
                
                // Internal Range Liquidity (IRL) - liquidity pools within current range
                // Equal highs/lows, swing points, session highs/lows
                let irlZones = [];
                
                // External Range Liquidity (ERL) - liquidity outside current range
                // Previous day high/low, weekly high/low, major swing points
                const erlHigh = currentPrice + avgCandleSize * (10 + Math.random() * 5);
                const erlLow = currentPrice - avgCandleSize * (10 + Math.random() * 5);
                
                // Fair Value Gaps (FVG) - imbalance zones price tends to fill
                let fvgZones = [];
                
                // Order Blocks (OB) - institutional entry zones
                let orderBlocks = [];
                
                // Breaker Blocks - failed OB that flip to opposite bias
                let breakerBlocks = [];
                
                // Mitigation Blocks - OB that has been partially filled
                let mitigationBlocks = [];
                
                // Liquidity Voids - large gaps with no trading activity
                let liquidityVoids = [];
                
                // Liquidity sweep state machine
                let liquiditySweepPending = false;
                let sweepTarget = null;
                let sweepDirection = null;
                let sweepPhase = 0; // 0=none, 1=approach, 2=sweep, 3=displacement
                
                // Premium/Discount zones (above/below equilibrium)
                const equilibrium = currentPrice;
                const premiumZone = equilibrium + avgCandleSize * 4;
                const discountZone = equilibrium - avgCandleSize * 4;
                
                // Create IRL zone helper
                const createIRLZone = (price, type, strength = 1) => {
                    irlZones.push({
                        price: price,
                        type: type, // 'equal_high', 'equal_low', 'swing_high', 'swing_low', 'session_high', 'session_low'
                        swept: false,
                        strength: strength, // 1-3, higher = more liquidity
                        createdAt: predictedCandles.length
                    });
                };
                
                // Create FVG helper
                const createFVG = (high, low, type) => {
                    if (high > low) {
                        fvgZones.push({
                            high: high,
                            low: low,
                            type: type, // 'bullish', 'bearish'
                            filled: false,
                            partialFill: 0
                        });
                    }
                };
                
                // Create Order Block helper
                const createOB = (high, low, type, index) => {
                    orderBlocks.push({
                        high: high,
                        low: low,
                        type: type, // 'bullish', 'bearish'
                        index: index,
                        mitigated: false,
                        tested: 0
                    });
                };
                
                // Initialize IRL zones from "historical" structure
                if (isBuy) {
                    // Buy setup: Create sell-side liquidity (lows) to sweep
                    createIRLZone(currentPrice - avgCandleSize * 1.2, 'equal_low', 2);
                    createIRLZone(currentPrice - avgCandleSize * 2.5, 'swing_low', 3);
                    createIRLZone(currentPrice - avgCandleSize * 4, 'session_low', 2);
                    // Create initial bullish OB
                    createOB(currentPrice, currentPrice - avgCandleSize * 0.8, 'bullish', 0);
                } else {
                    // Sell setup: Create buy-side liquidity (highs) to sweep
                    createIRLZone(currentPrice + avgCandleSize * 1.2, 'equal_high', 2);
                    createIRLZone(currentPrice + avgCandleSize * 2.5, 'swing_high', 3);
                    createIRLZone(currentPrice + avgCandleSize * 4, 'session_high', 2);
                    // Create initial bearish OB
                    createOB(currentPrice + avgCandleSize * 0.8, currentPrice, 'bearish', 0);
                }
                
                for (let i = 1; i <= numCandles; i++) {
                    const time = (currentTime + (intervalMs * i)) / 1000;
                    const progress = i / numCandles;
                    
                    // Determine current target
                    let targetPrice = progress < 0.35 ? entry.avgTP1 : (progress < 0.65 ? entry.avgTP2 : entry.avgTP3);
                    
                    // Initialize candle values with defaults
                    let open = prevClose;
                    let close = open + (isBuy ? avgCandleSize * 0.3 : -avgCandleSize * 0.3);
                    let high = Math.max(open, close) + avgCandleSize * 0.1;
                    let low = Math.min(open, close) - avgCandleSize * 0.1;
                    
                    // Debug first few candles
                    if (i <= 3) {
                        console.log(`üîÑ Candle ${i}: phase=${currentPhase}, open=${open.toFixed(2)}`);
                    }
                    
                    // Phase management
                    phaseCandles++;
                    if (phaseCandles >= phaseLength) {
                        phaseCandles = 0;
                        
                        // Transition to next phase
                        if (currentPhase === 'impulse') {
                            currentPhase = 'pullback';
                            phaseLength = 2 + Math.floor(Math.random() * 2);
                            waveCount++;
                        } else if (currentPhase === 'pullback') {
                            const nextPhaseRand = Math.random();
                            if (nextPhaseRand < 0.25) {
                                currentPhase = 'consolidation';
                                phaseLength = 2 + Math.floor(Math.random() * 3);
                                consolidationRange = { high: prevClose + avgCandleSize * 0.5, low: prevClose - avgCandleSize * 0.5 };
                            } else if (nextPhaseRand < 0.35) {
                                // 10% - Retest phase (return to key level)
                                currentPhase = 'retest';
                                phaseLength = 2 + Math.floor(Math.random() * 2);
                            } else if (nextPhaseRand < 0.45) {
                                // 10% - Double bottom/top formation
                                currentPhase = 'double_test';
                                phaseLength = 3 + Math.floor(Math.random() * 2);
                            } else {
                                // 55% - Continue with impulse
                                currentPhase = 'impulse';
                                phaseLength = 3 + Math.floor(Math.random() * 3);
                            }
                        } else if (currentPhase === 'consolidation') {
                            // After consolidation, breakout with impulse
                            currentPhase = 'impulse';
                            phaseLength = 4 + Math.floor(Math.random() * 3);
                        } else if (currentPhase === 'retest') {
                            // After retest, strong impulse continuation
                            currentPhase = 'impulse';
                            phaseLength = 4 + Math.floor(Math.random() * 2);
                        } else if (currentPhase === 'double_test') {
                            // After double test, impulse with conviction
                            currentPhase = 'impulse';
                            phaseLength = 5 + Math.floor(Math.random() * 2);
                        } else if (currentPhase === 'liquidity_sweep') {
                            // After sweep, displacement impulse
                            currentPhase = 'impulse';
                            phaseLength = 4 + Math.floor(Math.random() * 3);
                        }
                    }
                    
                    // ============================================
                    // RETEST PHASE LOGIC
                    // ============================================
                    if (currentPhase === 'retest') {
                        // Return to previous structure level for confirmation
                        const retestTarget = isBuy ? 
                            (swingLows.length > 0 ? swingLows[swingLows.length - 1].price : prevClose - avgCandleSize) :
                            (swingHighs.length > 0 ? swingHighs[swingHighs.length - 1].price : prevClose + avgCandleSize);
                        
                        const distToRetest = Math.abs(prevClose - retestTarget);
                        
                        if (phaseCandles < phaseLength - 1) {
                            // Move towards retest level
                            if (isBuy) {
                                close = prevClose - avgCandleSize * (0.3 + Math.random() * 0.2);
                                low = close - avgCandleSize * 0.15;
                                high = prevClose + avgCandleSize * 0.1;
                            } else {
                                close = prevClose + avgCandleSize * (0.3 + Math.random() * 0.2);
                                high = close + avgCandleSize * 0.15;
                                low = prevClose - avgCandleSize * 0.1;
                            }
                        } else {
                            // Retest confirmation candle - touch level and reverse
                            if (isBuy) {
                                low = retestTarget - avgCandleSize * 0.05;
                                close = retestTarget + avgCandleSize * 0.4;
                                high = close + avgCandleSize * 0.15;
                                open = retestTarget + avgCandleSize * 0.1;
                            } else {
                                high = retestTarget + avgCandleSize * 0.05;
                                close = retestTarget - avgCandleSize * 0.4;
                                low = close - avgCandleSize * 0.15;
                                open = retestTarget - avgCandleSize * 0.1;
                            }
                        }
                    }
                    
                    // ============================================
                    // DOUBLE TEST PHASE LOGIC (Double Bottom/Top)
                    // ============================================
                    if (currentPhase === 'double_test') {
                        const doubleTestTarget = isBuy ?
                            (swingLows.length > 0 ? swingLows[swingLows.length - 1].price : prevClose - avgCandleSize * 2) :
                            (swingHighs.length > 0 ? swingHighs[swingHighs.length - 1].price : prevClose + avgCandleSize * 2);
                        
                        if (phaseCandles === 0) {
                            // First candle - move towards double test level
                            if (isBuy) {
                                close = prevClose - avgCandleSize * 0.5;
                                low = close - avgCandleSize * 0.2;
                                high = prevClose + avgCandleSize * 0.1;
                            } else {
                                close = prevClose + avgCandleSize * 0.5;
                                high = close + avgCandleSize * 0.2;
                                low = prevClose - avgCandleSize * 0.1;
                            }
                        } else if (phaseCandles === 1) {
                            // Second candle - test the level (equal low/high)
                            if (isBuy) {
                                low = doubleTestTarget + avgCandleSize * (Math.random() * 0.1 - 0.05); // Slight variance
                                close = doubleTestTarget + avgCandleSize * 0.2;
                                high = close + avgCandleSize * 0.15;
                                open = doubleTestTarget + avgCandleSize * 0.3;
                                // Create equal low IRL zone
                                createIRLZone(low, 'equal_low', 3);
                            } else {
                                high = doubleTestTarget - avgCandleSize * (Math.random() * 0.1 - 0.05);
                                close = doubleTestTarget - avgCandleSize * 0.2;
                                low = close - avgCandleSize * 0.15;
                                open = doubleTestTarget - avgCandleSize * 0.3;
                                createIRLZone(high, 'equal_high', 3);
                            }
                        } else {
                            // Third candle - reversal confirmation
                            if (isBuy) {
                                close = prevClose + avgCandleSize * 0.6;
                                high = close + avgCandleSize * 0.15;
                                low = prevClose - avgCandleSize * 0.1;
                            } else {
                                close = prevClose - avgCandleSize * 0.6;
                                low = close - avgCandleSize * 0.15;
                                high = prevClose + avgCandleSize * 0.1;
                            }
                        }
                    }
                    
                    // ============================================
                    // ICT LIQUIDITY SWEEP LOGIC - ENHANCED
                    // ============================================
                    
                    // Determine if we should hunt liquidity (AMD - Accumulation, Manipulation, Distribution)
                    const shouldSweep = !liquiditySweepPending && 
                        Math.random() < 0.12 && 
                        i > 3 && 
                        i < numCandles - 8 &&
                        (currentPhase === 'pullback' || currentPhase === 'consolidation');
                    
                    if (shouldSweep) {
                        // Find highest strength unswept IRL zone
                        const unsweptZones = irlZones.filter(z => !z.swept).sort((a, b) => b.strength - a.strength);
                        if (unsweptZones.length > 0) {
                            const targetZone = unsweptZones[0];
                            liquiditySweepPending = true;
                            sweepTarget = targetZone.price;
                            sweepDirection = targetZone.type.includes('low') ? 'down' : 'up';
                            sweepPhase = 1; // Start approach phase
                            currentPhase = 'liquidity_sweep';
                            phaseLength = 3 + Math.floor(Math.random() * 2);
                            phaseCandles = 0;
                            console.log(`üíß Initiating liquidity sweep to ${sweepDirection} @ ${sweepTarget.toFixed(2)}`);
                        }
                    }
                    
                    // Execute liquidity sweep with 3-phase structure
                    if (currentPhase === 'liquidity_sweep' && liquiditySweepPending) {
                        
                        if (sweepDirection === 'down') {
                            // SELL-SIDE LIQUIDITY SWEEP (hunting stop losses below lows)
                            if (sweepPhase === 1) {
                                // Phase 1: Approach - gradual move towards liquidity
                                close = prevClose - avgCandleSize * (0.4 + Math.random() * 0.3);
                                low = close - avgCandleSize * 0.2;
                                high = prevClose + avgCandleSize * 0.15;
                                
                                if (prevClose - avgCandleSize < sweepTarget) {
                                    sweepPhase = 2; // Ready to sweep
                                }
                            } else if (sweepPhase === 2) {
                                // Phase 2: Sweep - aggressive wick through liquidity
                                low = sweepTarget - avgCandleSize * (0.3 + Math.random() * 0.4);
                                high = prevClose + avgCandleSize * 0.1;
                                // Rejection candle - close back above sweep level
                                close = sweepTarget + avgCandleSize * (0.2 + Math.random() * 0.3);
                                
                                // Mark zone as swept
                                const sweptZone = irlZones.find(z => z.price === sweepTarget);
                                if (sweptZone) sweptZone.swept = true;
                                
                                // Create bullish Order Block at sweep location
                                createOB(prevClose, low, 'bullish', i);
                                
                                // Create FVG if displacement is strong enough
                                if (predictedCandles.length >= 2) {
                                    const prevCandle = predictedCandles[predictedCandles.length - 1];
                                    if (close > prevCandle.high) {
                                        createFVG(close, prevCandle.high, 'bullish');
                                    }
                                }
                                
                                sweepPhase = 3;
                            } else {
                                // Phase 3: Displacement - strong move away from sweep
                                const displacementStrength = 0.8 + Math.random() * 0.4;
                                close = prevClose + avgCandleSize * displacementStrength;
                                low = prevClose - avgCandleSize * 0.05;
                                high = close + avgCandleSize * 0.15;
                                
                                liquiditySweepPending = false;
                                sweepPhase = 0;
                                currentPhase = 'impulse';
                                phaseLength = 4 + Math.floor(Math.random() * 3);
                                phaseCandles = 0;
                            }
                        } else {
                            // BUY-SIDE LIQUIDITY SWEEP (hunting stop losses above highs)
                            if (sweepPhase === 1) {
                                close = prevClose + avgCandleSize * (0.4 + Math.random() * 0.3);
                                high = close + avgCandleSize * 0.2;
                                low = prevClose - avgCandleSize * 0.15;
                                
                                if (prevClose + avgCandleSize > sweepTarget) {
                                    sweepPhase = 2;
                                }
                            } else if (sweepPhase === 2) {
                                high = sweepTarget + avgCandleSize * (0.3 + Math.random() * 0.4);
                                low = prevClose - avgCandleSize * 0.1;
                                close = sweepTarget - avgCandleSize * (0.2 + Math.random() * 0.3);
                                
                                const sweptZone = irlZones.find(z => z.price === sweepTarget);
                                if (sweptZone) sweptZone.swept = true;
                                
                                createOB(high, prevClose, 'bearish', i);
                                
                                if (predictedCandles.length >= 2) {
                                    const prevCandle = predictedCandles[predictedCandles.length - 1];
                                    if (close < prevCandle.low) {
                                        createFVG(prevCandle.low, close, 'bearish');
                                    }
                                }
                                
                                sweepPhase = 3;
                            } else {
                                const displacementStrength = 0.8 + Math.random() * 0.4;
                                close = prevClose - avgCandleSize * displacementStrength;
                                high = prevClose + avgCandleSize * 0.05;
                                low = close - avgCandleSize * 0.15;
                                
                                liquiditySweepPending = false;
                                sweepPhase = 0;
                                currentPhase = 'impulse';
                                phaseLength = 4 + Math.floor(Math.random() * 3);
                                phaseCandles = 0;
                            }
                        }
                        
                        high = Math.max(high || open, open, close || open);
                        low = Math.min(low || open, open, close || open);
                        
                        predictedCandles.push({ time, open, high, low, close });
                        prevClose = close;
                        continue;
                    }
                    
                    // ============================================
                    // FVG (Fair Value Gap) CREATION - ENHANCED
                    // ============================================
                    // FVGs form during displacement (strong impulsive moves)
                    if (currentPhase === 'impulse' && predictedCandles.length >= 2 && Math.random() < 0.18) {
                        const candle1 = predictedCandles[predictedCandles.length - 2];
                        const candle2 = predictedCandles[predictedCandles.length - 1];
                        
                        if (isBuy) {
                            // Bullish FVG - gap between candle1 high and current candle low
                            const gapSize = avgCandleSize * (0.25 + Math.random() * 0.35);
                            const fvgLow = candle1.high;
                            const fvgHigh = candle2.close + gapSize;
                            
                            if (fvgHigh > fvgLow) {
                                createFVG(fvgHigh, fvgLow, 'bullish');
                                // Price gaps up
                                open = candle2.close + gapSize * 0.3;
                            }
                        } else {
                            // Bearish FVG
                            const gapSize = avgCandleSize * (0.25 + Math.random() * 0.35);
                            const fvgHigh = candle1.low;
                            const fvgLow = candle2.close - gapSize;
                            
                            if (fvgHigh > fvgLow) {
                                createFVG(fvgHigh, fvgLow, 'bearish');
                                open = candle2.close - gapSize * 0.3;
                            }
                        }
                    }
                    
                    // ============================================
                    // FVG FILL / MITIGATION LOGIC
                    // ============================================
                    // Price tends to return to fill FVGs (rebalancing)
                    const unfilledFVG = fvgZones.find(f => !f.filled && f.partialFill < 1);
                    
                    if (unfilledFVG && currentPhase === 'pullback') {
                        const fillChance = 0.5 + (unfilledFVG.partialFill * 0.2); // Higher chance if partially filled
                        
                        if (Math.random() < fillChance) {
                            const fvgMid = (unfilledFVG.high + unfilledFVG.low) / 2;
                            const fvgRange = unfilledFVG.high - unfilledFVG.low;
                            
                            if (unfilledFVG.type === 'bullish' && isBuy) {
                                // Pullback into bullish FVG - look for reaction
                                const fillDepth = 0.5 + Math.random() * 0.4; // 50-90% fill
                                low = unfilledFVG.high - (fvgRange * fillDepth);
                                
                                // Reaction from FVG (bullish candle)
                                close = low + avgCandleSize * (0.3 + Math.random() * 0.3);
                                high = Math.max(open, close) + avgCandleSize * 0.1;
                                
                                unfilledFVG.partialFill = fillDepth;
                                if (fillDepth > 0.8) unfilledFVG.filled = true;
                                
                                // Transition to impulse after FVG reaction
                                currentPhase = 'impulse';
                                phaseLength = 3 + Math.floor(Math.random() * 2);
                                phaseCandles = 0;
                            } else if (unfilledFVG.type === 'bearish' && !isBuy) {
                                const fillDepth = 0.5 + Math.random() * 0.4;
                                high = unfilledFVG.low + (fvgRange * fillDepth);
                                
                                close = high - avgCandleSize * (0.3 + Math.random() * 0.3);
                                low = Math.min(open, close) - avgCandleSize * 0.1;
                                
                                unfilledFVG.partialFill = fillDepth;
                                if (fillDepth > 0.8) unfilledFVG.filled = true;
                                
                                currentPhase = 'impulse';
                                phaseLength = 3 + Math.floor(Math.random() * 2);
                                phaseCandles = 0;
                            }
                        }
                    }
                    
                    // ============================================
                    // ORDER BLOCK REACTION - ENHANCED
                    // ============================================
                    // OBs are high-probability reversal zones
                    const activeOBs = orderBlocks.filter(ob => !ob.mitigated && ob.tested < 2);
                    
                    for (const ob of activeOBs) {
                        const obMid = (ob.high + ob.low) / 2;
                        const distToOB = isBuy ? 
                            (prevClose - ob.high) : 
                            (ob.low - prevClose);
                        
                        // Check if price is approaching OB
                        if (distToOB > 0 && distToOB < avgCandleSize * 1.5 && currentPhase === 'pullback') {
                            
                            if (ob.type === 'bullish' && isBuy && Math.random() < 0.6) {
                                // Bullish OB reaction - price wicks into OB and reverses
                                low = ob.high - (ob.high - ob.low) * (0.3 + Math.random() * 0.4);
                                close = ob.high + avgCandleSize * (0.3 + Math.random() * 0.3);
                                high = close + avgCandleSize * 0.15;
                                
                                ob.tested++;
                                if (ob.tested >= 2) ob.mitigated = true;
                                
                                // Strong reaction = impulse
                                currentPhase = 'impulse';
                                phaseLength = 4 + Math.floor(Math.random() * 2);
                                phaseCandles = 0;
                                break;
                                
                            } else if (ob.type === 'bearish' && !isBuy && Math.random() < 0.6) {
                                high = ob.low + (ob.high - ob.low) * (0.3 + Math.random() * 0.4);
                                close = ob.low - avgCandleSize * (0.3 + Math.random() * 0.3);
                                low = close - avgCandleSize * 0.15;
                                
                                ob.tested++;
                                if (ob.tested >= 2) ob.mitigated = true;
                                
                                currentPhase = 'impulse';
                                phaseLength = 4 + Math.floor(Math.random() * 2);
                                phaseCandles = 0;
                                break;
                            }
                        }
                    }
                    
                    // ============================================
                    // MAIN PHASE CANDLE GENERATION
                    // ============================================
                    
                    if (currentPhase === 'impulse') {
                        // Strong directional move
                        const impulseStrength = 0.6 + Math.random() * 0.4; // 60-100% of avg candle
                        const bodySize = avgCandleSize * impulseStrength;
                        
                        if (isBuy) {
                            close = open + bodySize;
                            // Small lower wick, small upper wick for strong bullish
                            low = open - avgCandleSize * (0.05 + Math.random() * 0.1);
                            high = close + avgCandleSize * (0.05 + Math.random() * 0.15);
                        } else {
                            close = open - bodySize;
                            // Small upper wick, small lower wick for strong bearish
                            high = open + avgCandleSize * (0.05 + Math.random() * 0.1);
                            low = close - avgCandleSize * (0.05 + Math.random() * 0.15);
                        }
                        
                        // ============================================
                        // SWING POINT & IRL ZONE TRACKING
                        // ============================================
                        if (isBuy && high > lastSwingHigh) {
                            lastSwingHigh = high;
                            swingHighs.push({ price: high, index: i });
                            
                            // Check for equal highs (strong IRL - buy-side liquidity)
                            if (swingHighs.length > 1) {
                                const prevSwing = swingHighs[swingHighs.length - 2];
                                const tolerance = avgCandleSize * 0.4;
                                if (Math.abs(high - prevSwing.price) < tolerance) {
                                    // Equal highs detected - strong liquidity pool
                                    createIRLZone(Math.max(high, prevSwing.price), 'equal_high', 3);
                                }
                            }
                            
                            // Create swing high IRL zone
                            if (i > 5 && Math.random() < 0.3) {
                                createIRLZone(high, 'swing_high', 2);
                            }
                        }
                        
                        if (!isBuy && low < lastSwingLow) {
                            lastSwingLow = low;
                            swingLows.push({ price: low, index: i });
                            
                            // Check for equal lows (strong IRL - sell-side liquidity)
                            if (swingLows.length > 1) {
                                const prevSwing = swingLows[swingLows.length - 2];
                                const tolerance = avgCandleSize * 0.4;
                                if (Math.abs(low - prevSwing.price) < tolerance) {
                                    createIRLZone(Math.min(low, prevSwing.price), 'equal_low', 3);
                                }
                            }
                            
                            if (i > 5 && Math.random() < 0.3) {
                                createIRLZone(low, 'swing_low', 2);
                            }
                        }
                        
                        // ============================================
                        // ERL (External Range Liquidity) TARGETING
                        // ============================================
                        // Price accelerates towards external liquidity targets
                        const distToERL = isBuy ? (erlHigh - close) : (close - erlLow);
                        
                        if (distToERL < avgCandleSize * 4 && distToERL > 0) {
                            // Approaching ERL - increase momentum (liquidity draw)
                            const erlProximity = 1 - (distToERL / (avgCandleSize * 4));
                            const erlBoost = avgCandleSize * 0.25 * erlProximity;
                            
                            if (isBuy) {
                                close += erlBoost;
                                high = Math.max(high, close + avgCandleSize * 0.1);
                                
                                // Check if we've reached ERL
                                if (close >= erlHigh) {
                                    console.log(`üéØ ERL High reached @ ${erlHigh.toFixed(2)}`);
                                }
                            } else {
                                close -= erlBoost;
                                low = Math.min(low, close - avgCandleSize * 0.1);
                                
                                if (close <= erlLow) {
                                    console.log(`üéØ ERL Low reached @ ${erlLow.toFixed(2)}`);
                                }
                            }
                        }
                        
                        // ============================================
                        // CREATE ORDER BLOCKS DURING IMPULSE
                        // ============================================
                        // OBs form at the origin of strong moves
                        if (phaseCandles === 1 && Math.random() < 0.25) {
                            // First candle of impulse can be an OB
                            if (isBuy) {
                                createOB(open + avgCandleSize * 0.1, open - avgCandleSize * 0.3, 'bullish', i);
                            } else {
                                createOB(open + avgCandleSize * 0.3, open - avgCandleSize * 0.1, 'bearish', i);
                            }
                        }
                        
                    } else if (currentPhase === 'pullback') {
                        // Counter-trend move (retracement)
                        const pullbackStrength = 0.3 + Math.random() * 0.4; // 30-70% of avg candle
                        const bodySize = avgCandleSize * pullbackStrength;
                        
                        if (isBuy) {
                            // Bearish candle in uptrend (pullback)
                            close = open - bodySize;
                            high = open + avgCandleSize * (0.1 + Math.random() * 0.2);
                            low = close - avgCandleSize * (0.1 + Math.random() * 0.15);
                            
                            // Create higher low (key for market structure)
                            if (low < lastSwingLow) {
                                low = lastSwingLow + avgCandleSize * 0.1; // Keep above last swing low
                            }
                            lastSwingLow = Math.max(lastSwingLow, low);
                            swingLows.push({ price: low, index: i });
                        } else {
                            // Bullish candle in downtrend (pullback)
                            close = open + bodySize;
                            low = open - avgCandleSize * (0.1 + Math.random() * 0.2);
                            high = close + avgCandleSize * (0.1 + Math.random() * 0.15);
                            
                            // Create lower high (key for market structure)
                            if (high > lastSwingHigh) {
                                high = lastSwingHigh - avgCandleSize * 0.1; // Keep below last swing high
                            }
                            lastSwingHigh = Math.min(lastSwingHigh, high);
                            swingHighs.push({ price: high, index: i });
                        }
                        
                    } else if (currentPhase === 'consolidation') {
                        // Sideways movement within range - INSTITUTIONAL ACCUMULATION/DISTRIBUTION
                        const bodySize = avgCandleSize * (0.15 + Math.random() * 0.25);
                        
                        // Alternate direction to create range-bound structure
                        const prevCandle = predictedCandles.length > 0 ? predictedCandles[predictedCandles.length - 1] : null;
                        let direction;
                        if (prevCandle) {
                            // Tend to reverse direction in consolidation
                            direction = prevCandle.close > prevCandle.open ? -1 : 1;
                            if (Math.random() < 0.3) direction *= -1; // 30% chance to continue
                        } else {
                            direction = Math.random() > 0.5 ? 1 : -1;
                        }
                        
                        close = open + (bodySize * direction);
                        
                        // Keep within consolidation range
                        if (consolidationRange) {
                            // Test range boundaries occasionally
                            if (Math.random() < 0.2) {
                                // Test upper boundary
                                high = consolidationRange.high + avgCandleSize * 0.1;
                                close = consolidationRange.high - avgCandleSize * 0.15;
                            } else if (Math.random() < 0.2) {
                                // Test lower boundary
                                low = consolidationRange.low - avgCandleSize * 0.1;
                                close = consolidationRange.low + avgCandleSize * 0.15;
                            } else {
                                if (close > consolidationRange.high) close = consolidationRange.high - avgCandleSize * 0.1;
                                if (close < consolidationRange.low) close = consolidationRange.low + avgCandleSize * 0.1;
                            }
                        }
                        
                        // Longer wicks in consolidation (indecision/stop hunting)
                        const upperWick = avgCandleSize * (0.25 + Math.random() * 0.35);
                        const lowerWick = avgCandleSize * (0.25 + Math.random() * 0.35);
                        high = Math.max(open, close) + upperWick;
                        low = Math.min(open, close) - lowerWick;
                        
                        // Create internal liquidity during consolidation
                        if (Math.random() < 0.15 && consolidationRange) {
                            if (high >= consolidationRange.high - avgCandleSize * 0.1) {
                                createIRLZone(high, 'equal_high', 2);
                            }
                            if (low <= consolidationRange.low + avgCandleSize * 0.1) {
                                createIRLZone(low, 'equal_low', 2);
                            }
                        }
                    }
                    
                    // ============================================
                    // FALLBACK: Ensure candle has valid values
                    // ============================================
                    if (close === open || close === undefined) {
                        // Default to impulse-like candle if no phase set values
                        const defaultBody = avgCandleSize * (0.4 + Math.random() * 0.3);
                        if (isBuy) {
                            close = open + defaultBody;
                            high = close + avgCandleSize * 0.1;
                            low = open - avgCandleSize * 0.1;
                        } else {
                            close = open - defaultBody;
                            low = close - avgCandleSize * 0.1;
                            high = open + avgCandleSize * 0.1;
                        }
                    }
                    
                    // Ensure proper OHLC
                    high = Math.max(high, open, close);
                    low = Math.min(low, open, close);
                    
                    // Ensure minimum range
                    if (high - low < avgCandleSize * 0.05) {
                        high = Math.max(open, close) + avgCandleSize * 0.03;
                        low = Math.min(open, close) - avgCandleSize * 0.03;
                    }
                    
                    // ============================================
                    // ADVANCED CANDLE PATTERNS FOR REALISM
                    // ============================================
                    const patternRand = Math.random();
                    const candleIndex = predictedCandles.length;
                    
                    // 1. DOJI (5% chance) - Indecision
                    if (patternRand < 0.05) {
                        const mid = (open + close) / 2;
                        close = mid + (Math.random() - 0.5) * avgCandleSize * 0.05;
                        high = Math.max(open, close) + avgCandleSize * (0.35 + Math.random() * 0.25);
                        low = Math.min(open, close) - avgCandleSize * (0.35 + Math.random() * 0.25);
                    }
                    
                    // 2. HAMMER / INVERTED HAMMER (6% chance during pullback)
                    else if (patternRand < 0.11 && currentPhase === 'pullback') {
                        if (isBuy) {
                            // Bullish Hammer - long lower wick, small body at top
                            const bodySize = avgCandleSize * 0.15;
                            close = open + bodySize;
                            low = open - avgCandleSize * (0.7 + Math.random() * 0.4);
                            high = close + avgCandleSize * 0.08;
                        } else {
                            // Bearish Inverted Hammer
                            const bodySize = avgCandleSize * 0.15;
                            close = open - bodySize;
                            high = open + avgCandleSize * (0.7 + Math.random() * 0.4);
                            low = close - avgCandleSize * 0.08;
                        }
                    }
                    
                    // 3. ENGULFING (5% chance at wave transitions)
                    else if (patternRand < 0.16 && candleIndex > 0 && currentPhase === 'impulse') {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        const prevBody = Math.abs(prevCandle.close - prevCandle.open);
                        
                        if (isBuy) {
                            // Bullish Engulfing
                            open = prevCandle.close - avgCandleSize * 0.05;
                            close = prevCandle.open + avgCandleSize * 0.3;
                            low = Math.min(open, prevCandle.low) - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            // Bearish Engulfing
                            open = prevCandle.close + avgCandleSize * 0.05;
                            close = prevCandle.open - avgCandleSize * 0.3;
                            high = Math.max(open, prevCandle.high) + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 4. MORNING STAR / EVENING STAR (3% chance)
                    else if (patternRand < 0.19 && candleIndex >= 2) {
                        // Create small body (star)
                        const bodySize = avgCandleSize * 0.1;
                        close = open + (isBuy ? bodySize : -bodySize);
                        high = Math.max(open, close) + avgCandleSize * 0.2;
                        low = Math.min(open, close) - avgCandleSize * 0.2;
                    }
                    
                    // 5. MARUBOZU (4% chance during strong impulse)
                    else if (patternRand < 0.23 && currentPhase === 'impulse') {
                        // Strong candle with almost no wicks
                        const bodySize = avgCandleSize * (0.8 + Math.random() * 0.3);
                        if (isBuy) {
                            close = open + bodySize;
                            high = close + avgCandleSize * 0.02;
                            low = open - avgCandleSize * 0.02;
                        } else {
                            close = open - bodySize;
                            low = close - avgCandleSize * 0.02;
                            high = open + avgCandleSize * 0.02;
                        }
                    }
                    
                    // 6. SPINNING TOP (5% chance during consolidation)
                    else if (patternRand < 0.28 && currentPhase === 'consolidation') {
                        const bodySize = avgCandleSize * 0.15;
                        const direction = Math.random() > 0.5 ? 1 : -1;
                        close = open + bodySize * direction;
                        high = Math.max(open, close) + avgCandleSize * (0.3 + Math.random() * 0.2);
                        low = Math.min(open, close) - avgCandleSize * (0.3 + Math.random() * 0.2);
                    }
                    
                    // 7. DRAGONFLY DOJI (2% chance at support)
                    else if (patternRand < 0.30 && currentPhase === 'pullback' && isBuy) {
                        close = open + avgCandleSize * 0.02;
                        high = Math.max(open, close) + avgCandleSize * 0.05;
                        low = open - avgCandleSize * (0.6 + Math.random() * 0.3);
                    }
                    
                    // 8. GRAVESTONE DOJI (2% chance at resistance)
                    else if (patternRand < 0.32 && currentPhase === 'pullback' && !isBuy) {
                        close = open - avgCandleSize * 0.02;
                        low = Math.min(open, close) - avgCandleSize * 0.05;
                        high = open + avgCandleSize * (0.6 + Math.random() * 0.3);
                    }
                    
                    // 9. THREE WHITE SOLDIERS / THREE BLACK CROWS (check previous 2 candles)
                    else if (patternRand < 0.35 && candleIndex >= 2 && currentPhase === 'impulse') {
                        const prev1 = predictedCandles[candleIndex - 1];
                        const prev2 = predictedCandles[candleIndex - 2];
                        
                        // Continue the pattern
                        const bodySize = avgCandleSize * (0.5 + Math.random() * 0.3);
                        if (isBuy) {
                            close = open + bodySize;
                            high = close + avgCandleSize * 0.1;
                            low = open - avgCandleSize * 0.05;
                        } else {
                            close = open - bodySize;
                            low = close - avgCandleSize * 0.1;
                            high = open + avgCandleSize * 0.05;
                        }
                    }
                    
                    // 10. TWEEZER TOP/BOTTOM (3% chance)
                    else if (patternRand < 0.38 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        if (isBuy) {
                            // Tweezer Bottom - same low as previous
                            low = prevCandle.low;
                            close = open + avgCandleSize * 0.3;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            // Tweezer Top - same high as previous
                            high = prevCandle.high;
                            close = open - avgCandleSize * 0.3;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 11. INSIDE BAR (4% chance during consolidation)
                    else if (patternRand < 0.42 && candleIndex > 0 && currentPhase === 'consolidation') {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        const prevRange = prevCandle.high - prevCandle.low;
                        
                        // Candle completely inside previous candle
                        const insideRange = prevRange * (0.4 + Math.random() * 0.3);
                        const midPoint = (prevCandle.high + prevCandle.low) / 2;
                        
                        high = midPoint + insideRange / 2;
                        low = midPoint - insideRange / 2;
                        const bodySize = insideRange * 0.4;
                        close = open + (Math.random() > 0.5 ? bodySize : -bodySize);
                        
                        // Ensure inside
                        high = Math.min(high, prevCandle.high - avgCandleSize * 0.02);
                        low = Math.max(low, prevCandle.low + avgCandleSize * 0.02);
                    }
                    
                    // 12. HARAMI (3% chance)
                    else if (patternRand < 0.45 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        const prevBody = Math.abs(prevCandle.close - prevCandle.open);
                        
                        // Small body inside previous body
                        const bodySize = prevBody * 0.3;
                        const midPrev = (prevCandle.open + prevCandle.close) / 2;
                        
                        open = midPrev - bodySize / 2;
                        close = midPrev + bodySize / 2;
                        high = Math.max(open, close) + avgCandleSize * 0.1;
                        low = Math.min(open, close) - avgCandleSize * 0.1;
                    }
                    
                    // 13. PIERCING LINE / DARK CLOUD COVER (3% chance)
                    else if (patternRand < 0.48 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        const prevMid = (prevCandle.open + prevCandle.close) / 2;
                        
                        if (isBuy) {
                            // Piercing Line - opens below prev low, closes above prev midpoint
                            open = prevCandle.low - avgCandleSize * 0.1;
                            close = prevMid + avgCandleSize * 0.2;
                            low = open - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            // Dark Cloud Cover - opens above prev high, closes below prev midpoint
                            open = prevCandle.high + avgCandleSize * 0.1;
                            close = prevMid - avgCandleSize * 0.2;
                            high = open + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 14. KICKER PATTERN (2% chance - very strong reversal)
                    else if (patternRand < 0.50 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        
                        if (isBuy) {
                            // Bullish Kicker - gap up and strong bullish
                            open = prevCandle.high + avgCandleSize * 0.2;
                            close = open + avgCandleSize * 0.8;
                            low = open - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            // Bearish Kicker - gap down and strong bearish
                            open = prevCandle.low - avgCandleSize * 0.2;
                            close = open - avgCandleSize * 0.8;
                            high = open + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 15. BELT HOLD (2% chance)
                    else if (patternRand < 0.52) {
                        if (isBuy) {
                            // Bullish Belt Hold - opens at low, closes near high
                            low = open - avgCandleSize * 0.02;
                            close = open + avgCandleSize * 0.7;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            // Bearish Belt Hold - opens at high, closes near low
                            high = open + avgCandleSize * 0.02;
                            close = open - avgCandleSize * 0.7;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 16. ABANDONED BABY (1% chance - rare but powerful)
                    else if (patternRand < 0.53 && candleIndex >= 2) {
                        const prev1 = predictedCandles[candleIndex - 1];
                        const prev2 = predictedCandles[candleIndex - 2];
                        
                        // Create gap and strong reversal candle
                        if (isBuy) {
                            open = prev1.high + avgCandleSize * 0.3;
                            close = open + avgCandleSize * 0.6;
                            low = open - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            open = prev1.low - avgCandleSize * 0.3;
                            close = open - avgCandleSize * 0.6;
                            high = open + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 17. RISING THREE / FALLING THREE (2% chance)
                    else if (patternRand < 0.55 && candleIndex >= 3 && currentPhase === 'impulse') {
                        // Small counter-trend candle in a trend
                        const bodySize = avgCandleSize * 0.2;
                        if (isBuy) {
                            // Small bearish candle in uptrend
                            close = open - bodySize;
                        } else {
                            // Small bullish candle in downtrend
                            close = open + bodySize;
                        }
                        high = Math.max(open, close) + avgCandleSize * 0.15;
                        low = Math.min(open, close) - avgCandleSize * 0.15;
                    }
                    
                    // 18. MEETING LINES (2% chance)
                    else if (patternRand < 0.57 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        
                        // Close at same level as previous close
                        if (isBuy) {
                            open = prevCandle.close - avgCandleSize * 0.5;
                            close = prevCandle.close;
                            low = open - avgCandleSize * 0.1;
                            high = close + avgCandleSize * 0.15;
                        } else {
                            open = prevCandle.close + avgCandleSize * 0.5;
                            close = prevCandle.close;
                            high = open + avgCandleSize * 0.1;
                            low = close - avgCandleSize * 0.15;
                        }
                    }
                    
                    // 19. SEPARATING LINES (2% chance)
                    else if (patternRand < 0.59 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        
                        // Open at same level as previous open, continue trend
                        open = prevCandle.open;
                        if (isBuy) {
                            close = open + avgCandleSize * 0.6;
                            low = open - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            close = open - avgCandleSize * 0.6;
                            high = open + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 20. THRUSTING LINE (2% chance)
                    else if (patternRand < 0.61 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        const prevMid = (prevCandle.open + prevCandle.close) / 2;
                        
                        if (isBuy) {
                            // Opens below prev low, closes into prev body but below midpoint
                            open = prevCandle.low - avgCandleSize * 0.1;
                            close = prevMid - avgCandleSize * 0.1;
                            low = open - avgCandleSize * 0.05;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            open = prevCandle.high + avgCandleSize * 0.1;
                            close = prevMid + avgCandleSize * 0.1;
                            high = open + avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 21. LONG-LEGGED DOJI (2% chance)
                    else if (patternRand < 0.63) {
                        // Very long wicks, tiny body
                        const mid = open;
                        close = mid + (Math.random() - 0.5) * avgCandleSize * 0.03;
                        high = Math.max(open, close) + avgCandleSize * (0.5 + Math.random() * 0.3);
                        low = Math.min(open, close) - avgCandleSize * (0.5 + Math.random() * 0.3);
                    }
                    
                    // 22. RICKSHAW MAN (1% chance)
                    else if (patternRand < 0.64) {
                        // Doji with equal long wicks
                        close = open;
                        const wickSize = avgCandleSize * (0.4 + Math.random() * 0.2);
                        high = open + wickSize;
                        low = open - wickSize;
                    }
                    
                    // 23. HIGH WAVE CANDLE (2% chance)
                    else if (patternRand < 0.66) {
                        // Small body, very long wicks
                        const bodySize = avgCandleSize * 0.1;
                        close = open + (Math.random() > 0.5 ? bodySize : -bodySize);
                        high = Math.max(open, close) + avgCandleSize * (0.6 + Math.random() * 0.3);
                        low = Math.min(open, close) - avgCandleSize * (0.6 + Math.random() * 0.3);
                    }
                    
                    // 24. MATCHING LOW / MATCHING HIGH (2% chance)
                    else if (patternRand < 0.68 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        
                        if (isBuy) {
                            // Matching Low - same low as previous
                            low = prevCandle.low;
                            close = open + avgCandleSize * 0.4;
                            high = close + avgCandleSize * 0.15;
                        } else {
                            // Matching High - same high as previous
                            high = prevCandle.high;
                            close = open - avgCandleSize * 0.4;
                            low = close - avgCandleSize * 0.15;
                        }
                    }
                    
                    // 25. STICK SANDWICH (1% chance)
                    else if (patternRand < 0.69 && candleIndex >= 2) {
                        const prev2 = predictedCandles[candleIndex - 2];
                        
                        // Close at same level as 2 candles ago
                        close = prev2.close;
                        if (isBuy) {
                            open = close - avgCandleSize * 0.4;
                            low = open - avgCandleSize * 0.1;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            open = close + avgCandleSize * 0.4;
                            high = open + avgCandleSize * 0.1;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // ============================================
                    // ICT INSTITUTIONAL PATTERNS (26-40)
                    // ============================================
                    
                    // 26. DISPLACEMENT CANDLE (3% chance) - Strong institutional move
                    else if (patternRand < 0.72 && currentPhase === 'impulse') {
                        // Large body, minimal wicks - shows institutional commitment
                        const displacementSize = avgCandleSize * (1.2 + Math.random() * 0.6);
                        if (isBuy) {
                            close = open + displacementSize;
                            low = open - avgCandleSize * 0.03; // Almost no lower wick
                            high = close + avgCandleSize * 0.05; // Tiny upper wick
                        } else {
                            close = open - displacementSize;
                            high = open + avgCandleSize * 0.03;
                            low = close - avgCandleSize * 0.05;
                        }
                        // Create FVG after displacement
                        if (candleIndex > 0) {
                            const prevCandle = predictedCandles[candleIndex - 1];
                            if (isBuy && close > prevCandle.high + avgCandleSize * 0.2) {
                                createFVG(open, prevCandle.high, 'bullish');
                            } else if (!isBuy && close < prevCandle.low - avgCandleSize * 0.2) {
                                createFVG(prevCandle.low, open, 'bearish');
                            }
                        }
                    }
                    
                    // 27. REJECTION BLOCK (3% chance) - Failed breakout with reversal
                    else if (patternRand < 0.75 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        if (isBuy) {
                            // Wick below previous low, close back inside range
                            low = prevCandle.low - avgCandleSize * (0.3 + Math.random() * 0.3);
                            close = prevCandle.low + avgCandleSize * 0.4;
                            high = close + avgCandleSize * 0.15;
                            open = prevCandle.low - avgCandleSize * 0.1;
                            // This creates a bullish rejection block
                            createOB(prevCandle.low, low, 'bullish', i);
                        } else {
                            high = prevCandle.high + avgCandleSize * (0.3 + Math.random() * 0.3);
                            close = prevCandle.high - avgCandleSize * 0.4;
                            low = close - avgCandleSize * 0.15;
                            open = prevCandle.high + avgCandleSize * 0.1;
                            createOB(high, prevCandle.high, 'bearish', i);
                        }
                    }
                    
                    // 28. LIQUIDITY GRAB CANDLE (2% chance) - Stop hunt pattern
                    else if (patternRand < 0.77 && candleIndex >= 3) {
                        // Find recent swing to sweep
                        const recentCandles = predictedCandles.slice(-5);
                        if (isBuy) {
                            const recentLow = Math.min(...recentCandles.map(c => c.low));
                            low = recentLow - avgCandleSize * (0.2 + Math.random() * 0.3);
                            close = recentLow + avgCandleSize * 0.5; // Strong reversal
                            high = close + avgCandleSize * 0.2;
                            open = recentLow;
                        } else {
                            const recentHigh = Math.max(...recentCandles.map(c => c.high));
                            high = recentHigh + avgCandleSize * (0.2 + Math.random() * 0.3);
                            close = recentHigh - avgCandleSize * 0.5;
                            low = close - avgCandleSize * 0.2;
                            open = recentHigh;
                        }
                    }
                    
                    // 29. MITIGATION CANDLE (2% chance) - Retest of broken structure
                    else if (patternRand < 0.79 && candleIndex > 5) {
                        // Return to previous structure level
                        const targetCandle = predictedCandles[candleIndex - 4];
                        if (isBuy) {
                            // Retest previous resistance now support
                            low = targetCandle.high - avgCandleSize * 0.1;
                            close = targetCandle.high + avgCandleSize * 0.35;
                            high = close + avgCandleSize * 0.1;
                            open = targetCandle.high + avgCandleSize * 0.05;
                        } else {
                            high = targetCandle.low + avgCandleSize * 0.1;
                            close = targetCandle.low - avgCandleSize * 0.35;
                            low = close - avgCandleSize * 0.1;
                            open = targetCandle.low - avgCandleSize * 0.05;
                        }
                    }
                    
                    // 30. BREAKER RETEST (2% chance) - Failed OB becomes opposite
                    else if (patternRand < 0.81 && breakerBlocks.length > 0) {
                        const breaker = breakerBlocks[breakerBlocks.length - 1];
                        const breakerMid = (breaker.high + breaker.low) / 2;
                        if (isBuy && breaker.type === 'bullish') {
                            low = breaker.low - avgCandleSize * 0.05;
                            close = breakerMid + avgCandleSize * 0.3;
                            high = close + avgCandleSize * 0.1;
                        } else if (!isBuy && breaker.type === 'bearish') {
                            high = breaker.high + avgCandleSize * 0.05;
                            close = breakerMid - avgCandleSize * 0.3;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 31. OPTIMAL TRADE ENTRY (OTE) CANDLE (3% chance) - 62-79% retracement
                    else if (patternRand < 0.84 && currentPhase === 'pullback' && swingHighs.length > 0 && swingLows.length > 0) {
                        const lastHigh = swingHighs[swingHighs.length - 1]?.price || prevClose + avgCandleSize;
                        const lastLow = swingLows[swingLows.length - 1]?.price || prevClose - avgCandleSize;
                        const range = lastHigh - lastLow;
                        
                        if (isBuy) {
                            // OTE zone is 62-79% retracement from high
                            const oteLevel = lastHigh - range * (0.62 + Math.random() * 0.17);
                            low = oteLevel - avgCandleSize * 0.1;
                            close = oteLevel + avgCandleSize * 0.4;
                            high = close + avgCandleSize * 0.15;
                            open = oteLevel + avgCandleSize * 0.1;
                        } else {
                            const oteLevel = lastLow + range * (0.62 + Math.random() * 0.17);
                            high = oteLevel + avgCandleSize * 0.1;
                            close = oteLevel - avgCandleSize * 0.4;
                            low = close - avgCandleSize * 0.15;
                            open = oteLevel - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 32. CHANGE OF CHARACTER (CHoCH) CANDLE (2% chance)
                    else if (patternRand < 0.86 && candleIndex >= 5) {
                        // Break of recent structure indicating trend change
                        const recentCandles = predictedCandles.slice(-5);
                        if (isBuy) {
                            const structureHigh = Math.max(...recentCandles.map(c => c.high));
                            close = structureHigh + avgCandleSize * 0.4;
                            high = close + avgCandleSize * 0.15;
                            low = structureHigh - avgCandleSize * 0.1;
                            open = structureHigh;
                        } else {
                            const structureLow = Math.min(...recentCandles.map(c => c.low));
                            close = structureLow - avgCandleSize * 0.4;
                            low = close - avgCandleSize * 0.15;
                            high = structureLow + avgCandleSize * 0.1;
                            open = structureLow;
                        }
                    }
                    
                    // 33. BREAK OF STRUCTURE (BOS) CANDLE (2% chance)
                    else if (patternRand < 0.88 && candleIndex >= 3) {
                        // Continuation break of structure
                        if (isBuy) {
                            const bodySize = avgCandleSize * (0.7 + Math.random() * 0.4);
                            close = open + bodySize;
                            high = close + avgCandleSize * 0.1;
                            low = open - avgCandleSize * 0.08;
                        } else {
                            const bodySize = avgCandleSize * (0.7 + Math.random() * 0.4);
                            close = open - bodySize;
                            low = close - avgCandleSize * 0.1;
                            high = open + avgCandleSize * 0.08;
                        }
                    }
                    
                    // 34. INDUCEMENT CANDLE (2% chance) - Fake breakout to trap traders
                    else if (patternRand < 0.90 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        if (isBuy) {
                            // Fake breakdown then reversal
                            low = prevCandle.low - avgCandleSize * 0.25;
                            high = prevCandle.high + avgCandleSize * 0.1;
                            close = (open + high) / 2; // Close in upper half
                            // Long lower wick shows rejection
                        } else {
                            high = prevCandle.high + avgCandleSize * 0.25;
                            low = prevCandle.low - avgCandleSize * 0.1;
                            close = (open + low) / 2;
                        }
                    }
                    
                    // 35. POWER OF 3 CANDLE (2% chance) - AMD structure in single candle
                    else if (patternRand < 0.92) {
                        // Accumulation (open), Manipulation (wick), Distribution (close)
                        if (isBuy) {
                            low = open - avgCandleSize * (0.5 + Math.random() * 0.3); // Manipulation down
                            close = open + avgCandleSize * (0.4 + Math.random() * 0.3); // Distribution up
                            high = close + avgCandleSize * 0.1;
                        } else {
                            high = open + avgCandleSize * (0.5 + Math.random() * 0.3);
                            close = open - avgCandleSize * (0.4 + Math.random() * 0.3);
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 36. INSTITUTIONAL CANDLE (2% chance) - Large body, positioned wicks
                    else if (patternRand < 0.94) {
                        const bodySize = avgCandleSize * (0.65 + Math.random() * 0.25);
                        if (isBuy) {
                            close = open + bodySize;
                            // Lower wick 20-30% of body, upper wick 5-10%
                            low = open - bodySize * (0.2 + Math.random() * 0.1);
                            high = close + bodySize * (0.05 + Math.random() * 0.05);
                        } else {
                            close = open - bodySize;
                            high = open + bodySize * (0.2 + Math.random() * 0.1);
                            low = close - bodySize * (0.05 + Math.random() * 0.05);
                        }
                    }
                    
                    // 37. RETEST CONFIRMATION (2% chance) - Clean retest of level
                    else if (patternRand < 0.96 && candleIndex >= 4) {
                        const targetLevel = predictedCandles[candleIndex - 3].close;
                        if (isBuy) {
                            low = targetLevel - avgCandleSize * 0.05;
                            open = targetLevel + avgCandleSize * 0.02;
                            close = targetLevel + avgCandleSize * 0.35;
                            high = close + avgCandleSize * 0.1;
                        } else {
                            high = targetLevel + avgCandleSize * 0.05;
                            open = targetLevel - avgCandleSize * 0.02;
                            close = targetLevel - avgCandleSize * 0.35;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 38. VOLUME IMBALANCE CANDLE (2% chance) - Gap with partial fill
                    else if (patternRand < 0.98 && candleIndex > 0) {
                        const prevCandle = predictedCandles[candleIndex - 1];
                        if (isBuy) {
                            open = prevCandle.close + avgCandleSize * 0.15; // Small gap up
                            close = open + avgCandleSize * 0.4;
                            low = prevCandle.close + avgCandleSize * 0.05; // Partial fill
                            high = close + avgCandleSize * 0.1;
                        } else {
                            open = prevCandle.close - avgCandleSize * 0.15;
                            close = open - avgCandleSize * 0.4;
                            high = prevCandle.close - avgCandleSize * 0.05;
                            low = close - avgCandleSize * 0.1;
                        }
                    }
                    
                    // 39-40. REALISTIC BODY/WICK RATIOS based on phase
                    else {
                        // Apply realistic institutional body/wick ratios
                        const bodySize = Math.abs(close - open);
                        const totalRange = high - low;
                        
                        if (currentPhase === 'impulse') {
                            // Impulse: 60-80% body, small wicks
                            const targetBodyRatio = 0.6 + Math.random() * 0.2;
                            const currentRatio = totalRange > 0 ? bodySize / totalRange : 0.5;
                            
                            if (currentRatio < targetBodyRatio) {
                                // Reduce wicks to increase body ratio
                                const wickReduction = avgCandleSize * 0.1;
                                if (isBuy) {
                                    low = Math.max(low, open - wickReduction);
                                    high = Math.min(high, close + wickReduction);
                                } else {
                                    high = Math.min(high, open + wickReduction);
                                    low = Math.max(low, close - wickReduction);
                                }
                            }
                        } else if (currentPhase === 'pullback' || currentPhase === 'consolidation') {
                            // Pullback/Consolidation: 30-50% body, longer wicks
                            const targetBodyRatio = 0.3 + Math.random() * 0.2;
                            const wickExtension = avgCandleSize * (0.15 + Math.random() * 0.15);
                            high += wickExtension * 0.5;
                            low -= wickExtension * 0.5;
                        }
                    }
                    
                    // ============================================
                    // ADVANCED WICK BEHAVIOR BASED ON CONTEXT
                    // ============================================
                    
                    // Ensure proper OHLC first
                    high = Math.max(high || open, open, close || open);
                    low = Math.min(low || open, open, close || open);
                    
                    // Apply context-aware wick adjustments
                    const body = Math.abs(close - open);
                    const upperWick = high - Math.max(open, close);
                    const lowerWick = Math.min(open, close) - low;
                    const totalRange = high - low;
                    
                    // Near support/resistance - longer rejection wicks
                    const nearSupport = swingLows.length > 0 && 
                        Math.abs(low - swingLows[swingLows.length - 1].price) < avgCandleSize * 0.5;
                    const nearResistance = swingHighs.length > 0 && 
                        Math.abs(high - swingHighs[swingHighs.length - 1].price) < avgCandleSize * 0.5;
                    
                    if (nearSupport && isBuy && Math.random() < 0.6) {
                        // Extend lower wick for rejection at support
                        low = low - avgCandleSize * (0.2 + Math.random() * 0.2);
                        // Close should be in upper portion
                        if (close < open) {
                            close = open + body * 0.3;
                        }
                    }
                    
                    if (nearResistance && !isBuy && Math.random() < 0.6) {
                        // Extend upper wick for rejection at resistance
                        high = high + avgCandleSize * (0.2 + Math.random() * 0.2);
                        if (close > open) {
                            close = open - body * 0.3;
                        }
                    }
                    
                    // Near FVG - price tends to wick into gap
                    const nearFVG = fvgZones.find(f => !f.filled && (
                        (f.type === 'bullish' && low <= f.high && low >= f.low) ||
                        (f.type === 'bearish' && high >= f.low && high <= f.high)
                    ));
                    
                    if (nearFVG && Math.random() < 0.4) {
                        if (nearFVG.type === 'bullish') {
                            low = nearFVG.low + (nearFVG.high - nearFVG.low) * Math.random();
                            nearFVG.partialFill = Math.min(1, nearFVG.partialFill + 0.3);
                        } else {
                            high = nearFVG.high - (nearFVG.high - nearFVG.low) * Math.random();
                            nearFVG.partialFill = Math.min(1, nearFVG.partialFill + 0.3);
                        }
                    }
                    
                    // Near Order Block - price reacts with wicks
                    const nearOB = orderBlocks.find(ob => !ob.mitigated && (
                        (ob.type === 'bullish' && low <= ob.high && low >= ob.low) ||
                        (ob.type === 'bearish' && high >= ob.low && high <= ob.high)
                    ));
                    
                    if (nearOB && Math.random() < 0.5) {
                        nearOB.tested++;
                        if (nearOB.type === 'bullish' && isBuy) {
                            // Wick into bullish OB, close above
                            low = nearOB.low + (nearOB.high - nearOB.low) * (0.3 + Math.random() * 0.4);
                            if (close < nearOB.high) {
                                close = nearOB.high + avgCandleSize * 0.2;
                            }
                        } else if (nearOB.type === 'bearish' && !isBuy) {
                            high = nearOB.high - (nearOB.high - nearOB.low) * (0.3 + Math.random() * 0.4);
                            if (close > nearOB.low) {
                                close = nearOB.low - avgCandleSize * 0.2;
                            }
                        }
                        if (nearOB.tested >= 2) nearOB.mitigated = true;
                    }
                    
                    // Final validation
                    high = Math.max(high, open, close);
                    low = Math.min(low, open, close);
                    
                    // Ensure minimum candle size
                    if (high - low < avgCandleSize * 0.1) {
                        high = Math.max(open, close) + avgCandleSize * 0.05;
                        low = Math.min(open, close) - avgCandleSize * 0.05;
                    }
                    
                    predictedCandles.push({ time, open, high, low, close });
                    prevClose = close;
                }
                
                // Verify candles were generated
                console.log(`‚úÖ Loop completed. Generated ${predictedCandles.length} candles`);
                
                if (predictedCandles.length === 0) {
                    console.error('‚ùå No candles were generated!');
                    return;
                }
                
                // Log sample candles
                console.log('üìä First candle:', predictedCandles[0]);
                console.log('üìä Last candle:', predictedCandles[predictedCandles.length - 1]);
                
                // Log enhanced ICT structure summary
                const sweptIRL = irlZones.filter(z => z.swept).length;
                const filledFVG = fvgZones.filter(f => f.filled).length;
                const partialFVG = fvgZones.filter(f => f.partialFill > 0 && !f.filled).length;
                const mitigatedOB = orderBlocks.filter(ob => ob.mitigated).length;
                const testedOB = orderBlocks.filter(ob => ob.tested > 0).length;
                
                console.log(`üìä Market Structure: ${swingHighs.length} swing highs, ${swingLows.length} swing lows`);
                console.log(`üíß IRL: ${sweptIRL}/${irlZones.length} swept`);
                console.log(`üìê FVG: ${filledFVG} filled, ${partialFVG} partial`);
                console.log(`üß± OB: ${orderBlocks.length} created, ${testedOB} tested`);
                    
                // Set predicted candles on chart with SMOOTH ANIMATION
                if (predictedCandleSeries && predictedCandles.length > 0) {
                    // Option 1: Instant display (fastest)
                    // predictedCandleSeries.setData(predictedCandles);
                    
                    // Option 2: Animated display - candles appear progressively
                    await animatePredictedCandles(predictedCandles);
                    
                    console.log(`‚úÖ Set ${predictedCandles.length} predicted candles on chart`);
                    console.log('First predicted candle:', predictedCandles[0]);
                    console.log('Last predicted candle:', predictedCandles[predictedCandles.length - 1]);
                } else {
                    console.error('‚ùå Cannot set predicted candles:', {
                        seriesExists: !!predictedCandleSeries,
                        candleCount: predictedCandles.length
                    });
                }
                
                const endTime = performance.now();
                console.log(`‚úÖ Generated ${predictedCandles.length} candles in ${(endTime - startTime).toFixed(0)}ms`);
                
                // Calculate time to reach targets
                const firstPredictedTime = new Date(predictedCandles[0].time * 1000);
                const lastPredictedTime = new Date(predictedCandles[predictedCandles.length - 1].time * 1000);
                const totalMinutes = Math.round((lastPredictedTime - firstPredictedTime) / 60000);
                
                // Find when we hit each target
                let tp1Time = null, tp2Time = null, tp3Time = null;
                for (let i = 0; i < predictedCandles.length; i++) {
                    const candle = predictedCandles[i];
                    const price = isBuy ? candle.high : candle.low;
                    
                    if (!tp1Time && (isBuy ? price >= entry.avgTP1 : price <= entry.avgTP1)) {
                        tp1Time = Math.round((candle.time * 1000 - firstPredictedTime) / 60000);
                    }
                    if (!tp2Time && (isBuy ? price >= entry.avgTP2 : price <= entry.avgTP2)) {
                        tp2Time = Math.round((candle.time * 1000 - firstPredictedTime) / 60000);
                    }
                    if (!tp3Time && (isBuy ? price >= entry.avgTP3 : price <= entry.avgTP3)) {
                        tp3Time = Math.round((candle.time * 1000 - firstPredictedTime) / 60000);
                    }
                }
                
                // Format time display
                const formatTime = (mins) => {
                    if (!mins) return 'N/A';
                    if (mins < 60) return `${mins}m`;
                    const hours = Math.floor(mins / 60);
                    const remainingMins = mins % 60;
                    return remainingMins > 0 ? `${hours}h ${remainingMins}m` : `${hours}h`;
                };
                
                // Update UI status
                const statusEl = document.getElementById('prediction-status');
                if (statusEl) {
                    statusEl.innerHTML = `
                        üîÆ ${predictedCandles.length} predicted candles (${formatTime(totalMinutes)} total) | 
                        ‚è±Ô∏è TP1: ${formatTime(tp1Time)} | TP2: ${formatTime(tp2Time)} | TP3: ${formatTime(tp3Time)}
                    `;
                }
                
                // Update time analysis panel
                const timeAnalysis = document.getElementById('time-analysis');
                if (timeAnalysis) {
                    timeAnalysis.style.display = 'block';
                    document.getElementById('time-tp1').textContent = formatTime(tp1Time);
                    document.getElementById('time-tp2').textContent = formatTime(tp2Time);
                    document.getElementById('time-tp3').textContent = formatTime(tp3Time);
                    document.getElementById('time-total').textContent = formatTime(totalMinutes);
                }
                
                // Analyze and display candle/wick statistics
                // Create wave pattern array from the wave structure used
                const wavePatternForAnalysis = predictedCandles.map((_, i) => {
                    const progress = i / predictedCandles.length;
                    if (progress < 0.15) return 'impulse';
                    if (progress < 0.23) return 'correction';
                    if (progress < 0.41) return 'impulse';
                    if (progress < 0.47) return 'correction';
                    if (progress < 0.69) return 'impulse';
                    if (progress < 0.77) return 'consolidation';
                    if (progress < 0.89) return 'impulse';
                    if (progress < 0.94) return 'correction';
                    return 'impulse';
                });
                analyzePredictedCandles(predictedCandles, wavePatternForAnalysis, entry.type);
                
            } catch (error) {
                console.error('Error generating predictions:', error);
            }
        }
        
        // ============================================
        // SMOOTH ANIMATED CANDLE VISUALIZATION
        // ============================================
        let animationInProgress = false;
        let animationCancelled = false;
        
        async function animatePredictedCandles(candles) {
            if (!predictedCandleSeries || !candles || candles.length === 0) return;
            
            // Cancel any ongoing animation
            animationCancelled = true;
            await new Promise(r => setTimeout(r, 5));
            animationCancelled = false;
            animationInProgress = true;
            
            // Clear existing
            predictedCandleSeries.setData([]);
            
            // FAST MODE: Instant display
            if (fastAnimationMode) {
                predictedCandleSeries.setData(candles);
                animationInProgress = false;
                if (chart) chart.timeScale().fitContent();
                return;
            }
            
            // ANIMATED MODE: Smooth progressive display
            const totalDuration = 600; // Total animation time in ms (faster)
            const numBatches = 15; // Number of batches
            const batchSize = Math.ceil(candles.length / numBatches);
            const delayPerBatch = totalDuration / numBatches;
            
            let displayedCandles = [];
            
            // Use requestAnimationFrame for smoother rendering
            const animateBatch = (startIndex) => {
                if (animationCancelled || startIndex >= candles.length) {
                    if (!animationCancelled) {
                        predictedCandleSeries.setData(candles);
                        if (chart) chart.timeScale().fitContent();
                    }
                    animationInProgress = false;
                    return;
                }
                
                // Add batch of candles
                const endIndex = Math.min(startIndex + batchSize, candles.length);
                displayedCandles = candles.slice(0, endIndex);
                
                // Update chart
                predictedCandleSeries.setData(displayedCandles);
                
                // Schedule next batch
                setTimeout(() => {
                    requestAnimationFrame(() => animateBatch(endIndex));
                }, delayPerBatch);
            };
            
            // Start animation
            requestAnimationFrame(() => animateBatch(0));
        }
        
        // Fast instant display (no animation)
        function displayPredictedCandlesInstant(candles) {
            if (!predictedCandleSeries || !candles) return;
            predictedCandleSeries.setData(candles);
            if (chart) chart.timeScale().fitContent();
        }
        
        // Clear predictions and reset
        function clearPredictions() {
            animationCancelled = true;
            isPredictionActive = false;
            predictedCandles = [];
            
            if (predictedCandleSeries) {
                predictedCandleSeries.setData([]);
            }
            
            // Hide prediction status
            const statusEl = document.getElementById('prediction-status');
            if (statusEl) statusEl.innerHTML = '';
            
            // Hide accuracy scoreboard
            const scoreboard = document.getElementById('accuracy-scoreboard');
            if (scoreboard) scoreboard.style.display = 'none';
            
            // Hide time analysis
            const timeAnalysis = document.getElementById('time-analysis');
            if (timeAnalysis) timeAnalysis.style.display = 'none';
            
            console.log('üßπ Predictions cleared');
        }
        
        // Animation speed toggle
        let fastAnimationMode = false;
        
        function toggleAnimationSpeed() {
            fastAnimationMode = !fastAnimationMode;
            const btn = document.getElementById('speed-btn');
            if (btn) {
                btn.textContent = fastAnimationMode ? 'üê¢ Slow Mode' : '‚ö° Fast Mode';
                btn.style.background = fastAnimationMode ? '#26a69a' : '#f7931a';
            }
            console.log(`Animation mode: ${fastAnimationMode ? 'INSTANT' : 'ANIMATED'}`);
        }
        
        // Get interval in milliseconds
        function getIntervalMs(interval) {
            const map = {
                '1s': 1000,
                '1m': 60000,
                '3m': 180000,
                '5m': 300000,
                '15m': 900000,
                '1h': 3600000,
                '4h': 14400000
            };
            return map[interval] || 60000;
        }
        
        // Detect parallel channel (trend channel)
        function detectParallelChannel(candles, swingPoints, signalType) {
            if (!swingPoints.swingHighs || !swingPoints.swingLows) {
                return null;
            }
            
            const isBuy = signalType === 'BUY';
            const recentHighs = swingPoints.swingHighs.slice(-3);
            const recentLows = swingPoints.swingLows.slice(-3);
            
            if (recentHighs.length < 2 || recentLows.length < 2) {
                return null;
            }
            
            // Calculate trend line slopes
            const highSlope = (recentHighs[recentHighs.length - 1].price - recentHighs[0].price) / 
                            (recentHighs[recentHighs.length - 1].index - recentHighs[0].index);
            const lowSlope = (recentLows[recentLows.length - 1].price - recentLows[0].price) / 
                           (recentLows[recentLows.length - 1].index - recentLows[0].index);
            
            // Project channel forward
            const lastHigh = recentHighs[recentHighs.length - 1];
            const lastLow = recentLows[recentLows.length - 1];
            const candlesAhead = 10;
            
            return {
                upperBound: lastHigh.price + (highSlope * candlesAhead),
                lowerBound: lastLow.price + (lowSlope * candlesAhead),
                slope: (highSlope + lowSlope) / 2,
                width: lastHigh.price - lastLow.price
            };
        }
        
        // Select realistic candle pattern based on context
        function selectCandlePattern(wavePhase, momentum, candleIndex, totalCandles) {
            const patterns = {
                impulse: ['marubozu', 'strong_body', 'small_wick', 'engulfing'],
                correction: ['spinning_top', 'small_body', 'doji', 'harami', 'tweezer'],
                retest: ['hammer', 'shooting_star', 'pin_bar', 'dragonfly_doji', 'gravestone_doji'],
                consolidation: ['doji', 'spinning_top', 'inside_bar', 'harami']
            };
            
            // Stop hunt at swing points (10% chance)
            if (candleIndex % 4 === 0 && Math.random() < 0.1) {
                return 'stop_hunt';
            }
            
            // Add engulfing patterns at key points
            if (candleIndex % 5 === 0 && momentum > 1.2) {
                return 'engulfing';
            }
            
            // Add pin bars at reversals
            if (wavePhase === 'correction' && Math.random() < 0.3) {
                return 'pin_bar';
            }
            
            // Dragonfly/Gravestone doji at extremes
            if (candleIndex === 1 || candleIndex === totalCandles) {
                return Math.random() < 0.5 ? 'dragonfly_doji' : 'gravestone_doji';
            }
            
            // Harami after strong moves
            if (momentum > 1.3 && Math.random() < 0.2) {
                return 'harami';
            }
            
            // Select from phase-appropriate patterns
            const phasePatterns = patterns[wavePhase] || patterns.impulse;
            return phasePatterns[Math.floor(Math.random() * phasePatterns.length)];
        }
        
        // Apply candle pattern characteristics
        function applyCandlePattern(pattern, open, close, avgSize, isBuy) {
            let body = Math.abs(close - open);
            let upperWick, lowerWick;
            
            switch(pattern) {
                case 'marubozu': // No wicks, all body
                    upperWick = avgSize * 0.02;
                    lowerWick = avgSize * 0.02;
                    body = avgSize * 0.9;
                    break;
                    
                case 'hammer': // Long lower wick, small body
                    upperWick = avgSize * 0.05;
                    lowerWick = avgSize * 0.6;
                    body = avgSize * 0.2;
                    break;
                    
                case 'shooting_star': // Long upper wick, small body
                    upperWick = avgSize * 0.6;
                    lowerWick = avgSize * 0.05;
                    body = avgSize * 0.2;
                    break;
                    
                case 'pin_bar': // Long wick one side
                    if (isBuy) {
                        upperWick = avgSize * 0.1;
                        lowerWick = avgSize * 0.7;
                    } else {
                        upperWick = avgSize * 0.7;
                        lowerWick = avgSize * 0.1;
                    }
                    body = avgSize * 0.15;
                    break;
                    
                case 'doji': // Tiny body, equal wicks
                    upperWick = avgSize * 0.4;
                    lowerWick = avgSize * 0.4;
                    body = avgSize * 0.05;
                    break;
                    
                case 'spinning_top': // Small body, medium wicks
                    upperWick = avgSize * 0.3;
                    lowerWick = avgSize * 0.3;
                    body = avgSize * 0.25;
                    break;
                    
                case 'engulfing': // Large body engulfs previous
                    upperWick = avgSize * 0.1;
                    lowerWick = avgSize * 0.1;
                    body = avgSize * 1.2;
                    break;
                    
                case 'fakeout': // False breakout - long wick, small body opposite direction
                    if (isBuy) {
                        // Bullish fakeout: Wicks down (stop hunt), closes up
                        upperWick = avgSize * 0.15;
                        lowerWick = avgSize * 0.8; // Long lower wick (fake breakdown)
                        body = avgSize * 0.25; // Small bullish body
                    } else {
                        // Bearish fakeout: Wicks up (stop hunt), closes down
                        upperWick = avgSize * 0.8; // Long upper wick (fake breakout)
                        lowerWick = avgSize * 0.15;
                        body = avgSize * 0.25; // Small bearish body
                    }
                    break;
                    
                case 'stop_hunt': // Extreme wick to grab liquidity
                    if (isBuy) {
                        upperWick = avgSize * 0.2;
                        lowerWick = avgSize * 1.0; // Very long lower wick
                        body = avgSize * 0.3;
                    } else {
                        upperWick = avgSize * 1.0; // Very long upper wick
                        lowerWick = avgSize * 0.2;
                        body = avgSize * 0.3;
                    }
                    break;
                    
                case 'tweezer': // Two candles with same high/low
                    upperWick = avgSize * 0.3;
                    lowerWick = avgSize * 0.3;
                    body = avgSize * 0.35;
                    break;
                    
                case 'harami': // Small candle inside previous (opposite of engulfing)
                    upperWick = avgSize * 0.15;
                    lowerWick = avgSize * 0.15;
                    body = avgSize * 0.3;
                    break;
                    
                case 'dragonfly_doji': // Long lower wick, no upper wick
                    upperWick = avgSize * 0.02;
                    lowerWick = avgSize * 0.7;
                    body = avgSize * 0.05;
                    break;
                    
                case 'gravestone_doji': // Long upper wick, no lower wick
                    upperWick = avgSize * 0.7;
                    lowerWick = avgSize * 0.02;
                    body = avgSize * 0.05;
                    break;
                    
                default: // strong_body
                    upperWick = avgSize * 0.15;
                    lowerWick = avgSize * 0.15;
                    body = avgSize * 0.6;
            }
            
            return { body, upperWick, lowerWick };
        }
        
        // Detect Order Blocks (last bearish candle before bullish move, or vice versa)
        function detectOrderBlocks(candles, signalType) {
            const orderBlocks = [];
            const isBuy = signalType === 'BUY';
            
            for (let i = 3; i < candles.length - 1; i++) {
                const open = parseFloat(candles[i][1]);
                const high = parseFloat(candles[i][2]);
                const low = parseFloat(candles[i][3]);
                const close = parseFloat(candles[i][4]);
                
                const nextOpen = parseFloat(candles[i + 1][1]);
                const nextClose = parseFloat(candles[i + 1][4]);
                
                if (isBuy) {
                    // Bullish OB: Last bearish candle before strong bullish move
                    if (close < open && nextClose > nextOpen && nextClose > high) {
                        orderBlocks.push({
                            price: (high + low) / 2,
                            high: high,
                            low: low,
                            type: 'bullish',
                            strength: Math.abs(nextClose - nextOpen)
                        });
                    }
                } else {
                    // Bearish OB: Last bullish candle before strong bearish move
                    if (close > open && nextClose < nextOpen && nextClose < low) {
                        orderBlocks.push({
                            price: (high + low) / 2,
                            high: high,
                            low: low,
                            type: 'bearish',
                            strength: Math.abs(nextClose - nextOpen)
                        });
                    }
                }
            }
            
            return orderBlocks.slice(-3); // Last 3 order blocks
        }
        
        // Detect Fair Value Gaps (FVG) - imbalances in price
        function detectFairValueGaps(candles) {
            const fvgs = [];
            
            for (let i = 1; i < candles.length - 1; i++) {
                const prevHigh = parseFloat(candles[i - 1][2]);
                const prevLow = parseFloat(candles[i - 1][3]);
                const currentHigh = parseFloat(candles[i][2]);
                const currentLow = parseFloat(candles[i][3]);
                const nextHigh = parseFloat(candles[i + 1][2]);
                const nextLow = parseFloat(candles[i + 1][3]);
                
                // Bullish FVG: Gap between prev high and next low
                if (nextLow > prevHigh) {
                    fvgs.push({
                        low: prevHigh,
                        high: nextLow,
                        type: 'bullish',
                        size: nextLow - prevHigh
                    });
                }
                
                // Bearish FVG: Gap between prev low and next high
                if (nextHigh < prevLow) {
                    fvgs.push({
                        low: nextHigh,
                        high: prevLow,
                        type: 'bearish',
                        size: prevLow - nextHigh
                    });
                }
            }
            
            return fvgs.slice(-5); // Last 5 FVGs
        }
        
        // Identify liquidity sweep areas (where stops are likely)
        function identifyLiquiditySweeps(candles, swingPoints) {
            const sweeps = [];
            
            // Liquidity sits above swing highs and below swing lows
            if (swingPoints.swingHighs) {
                swingPoints.swingHighs.forEach(swing => {
                    sweeps.push({
                        price: swing.price,
                        type: 'high',
                        description: 'Buy stops above swing high'
                    });
                });
            }
            
            if (swingPoints.swingLows) {
                swingPoints.swingLows.forEach(swing => {
                    sweeps.push({
                        price: swing.price,
                        type: 'low',
                        description: 'Sell stops below swing low'
                    });
                });
            }
            
            return sweeps;
        }
        
        // Detect swing highs and swing lows
        function detectSwingPoints(candles) {
            const swingHighs = [];
            const swingLows = [];
            const lookback = 2; // Candles on each side to confirm swing
            
            for (let i = lookback; i < candles.length - lookback; i++) {
                const currentHigh = parseFloat(candles[i][2]);
                const currentLow = parseFloat(candles[i][3]);
                
                // Check for swing high (higher than surrounding candles)
                let isSwingHigh = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j !== i && parseFloat(candles[j][2]) >= currentHigh) {
                        isSwingHigh = false;
                        break;
                    }
                }
                if (isSwingHigh) {
                    swingHighs.push({ index: i, price: currentHigh });
                }
                
                // Check for swing low (lower than surrounding candles)
                let isSwingLow = true;
                for (let j = i - lookback; j <= i + lookback; j++) {
                    if (j !== i && parseFloat(candles[j][3]) <= currentLow) {
                        isSwingLow = false;
                        break;
                    }
                }
                if (isSwingLow) {
                    swingLows.push({ index: i, price: currentLow });
                }
            }
            
            return {
                swingHighs: swingHighs.slice(-5), // Last 5 swing highs
                swingLows: swingLows.slice(-5),   // Last 5 swing lows
                lastSwingHigh: swingHighs.length > 0 ? swingHighs[swingHighs.length - 1].price : null,
                lastSwingLow: swingLows.length > 0 ? swingLows[swingLows.length - 1].price : null
            };
        }
        
        // Analyze market structure for realistic predictions
        function analyzeMarketStructure(candles) {
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            const volumes = candles.map(c => parseFloat(c[5]));
            
            // Calculate trend strength using EMA
            const ema20 = calculateEMA(closes, 20);
            const ema50 = calculateEMA(closes, 50);
            const currentPrice = closes[closes.length - 1];
            
            // Trend direction and strength
            const trendUp = ema20 > ema50;
            const trendDistance = Math.abs(ema20 - ema50);
            const avgPrice = closes.reduce((a, b) => a + b, 0) / closes.length;
            const trendStrength = Math.min(1.5, 0.5 + (trendDistance / avgPrice) * 100);
            
            // Find support and resistance levels
            const recentHighs = highs.slice(-20);
            const recentLows = lows.slice(-20);
            const resistance = Math.max(...recentHighs);
            const support = Math.min(...recentLows);
            
            // Calculate volatility (ATR-like)
            let totalRange = 0;
            for (let i = 0; i < Math.min(14, candles.length); i++) {
                const idx = candles.length - 1 - i;
                const high = parseFloat(candles[idx][2]);
                const low = parseFloat(candles[idx][3]);
                totalRange += (high - low);
            }
            const avgRange = totalRange / Math.min(14, candles.length);
            const volatility = 0.3 + Math.min(1.0, (avgRange / currentPrice) * 100);
            
            // Volume trend
            const recentVolume = volumes.slice(-10).reduce((a, b) => a + b, 0) / 10;
            const olderVolume = volumes.slice(-30, -10).reduce((a, b) => a + b, 0) / 20;
            const volumeIncrease = recentVolume > olderVolume * 1.2;
            
            return {
                trendUp: trendUp,
                trendStrength: trendStrength,
                resistance: resistance,
                support: support,
                volatility: volatility,
                volumeIncrease: volumeIncrease,
                ema20: ema20,
                ema50: ema50
            };
        }
        
        // Calculate Exponential Moving Average
        function calculateEMA(data, period) {
            if (data.length < period) return data[data.length - 1];
            
            const multiplier = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            for (let i = period; i < data.length; i++) {
                ema = (data[i] - ema) * multiplier + ema;
            }
            
            return ema;
        }
        
        // Calculate Fibonacci retracement levels
        function calculateFibonacciLevels(startPrice, endPrice, isBuy) {
            const levels = [0.236, 0.382, 0.5, 0.618, 0.786];
            const range = Math.abs(endPrice - startPrice);
            
            return levels.map(level => ({
                level: level,
                price: isBuy ? startPrice + (range * level) : startPrice - (range * level),
                name: `Fib ${(level * 100).toFixed(1)}%`
            }));
        }
        
        // Generate Elliott Wave pattern with retest phases
        function generateWavePatternWithRetests(totalCandles, numRetests) {
            const pattern = [];
            const waveStructure = [
                { type: 'impulse', ratio: 0.15 },      // Wave 1 - Initial breakout
                { type: 'retest', ratio: 0.08 },       // Retest breakout level
                { type: 'impulse', ratio: 0.12 },      // Continuation after retest
                { type: 'correction', ratio: 0.08 },   // Wave 2
                { type: 'impulse', ratio: 0.22 },      // Wave 3 (strongest)
                { type: 'retest', ratio: 0.08 },       // Retest previous high/low
                { type: 'correction', ratio: 0.07 },   // Wave 4
                { type: 'impulse', ratio: 0.15 },      // Wave 5
                { type: 'consolidation', ratio: 0.05 } // Final consolidation
            ];
            
            for (const wave of waveStructure) {
                const waveLength = Math.floor(totalCandles * wave.ratio);
                for (let i = 0; i < waveLength; i++) {
                    pattern.push(wave.type);
                }
            }
            
            // Fill remaining with impulse
            while (pattern.length < totalCandles) {
                pattern.push('impulse');
            }
            
            return pattern;
        }
        
        // Extract mirror patterns from historical data
        function extractMirrorPatterns(candles, signalType, marketStructure) {
            const patterns = [];
            const lookback = Math.min(30, candles.length - 10);
            
            // Find similar market conditions in history
            for (let i = candles.length - lookback; i < candles.length - 5; i++) {
                const historicalCandles = candles.slice(i, i + 5);
                
                // Calculate historical trend
                const firstClose = parseFloat(historicalCandles[0][4]);
                const lastClose = parseFloat(historicalCandles[4][4]);
                const historicalTrend = lastClose > firstClose ? 'BUY' : 'SELL';
                
                // Only use patterns that match current signal direction
                if (historicalTrend !== signalType) continue;
                
                // Extract candle characteristics
                for (let j = 0; j < historicalCandles.length; j++) {
                    const candle = historicalCandles[j];
                    const open = parseFloat(candle[1]);
                    const high = parseFloat(candle[2]);
                    const low = parseFloat(candle[3]);
                    const close = parseFloat(candle[4]);
                    
                    const body = Math.abs(close - open);
                    const totalRange = high - low;
                    const upperWick = high - Math.max(open, close);
                    const lowerWick = Math.min(open, close) - low;
                    
                    // Calculate ratios (these are the "mirror" characteristics)
                    const bodyRatio = totalRange > 0 ? body / totalRange : 0.5;
                    const upperWickRatio = body > 0 ? upperWick / body : 0.3;
                    const lowerWickRatio = body > 0 ? lowerWick / body : 0.3;
                    const isBullish = close > open;
                    
                    patterns.push({
                        bodyRatio: bodyRatio,
                        upperWickRatio: upperWickRatio,
                        lowerWickRatio: lowerWickRatio,
                        isBullish: isBullish,
                        totalRange: totalRange,
                        momentum: (close - open) / totalRange // Directional strength
                    });
                }
            }
            
            // Return most recent patterns (they're most relevant)
            return patterns.slice(-20); // Last 20 patterns
        }
        
        // Identify liquidity zones (previous highs/lows where retests occur)
        function identifyLiquidityZones(candles, currentPrice, isBuy) {
            const zones = [];
            const lookback = Math.min(50, candles.length);
            
            // Find swing highs and lows
            for (let i = lookback - 1; i >= 2; i--) {
                const idx = candles.length - i;
                const high = parseFloat(candles[idx][2]);
                const low = parseFloat(candles[idx][3]);
                const prevHigh = parseFloat(candles[idx - 1][2]);
                const prevLow = parseFloat(candles[idx - 1][3]);
                const nextHigh = parseFloat(candles[idx + 1][2]);
                const nextLow = parseFloat(candles[idx + 1][3]);
                
                // Swing high (liquidity above)
                if (high > prevHigh && high > nextHigh) {
                    zones.push({
                        price: high,
                        type: 'resistance',
                        strength: high - low, // Range indicates strength
                        age: i
                    });
                }
                
                // Swing low (liquidity below)
                if (low < prevLow && low < nextLow) {
                    zones.push({
                        price: low,
                        type: 'support',
                        strength: high - low,
                        age: i
                    });
                }
            }
            
            // Filter relevant zones based on direction
            const relevantZones = zones
                .filter(z => isBuy ? z.price < currentPrice : z.price > currentPrice)
                .sort((a, b) => Math.abs(b.price - currentPrice) - Math.abs(a.price - currentPrice))
                .slice(0, 3); // Keep top 3 closest zones
            
            return relevantZones;
        }
        
        // Analyze predicted candles for visualization
        function analyzePredictedCandles(candles, wavePattern, signalType) {
            if (!candles || candles.length === 0) return;
            
            // Calculate statistics
            let totalBodyRatio = 0;
            let totalUpperWick = 0;
            let totalLowerWick = 0;
            let rejectionCount = 0;
            let impulseCount = 0;
            let correctionCount = 0;
            let retestCount = 0;
            let consolidationCount = 0;
            let insideBarCount = 0;
            
            const insights = [];
            
            candles.forEach((candle, index) => {
                const body = Math.abs(candle.close - candle.open);
                const totalRange = candle.high - candle.low;
                const upperWick = candle.high - Math.max(candle.open, candle.close);
                const lowerWick = Math.min(candle.open, candle.close) - candle.low;
                
                // Calculate ratios
                const bodyRatio = totalRange > 0 ? body / totalRange : 0;
                const upperWickRatio = totalRange > 0 ? upperWick / totalRange : 0;
                const lowerWickRatio = totalRange > 0 ? lowerWick / totalRange : 0;
                
                totalBodyRatio += bodyRatio;
                totalUpperWick += upperWickRatio;
                totalLowerWick += lowerWickRatio;
                
                // Detect inside bars (current candle within previous candle's range)
                if (index > 0) {
                    const prevCandle = candles[index - 1];
                    if (candle.high < prevCandle.high && candle.low > prevCandle.low) {
                        insideBarCount++;
                    }
                }
                
                // Detect rejection candles (long wicks, small bodies)
                if (bodyRatio < 0.3 && (upperWickRatio > 0.5 || lowerWickRatio > 0.5)) {
                    rejectionCount++;
                }
                
                // Count wave types
                const wave = wavePattern[index];
                if (wave === 'impulse') impulseCount++;
                else if (wave === 'correction') correctionCount++;
                else if (wave === 'retest') retestCount++;
                else if (wave === 'consolidation') consolidationCount++;
            });
            
            const avgBodyRatio = (totalBodyRatio / candles.length * 100).toFixed(1);
            const avgUpperWick = (totalUpperWick / candles.length * 100).toFixed(1);
            const avgLowerWick = (totalLowerWick / candles.length * 100).toFixed(1);
            
            // Generate insights
            if (avgBodyRatio > 60) {
                insights.push(`‚úÖ Strong ${signalType} momentum - Large candle bodies (${avgBodyRatio}%)`);
            } else if (avgBodyRatio < 30) {
                insights.push(`‚ö†Ô∏è Weak momentum - Small bodies indicate indecision (${avgBodyRatio}%)`);
            }
            
            if (rejectionCount > candles.length * 0.2) {
                insights.push(`üîÑ ${rejectionCount} rejection candles detected - Expect volatility at key levels`);
            }
            
            if (retestCount > 0) {
                insights.push(`üéØ ${retestCount} retest candles - Price will test breakout levels`);
            }
            
            if (avgUpperWick > 40) {
                insights.push(`üìà High upper wick activity (${avgUpperWick}%) - Resistance overhead`);
            }
            
            if (avgLowerWick > 40) {
                insights.push(`üìâ High lower wick activity (${avgLowerWick}%) - Support below`);
            }
            
            if (impulseCount > candles.length * 0.5) {
                insights.push(`üöÄ ${impulseCount} impulse waves - Strong directional movement expected`);
            }
            
            if (insideBarCount > 0) {
                insights.push(`üì¶ ${insideBarCount} inside bar(s) detected - Consolidation before breakout`);
            }
            
            // Update UI
            document.getElementById('candle-analysis').style.display = 'block';
            document.getElementById('analysis-count').textContent = `${candles.length} candles analyzed`;
            
            document.getElementById('avg-body-ratio').textContent = `${avgBodyRatio}%`;
            document.getElementById('body-ratio-bar').style.width = `${avgBodyRatio}%`;
            
            document.getElementById('avg-upper-wick').textContent = `${avgUpperWick}%`;
            document.getElementById('upper-wick-bar').style.width = `${avgUpperWick}%`;
            
            document.getElementById('avg-lower-wick').textContent = `${avgLowerWick}%`;
            document.getElementById('lower-wick-bar').style.width = `${avgLowerWick}%`;
            
            document.getElementById('rejection-count').textContent = rejectionCount;
            
            document.getElementById('impulse-count').textContent = impulseCount;
            document.getElementById('correction-count').textContent = correctionCount;
            document.getElementById('retest-count').textContent = retestCount;
            document.getElementById('consolidation-count').textContent = consolidationCount;
            
            // Display insights
            const insightsList = document.getElementById('insights-list');
            insightsList.innerHTML = insights.map(insight => 
                `<div style="margin: 4px 0;">‚Ä¢ ${insight}</div>`
            ).join('');
            
            console.log('üìä Candle Analysis:', {
                avgBodyRatio,
                avgUpperWick,
                avgLowerWick,
                rejectionCount,
                patterns: { impulseCount, correctionCount, retestCount, consolidationCount }
            });
        }
        
        function drawEntryLevelsOLD(entry) {
            currentEntry = entry;
            
            const isBuy = entry.type === 'BUY';
            const color = isBuy ? '#26a69a' : '#ef5350';
            
            // Calculate price range including candles
            const prices = [entry.avgEntry, entry.avgStopLoss, entry.avgTP1, entry.avgTP2, entry.avgTP3];
            if (candleData.length > 0) {
                candleData.forEach(c => {
                    prices.push(c.high, c.low);
                });
            }
            const maxPrice = Math.max(...prices);
            const minPrice = Math.min(...prices);
            const priceRange = maxPrice - minPrice;
            const padding = priceRange * 0.1;
            
            // Chart dimensions
            const chartTop = 50;
            const chartBottom = canvas.height - 50;
            const chartHeight = chartBottom - chartTop;
            const chartLeft = 100;
            const chartRight = canvas.width - 200;
            
            // Price to Y coordinate with zoom and offset
            const priceToY = (price) => {
                if (autoScale) {
                    const ratio = (price - (minPrice - padding)) / (priceRange + 2 * padding);
                    return chartBottom - (ratio * chartHeight);
                } else {
                    const centerPrice = (maxPrice + minPrice) / 2;
                    const adjustedRange = (priceRange + 2 * padding) / priceZoom;
                    const ratio = (price - (centerPrice - adjustedRange / 2)) / adjustedRange;
                    return chartBottom - (ratio * chartHeight) + priceOffset;
                }
            };
            
            // Draw background grid with price labels
            ctx.strokeStyle = '#2a2e39';
            ctx.lineWidth = 1;
            ctx.fillStyle = '#787b86';
            ctx.font = '11px Arial';
            ctx.textAlign = 'left';
            
            for (let i = 0; i <= 10; i++) {
                const y = chartTop + (chartHeight / 10) * i;
                const price = (maxPrice + padding) - ((i / 10) * (priceRange + 2 * padding));
                
                // Grid line
                ctx.beginPath();
                ctx.moveTo(chartLeft, y);
                ctx.lineTo(chartRight, y);
                ctx.stroke();
                
                // Price label on left
                ctx.fillStyle = '#787b86';
                ctx.textAlign = 'right';
                ctx.fillText(price.toFixed(2), chartLeft - 10, y + 4);
            }
            
            // Draw candlesticks with zoom and pan
            if (candleData.length > 0) {
                const visibleCandles = Math.floor(candleData.length / chartZoom);
                const startIndex = Math.max(0, Math.floor(-chartOffset / ((chartRight - chartLeft) / visibleCandles)));
                const endIndex = Math.min(candleData.length, startIndex + visibleCandles + 10);
                
                const candleWidth = ((chartRight - chartLeft) / visibleCandles) * chartZoom;
                const candleSpacing = candleWidth * 0.2;
                const actualCandleWidth = Math.max(1, candleWidth - candleSpacing);
                
                for (let i = startIndex; i < endIndex; i++) {
                    const candle = candleData[i];
                    const x = chartLeft + ((i - startIndex) * candleWidth) + (candleSpacing / 2) + chartOffset;
                    
                    if (x < chartLeft - candleWidth || x > chartRight + candleWidth) continue;
                    
                    const openY = priceToY(candle.open);
                    const closeY = priceToY(candle.close);
                    const highY = priceToY(candle.high);
                    const lowY = priceToY(candle.low);
                    
                    const isBullish = candle.close > candle.open;
                    const candleColor = isBullish ? '#26a69a' : '#ef5350';
                    
                    // Draw wick
                    ctx.strokeStyle = candleColor;
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x + actualCandleWidth / 2, highY);
                    ctx.lineTo(x + actualCandleWidth / 2, lowY);
                    ctx.stroke();
                    
                    // Draw body
                    ctx.fillStyle = candleColor;
                    const bodyTop = Math.min(openY, closeY);
                    const bodyHeight = Math.abs(closeY - openY) || 1;
                    ctx.fillRect(x, bodyTop, actualCandleWidth, bodyHeight);
                }
            }
            
            // Draw price levels
            const levels = [
                { price: entry.avgTP3, label: 'TP3', color: '#66bb6a', dash: [10, 5] },
                { price: entry.avgTP2, label: 'TP2', color: '#4caf50', dash: [10, 5] },
                { price: entry.avgTP1, label: 'TP1', color: '#26a69a', dash: [10, 5] },
                { price: entry.avgEntry, label: 'ENTRY', color: color, dash: [] },
                { price: entry.avgStopLoss, label: 'STOP LOSS', color: '#ef5350', dash: [10, 5] }
            ];
            
            levels.forEach(level => {
                const y = priceToY(level.price);
                
                // Draw line
                ctx.strokeStyle = level.color;
                ctx.lineWidth = level.label === 'ENTRY' ? 4 : 2;
                ctx.setLineDash(level.dash);
                ctx.beginPath();
                ctx.moveTo(chartLeft, y);
                ctx.lineTo(chartRight, y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw label background
                ctx.fillStyle = level.color;
                const labelWidth = 150;
                const labelHeight = 30;
                ctx.fillRect(chartRight + 10, y - labelHeight/2, labelWidth, labelHeight);
                
                // Draw label text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(level.label, chartRight + 20, y - 8);
                ctx.font = '12px Arial';
                ctx.fillText(level.price.toFixed(2), chartRight + 20, y + 8);
            });
            
            // Draw title
            ctx.fillStyle = '#d1d4dc';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`${isBuy ? 'üìà' : 'üìâ'} ${entry.type} ${entry.symbol}`, canvas.width / 2, 30);
            
            // Draw info
            ctx.font = '14px Arial';
            ctx.fillStyle = '#787b86';
            ctx.fillText(`Confluence: ${entry.confluenceScore}/6 | Strength: ${entry.avgStrength}% | Timeframes: ${entry.timeframes.join(', ')}`, canvas.width / 2, chartBottom + 30);
            
            // Draw risk/reward box
            const risk = Math.abs(entry.avgEntry - entry.avgStopLoss);
            const reward = Math.abs(entry.avgTP3 - entry.avgEntry);
            const rr = (reward / risk).toFixed(2);
            
            ctx.fillStyle = '#1e222d';
            ctx.fillRect(20, chartTop, 70, 120);
            ctx.strokeStyle = '#2a2e39';
            ctx.strokeRect(20, chartTop, 70, 120);
            
            ctx.fillStyle = '#d1d4dc';
            ctx.font = 'bold 12px Arial';
            ctx.textAlign = 'left';
            ctx.fillText('Risk', 30, chartTop + 20);
            ctx.fillStyle = '#ef5350';
            ctx.fillText(`$${risk.toFixed(0)}`, 30, chartTop + 40);
            
            ctx.fillStyle = '#d1d4dc';
            ctx.fillText('Reward', 30, chartTop + 65);
            ctx.fillStyle = '#26a69a';
            ctx.fillText(`$${reward.toFixed(0)}`, 30, chartTop + 85);
            
            ctx.fillStyle = '#d1d4dc';
            ctx.fillText('R:R', 30, chartTop + 105);
            ctx.fillStyle = '#f7931a';
            ctx.font = 'bold 14px Arial';
            ctx.fillText(`${rr}:1`, 30, chartTop + 125);
            
            // Update chart info and button states
            document.getElementById('chart-info').innerHTML = `
                ${isBuy ? 'üìà' : 'üìâ'} ${entry.type} ${entry.symbol} | 
                Confluence: ${entry.confluenceScore}/6 | 
                Strength: ${entry.avgStrength}% | 
                H-Zoom: ${chartZoom.toFixed(1)}x | V-Zoom: ${priceZoom.toFixed(1)}x | 
                ${autoScale ? 'üìê Auto' : 'üéØ Manual'} ${priceLocked ? 'üîí' : 'üîì'} | 
                üí° Scroll=zoom, Shift+Scroll=H-zoom, Ctrl+Scroll=V-zoom, Drag=pan
            `;
            
            // Update button states
            const autoBtn = document.getElementById('autoScaleBtn');
            const lockBtn = document.getElementById('priceLockBtn');
            if (autoBtn) {
                autoBtn.style.background = autoScale ? '#26a69a' : '#2a2e39';
                autoBtn.style.color = autoScale ? 'white' : '#d1d4dc';
            }
            if (lockBtn) {
                lockBtn.style.background = priceLocked ? '#f85149' : '#2a2e39';
                lockBtn.style.color = priceLocked ? 'white' : '#d1d4dc';
            }
            
            // Save chart state for crosshair overlay
            savechartState();
        }
        
        // ============================================
        // CANDLE CLOSE TIMER - TradingView Style
        // ============================================
        
        function getTimeframeMs(tf) {
            const map = {
                '1s': 1000,
                '1m': 60000,
                '3m': 180000,
                '5m': 300000,
                '15m': 900000,
                '30m': 1800000,
                '1h': 3600000,
                '2h': 7200000,
                '4h': 14400000,
                '1d': 86400000
            };
            return map[tf] || 60000;
        }
        
        function startCandleTimer() {
            // Clear existing timer
            if (candleTimerInterval) {
                clearInterval(candleTimerInterval);
            }
            
            const updateTimer = () => {
                const now = Date.now();
                const tfMs = getTimeframeMs(currentChartTimeframe);
                
                // Calculate time until next candle close
                const currentCandleStart = Math.floor(now / tfMs) * tfMs;
                const nextCandleStart = currentCandleStart + tfMs;
                const remaining = nextCandleStart - now;
                
                // Calculate progress percentage
                const elapsed = now - currentCandleStart;
                const progress = (elapsed / tfMs) * 100;
                
                // Format time remaining
                let timeStr;
                if (remaining < 1000) {
                    timeStr = '00:00';
                } else if (remaining < 60000) {
                    // Less than 1 minute - show seconds
                    const secs = Math.floor(remaining / 1000);
                    timeStr = `00:${secs.toString().padStart(2, '0')}`;
                } else if (remaining < 3600000) {
                    // Less than 1 hour - show mm:ss
                    const mins = Math.floor(remaining / 60000);
                    const secs = Math.floor((remaining % 60000) / 1000);
                    timeStr = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                } else {
                    // More than 1 hour - show hh:mm:ss
                    const hours = Math.floor(remaining / 3600000);
                    const mins = Math.floor((remaining % 3600000) / 60000);
                    const secs = Math.floor((remaining % 60000) / 1000);
                    timeStr = `${hours}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }
                
                // Update timer display
                const timerEl = document.getElementById('candle-timer');
                if (timerEl) {
                    timerEl.textContent = timeStr;
                    
                    // Color based on urgency
                    if (remaining < 5000) {
                        timerEl.style.color = '#ef5350'; // Red - closing soon!
                        timerEl.style.animation = 'pulse 0.5s infinite';
                    } else if (remaining < 15000) {
                        timerEl.style.color = '#f7931a'; // Orange - warning
                        timerEl.style.animation = 'none';
                    } else {
                        timerEl.style.color = '#26a69a'; // Green - normal
                        timerEl.style.animation = 'none';
                    }
                }
                
                // Update progress bar
                const progressBar = document.getElementById('candle-progress-bar');
                if (progressBar) {
                    progressBar.style.width = `${progress}%`;
                    
                    // Color based on progress
                    if (progress > 90) {
                        progressBar.style.background = 'linear-gradient(90deg, #ef5350, #ff6b6b)';
                    } else if (progress > 75) {
                        progressBar.style.background = 'linear-gradient(90deg, #f7931a, #ffa726)';
                    } else {
                        progressBar.style.background = 'linear-gradient(90deg, #26a69a, #4caf50)';
                    }
                }
                
                // Update timeframe display
                const tfDisplay = document.getElementById('current-tf-display');
                if (tfDisplay) {
                    tfDisplay.textContent = currentChartTimeframe.toUpperCase();
                }
            };
            
            // Update immediately
            updateTimer();
            
            // Update every 100ms for smooth countdown
            candleTimerInterval = setInterval(updateTimer, 100);
        }
        
        // Change chart timeframe
        function changeChartTimeframe(timeframe) {
            currentChartTimeframe = timeframe;
            
            // Update button styles
            document.querySelectorAll('.time-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = '#2a2e39';
                btn.style.color = '#d1d4dc';
            });
            event.target.classList.add('active');
            event.target.style.background = '#26a69a';
            event.target.style.color = 'white';
            
            // Restart candle timer for new timeframe
            startCandleTimer();
            
            // Reload chart data with new timeframe
            if (currentEntry) {
                loadChartData(currentEntry.symbol, timeframe).then(() => {
                    // Redraw entry levels after chart data loads
                    drawEntryLevelsOnly(currentEntry);
                });
            } else {
                loadChartData('BTCUSDT', timeframe);
            }
        }
        
        // Draw only the price lines (without reloading chart data)
        function drawEntryLevelsOnly(entry) {
            const isBuy = entry.type === 'BUY';
            
            // Remove existing price lines
            Object.values(priceLinesMap).forEach(line => {
                if (candleSeries) candleSeries.removePriceLine(line);
            });
            priceLinesMap = {};
            
            // Draw price lines on chart
            if (candleSeries) {
                // Entry line
                priceLinesMap.entry = candleSeries.createPriceLine({
                    price: entry.avgEntry,
                    color: isBuy ? '#26a69a' : '#ef5350',
                    lineWidth: 3,
                    lineStyle: LightweightCharts.LineStyle.Solid,
                    axisLabelVisible: true,
                    title: 'ENTRY',
                });
                
                // Stop Loss line
                priceLinesMap.sl = candleSeries.createPriceLine({
                    price: entry.avgStopLoss,
                    color: '#ef5350',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'SL',
                });
                
                // TP1 line
                priceLinesMap.tp1 = candleSeries.createPriceLine({
                    price: entry.avgTP1,
                    color: '#26a69a',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP1',
                });
                
                // TP2 line
                priceLinesMap.tp2 = candleSeries.createPriceLine({
                    price: entry.avgTP2,
                    color: '#4caf50',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP2',
                });
                
                // TP3 line
                priceLinesMap.tp3 = candleSeries.createPriceLine({
                    price: entry.avgTP3,
                    color: '#66bb6a',
                    lineWidth: 2,
                    lineStyle: LightweightCharts.LineStyle.Dashed,
                    axisLabelVisible: true,
                    title: 'TP3',
                });
            }
        }
        
        // Debug function
        function debugChart() {
            console.log('=== CHART DEBUG ===');
            console.log('Chart object:', chart);
            console.log('Candle series:', candleSeries);
            console.log('Predicted series:', predictedCandleSeries);
            console.log('Container:', document.getElementById('tradingview_chart'));
            console.log('LightweightCharts:', typeof LightweightCharts);
            console.log('==================');
        }
        
        // Make debug available globally
        window.debugChart = debugChart;
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, LightweightCharts available:', typeof LightweightCharts !== 'undefined');
            
            console.log('üöÄ Page loaded, initializing...');
            const pageLoadStart = performance.now();
            
            // Start candle close timer immediately
            startCandleTimer();
            
            // Initialize chart immediately
            initChart();
            
            // Load default chart data
            loadChartData('BTCUSDT', '1m').then(() => {
                const chartLoadTime = performance.now() - pageLoadStart;
                console.log(`‚úÖ Chart ready in ${chartLoadTime.toFixed(0)}ms`);
            });
            
            // Load entries
            loadBestEntries().then(() => {
                const totalLoadTime = performance.now() - pageLoadStart;
                console.log(`‚úÖ Page fully loaded in ${totalLoadTime.toFixed(0)}ms`);
            });
        });
        
        // Auto-refresh disabled - manual refresh only to prevent chart disruption
        // setInterval(loadBestEntries, 30000);
        
        // Optional: Add manual refresh reminder after 5 minutes
        setTimeout(() => {
            console.log('üí° Data may be stale. Click Refresh to update.');
        }, 300000);
    </script>
</body>
</html>
