package telegram

import (
	"bytes"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"time"
)

type TelegramBot struct {
	Token   string
	ChatID  string
	Running bool
}

type TelegramMessage struct {
	ChatID    string `json:"chat_id"`
	Text      string `json:"text"`
	ParseMode string `json:"parse_mode"`
}

var telegramBot *TelegramBot

// InitTelegramBot initializes the Telegram bot
func InitTelegramBot() {
	token := os.Getenv("TELEGRAM_BOT_TOKEN")
	chatID := os.Getenv("TELEGRAM_CHAT_ID")
	
	if token == "" || chatID == "" {
		log.Println("âš ï¸  Telegram bot not configured (missing TELEGRAM_BOT_TOKEN or TELEGRAM_CHAT_ID)")
		return
	}
	
	telegramBot = &TelegramBot{
		Token:   token,
		ChatID:  chatID,
		Running: false,
	}
	
	log.Println("âœ… Telegram bot initialized")
}

// StartTelegramSignalBot enables Telegram notifications (bot is just a messenger now)
func StartTelegramSignalBot(symbol, strategy string, filterBuy, filterSell bool) error {
	if telegramBot == nil {
		return fmt.Errorf("telegram bot not initialized")
	}
	
	if telegramBot.Running {
		return fmt.Errorf("telegram bot already running")
	}
	
	telegramBot.Running = true
	
	// Get CURRENT filter settings from database (not the passed parameters)
	currentFilterBuy, currentFilterSell := GetCurrentFilterSettings()
	
	// Send startup message with CURRENT settings
	startMsg := fmt.Sprintf("ğŸ¤– *Trading Signal Bot Started*\n\n"+
		"ğŸ“Š Symbol: `%s`\n"+
		"ğŸ¯ Strategy: `%s`\n"+
		"ğŸŸ¢ Buy Signals: %v\n"+
		"ğŸ”´ Sell Signals: %v\n\n"+
		"_Telegram notifications enabled_\n"+
		"_Signals generated by Live Signal Handler_\n"+
		"_All signals saved to Supabase automatically_",
		symbol, strategy, currentFilterBuy, currentFilterSell)
	
	telegramBot.SendMessage(startMsg)
	
	log.Printf("ğŸ¤– Telegram bot started - notifications enabled for %s with %s strategy", symbol, strategy)
	log.Printf("â„¹ï¸  Telegram bot is now a messenger only (signals generated by Live Signal Handler)")
	log.Printf("â„¹ï¸  Current filter settings: filterBuy=%v, filterSell=%v", currentFilterBuy, currentFilterSell)
	
	return nil
}

// StopTelegramSignalBot disables Telegram notifications
func StopTelegramSignalBot() {
	if telegramBot != nil && telegramBot.Running {
		telegramBot.Running = false
		telegramBot.SendMessage("ğŸ›‘ *Trading Signal Bot Stopped*\n\n_Telegram notifications disabled_")
		log.Println("ğŸ¤– Telegram bot stopped - notifications disabled")
	}
}

// SendSignal sends a trading signal to Telegram (only if bot is running)
func (bot *TelegramBot) SendSignal(signal LiveSignalResponse, symbol, strategy string) {
	// Check if bot is running (notifications enabled)
	if !bot.Running {
		log.Printf("â„¹ï¸  Telegram notifications disabled, not sending %s signal", signal.Signal)
		return
	}
	
	var emoji string
	var signalType string
	
	if signal.Signal == "BUY" {
		emoji = "ğŸŸ¢"
		signalType = "BUY SIGNAL"
	} else {
		emoji = "ğŸ”´"
		signalType = "SELL SIGNAL"
	}
	
	message := fmt.Sprintf(
		"%s *%s*\n\n"+
			"ğŸ“Š *Symbol:* `%s`\n"+
			"ğŸ¯ *Strategy:* `%s`\n"+
			"ğŸ’° *Current Price:* `$%.2f`\n\n"+
			"ğŸ“ *Entry:* `$%.2f`\n"+
			"ğŸ›‘ *Stop Loss:* `$%.2f`\n\n"+
			"ğŸ¯ *Take Profit Levels:*\n"+
			"   TP1 (33%%): `$%.2f`\n"+
			"   TP2 (33%%): `$%.2f`\n"+
			"   TP3 (34%%): `$%.2f`\n\n"+
			"ğŸ“Š *Risk/Reward:* `%.2f:1`\n"+
			"â° *Time:* `%s`\n\n"+
			"_Automated signal from Trading Bot_",
		emoji, signalType,
		symbol,
		strategy,
		signal.CurrentPrice,
		signal.Entry,
		signal.StopLoss,
		signal.TP1,
		signal.TP2,
		signal.TP3,
		signal.RiskReward,
		time.Now().Format("2006-01-02 15:04:05 MST"),
	)
	
	bot.SendMessage(message)
	log.Printf("ğŸ“¤ Sent %s signal to Telegram for %s", signal.Signal, symbol)
}

// SendMessage sends a message to Telegram
func (bot *TelegramBot) SendMessage(text string) error {
	url := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", bot.Token)
	
	log.Printf("ğŸ” Sending to Telegram - ChatID: %s", bot.ChatID)
	
	msg := TelegramMessage{
		ChatID:    bot.ChatID,
		Text:      text,
		ParseMode: "Markdown",
	}
	
	jsonData, err := json.Marshal(msg)
	if err != nil {
		log.Printf("âŒ Failed to marshal Telegram message: %v", err)
		return err
	}
	
	resp, err := http.Post(url, "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		log.Printf("âŒ Failed to send to Telegram API: %v", err)
		return err
	}
	defer resp.Body.Close()
	
	log.Printf("ğŸ” Telegram API response status: %d", resp.StatusCode)
	
	if resp.StatusCode != http.StatusOK {
		// Read error response
		var responseBody bytes.Buffer
		responseBody.ReadFrom(resp.Body)
		log.Printf("âŒ Telegram API error (status %d): %s", resp.StatusCode, responseBody.String())
		return fmt.Errorf("telegram API returned status %d: %s", resp.StatusCode, responseBody.String())
	}
	
	log.Printf("âœ… Message sent to Telegram successfully")
	return nil
}

// GetTelegramBotStatus returns the current bot status
func GetTelegramBotStatus() map[string]interface{} {
	if telegramBot == nil {
		return map[string]interface{}{
			"configured": false,
			"running":    false,
			"message":    "Telegram bot not configured",
		}
	}
	
	return map[string]interface{}{
		"configured": true,
		"running":    telegramBot.Running,
		"message":    "Telegram bot ready",
	}
}
