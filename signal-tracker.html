<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal Tracker - Trading Signals</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #131722;
            color: #d1d4dc;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Loading Animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #131722;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #2a2e39;
            border-top: 4px solid #26a69a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 20px;
            color: #787b86;
            font-size: 14px;
        }
        .success-checkmark {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            display: none;
        }
        .success-checkmark.show {
            display: block;
        }
        .check-icon {
            width: 80px;
            height: 80px;
            position: relative;
            border-radius: 50%;
            box-sizing: content-box;
            border: 4px solid #26a69a;
        }
        .check-icon::before {
            top: 3px;
            left: -2px;
            width: 30px;
            transform-origin: 100% 50%;
            border-radius: 100px 0 0 100px;
        }
        .check-icon::after {
            top: 0;
            left: 30px;
            width: 60px;
            transform-origin: 0 50%;
            border-radius: 0 100px 100px 0;
            animation: rotate-circle 4.25s ease-in;
        }
        .icon-line {
            height: 5px;
            background-color: #26a69a;
            display: block;
            border-radius: 2px;
            position: absolute;
            z-index: 10;
        }
        .icon-line.line-tip {
            top: 46px;
            left: 14px;
            width: 25px;
            transform: rotate(45deg);
            animation: icon-line-tip 0.75s;
        }
        .icon-line.line-long {
            top: 38px;
            right: 8px;
            width: 47px;
            transform: rotate(-45deg);
            animation: icon-line-long 0.75s;
        }
        @keyframes icon-line-tip {
            0% { width: 0; left: 1px; top: 19px; }
            54% { width: 0; left: 1px; top: 19px; }
            70% { width: 50px; left: -8px; top: 37px; }
            84% { width: 17px; left: 21px; top: 48px; }
            100% { width: 25px; left: 14px; top: 46px; }
        }
        @keyframes icon-line-long {
            0% { width: 0; right: 46px; top: 54px; }
            65% { width: 0; right: 46px; top: 54px; }
            84% { width: 55px; right: 0px; top: 35px; }
            100% { width: 47px; right: 8px; top: 38px; }
        }
        h1 {
            color: #26a69a;
            margin-bottom: 20px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #1e222d;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        .stat-value.profit {
            color: #26a69a;
        }
        .stat-value.loss {
            color: #ef5350;
        }
        .stat-label {
            color: #787b86;
            font-size: 12px;
            text-transform: uppercase;
        }
        .controls {
            background: #1e222d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            background: #26a69a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #2bbbad;
        }
        button.secondary {
            background: #2962ff;
        }
        button.secondary:hover {
            background: #1e53e5;
        }
        button.refresh-btn {
            background: #26a69a;
            position: relative;
            transition: all 0.3s ease;
        }
        button.refresh-btn:hover {
            background: #2bbbad;
            transform: scale(1.05);
        }
        button.refresh-btn.spinning {
            pointer-events: none;
            opacity: 0.7;
        }
        button.refresh-btn.spinning::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin-refresh {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        select {
            background: #2a2e39;
            color: #d1d4dc;
            border: 1px solid #434651;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .table-container {
            background: #1e222d;
            border-radius: 8px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2a2e39;
        }
        th {
            background: #2a2e39;
            color: #787b86;
            font-weight: normal;
            font-size: 12px;
            text-transform: uppercase;
            position: sticky;
            top: 0;
        }
        tr {
            transition: background-color 0.2s ease;
        }
        tr:hover {
            background: #2a2e39;
        }
        td {
            transition: color 0.3s ease, background-color 0.3s ease;
        }
        .win {
            color: #26a69a;
            font-weight: bold;
        }
        .loss {
            color: #ef5350;
            font-weight: bold;
        }
        .pending {
            color: #f7931a;
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }
        .badge.buy {
            background: rgba(38, 166, 154, 0.2);
            color: #26a69a;
        }
        .badge.sell {
            background: rgba(239, 83, 80, 0.2);
            color: #ef5350;
        }
        .action-btn {
            background: #2962ff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .action-btn:hover {
            background: #1e53e5;
        }
        .action-btn.win {
            background: #26a69a;
        }
        .action-btn.loss {
            background: #ef5350;
        }
        .remove-btn {
            background: transparent;
            color: #ef5350;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.2s ease;
        }
        .remove-btn:hover {
            color: #ff6b6b;
            transform: scale(1.3);
        }
        
        /* Session Indicator */
        .session-indicator {
            background: #1e222d;
            padding: 15px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-left: 4px solid #26a69a;
        }
        .session-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .session-badge {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 6px;
            font-weight: bold;
            font-size: 14px;
        }
        .session-badge.asian {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
        }
        .session-badge.london {
            background: rgba(33, 150, 243, 0.2);
            color: #2196f3;
        }
        .session-badge.newyork {
            background: rgba(76, 175, 80, 0.2);
            color: #4caf50;
        }
        .session-badge.overlap {
            background: rgba(156, 39, 176, 0.2);
            color: #9c27b0;
        }
        .session-pulse {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        .session-badge.asian .session-pulse {
            background: #ffc107;
        }
        .session-badge.london .session-pulse {
            background: #2196f3;
        }
        .session-badge.newyork .session-pulse {
            background: #4caf50;
        }
        .session-badge.overlap .session-pulse {
            background: #9c27b0;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }
        .session-time {
            color: #787b86;
            font-size: 13px;
        }
        .session-details {
            display: flex;
            gap: 20px;
            color: #787b86;
            font-size: 12px;
        }
        .session-detail {
            display: flex;
            align-items: center;
            gap: 5px;
        }
    </style>
    
    <!-- Supabase Integration -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner" id="spinner"></div>
        <div class="success-checkmark" id="successCheckmark">
            <div class="check-icon">
                <span class="icon-line line-tip"></span>
                <span class="icon-line line-long"></span>
            </div>
        </div>
        <div class="loading-text" id="loadingText">Loading signals...</div>
    </div>

    <div class="container">
        <h1 style="margin-bottom: 20px;">üìä Signal Tracker</h1>
        
        <!-- Session Indicator -->
        <div class="session-indicator">
            <div class="session-info">
                <span class="session-badge" id="sessionBadge">
                    <span class="session-pulse"></span>
                    <span id="sessionName">Loading...</span>
                </span>
                <span class="session-time" id="sessionTime">--:-- UTC</span>
            </div>
            <div class="session-details">
                <div class="session-detail">
                    <span>üî• Asian Kill Zone (05:30-10:15 AM IST): <span id="asianKZ">--:--:--</span></span>
                </div>
                <div class="session-detail">
                    <span>üî• London Kill Zone (05:30-09:30 PM IST): <span id="londonKZ">--:--:--</span></span>
                </div>
                <div class="session-detail">
                    <span>üî• New York Kill Zone (11:30 AM-03:15 PM IST): <span id="nyKZ">--:--:--</span></span>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Total Signals</div>
                <div class="stat-value" id="total-signals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Winning Trades</div>
                <div class="stat-value profit" id="win-count">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Losing Trades</div>
                <div class="stat-value loss" id="loss-count">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Win Rate</div>
                <div class="stat-value" id="win-rate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Profit Factor</div>
                <div class="stat-value" id="profit-factor">0.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Win</div>
                <div class="stat-value profit" id="avg-win">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Loss</div>
                <div class="stat-value loss" id="avg-loss">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Best Trade</div>
                <div class="stat-value profit" id="best-trade">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Worst Trade</div>
                <div class="stat-value loss" id="worst-trade">0%</div>
            </div>
        </div>
        
        <!-- Timeframe Performance Breakdown -->
        <div id="tf-stats" style="background: #1e222d; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h3 style="color: #26a69a; margin-bottom: 15px; font-size: 14px;">üìä Performance by Timeframe</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px;" id="tf-breakdown">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>
        
        <!-- R:R Performance Breakdown -->
        <div id="rr-stats" style="background: #1e222d; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h3 style="color: #f7931a; margin-bottom: 15px; font-size: 14px;">üéØ Performance by Risk:Reward</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;" id="rr-breakdown">
                <!-- Will be populated by JavaScript -->
            </div>
        </div>

        <div class="controls">
            <button id="refreshBtn" class="refresh-btn" onclick="manualRefresh()">üîÑ Refresh</button>
            <button class="secondary" onclick="checkAllSignalResults()" style="background: #a855f7;">üéØ Check Results</button>
            <button class="secondary" onclick="fetch1mSignals()" style="background: #ff6b6b;">‚ö° Fetch 1m Signals</button>
            <button class="secondary" onclick="exportToCSV()">üì• Export CSV</button>
            <button class="secondary" onclick="showChart()">üìä Chart</button>
            <button class="secondary" onclick="showStats()">üìà Statistics</button>
            <button class="secondary" onclick="clearAllSignals()">üóëÔ∏è Clear Supabase</button>
            <button class="secondary" onclick="clearLocalStorage()" style="background: #ff6b6b;">üßπ Clear Browser</button>
            <select id="filter" onchange="filterSignals()">
                <option value="all">All Signals</option>
                <option value="win">Wins Only</option>
                <option value="loss">Losses Only</option>
                <option value="pending">Pending Only</option>
                <option value="buy">BUY Only</option>
                <option value="sell">SELL Only</option>
                <option value="tp1">TP1 Exits</option>
                <option value="tp2">TP2 Exits</option>
                <option value="tp3">TP3 Exits</option>
                <option value="trailing">Trailing Stop Exits</option>
            </select>
            <select id="tf-filter" onchange="filterSignals()" style="padding: 8px; background: #1e222d; color: #d1d4dc; border: 1px solid #363a45; border-radius: 4px;">
                <option value="all">All Timeframes</option>
                <option value="1m">üî¥ 1m (Scalping)</option>
                <option value="3m">üü† 3m (Fast)</option>
                <option value="5m">üü° 5m</option>
                <option value="15m">üîµ 15m (Day)</option>
                <option value="1h">üü£ 1h (Swing)</option>
                <option value="2h">üî¥ 2h (Best)</option>
                <option value="4h">üü¢ 4h (Position)</option>
            </select>
            <select id="rr-filter" onchange="filterSignals()" style="padding: 8px; background: #1e222d; color: #d1d4dc; border: 1px solid #363a45; border-radius: 4px;">
                <option value="all">All R:R</option>
                <option value="3+">R:R ‚â• 3:1 (Excellent)</option>
                <option value="2+">R:R ‚â• 2:1 (Good)</option>
                <option value="1.5+">R:R ‚â• 1.5:1 (Acceptable)</option>
            </select>
            <select id="quality-filter" onchange="filterSignals()" style="padding: 8px; background: #1e222d; color: #d1d4dc; border: 1px solid #363a45; border-radius: 4px;">
                <option value="all">All Quality</option>
                <option value="high">üî• High (‚â•80%)</option>
                <option value="medium">‚≠ê Medium (60-79%)</option>
                <option value="low">‚ö†Ô∏è Low (<60%)</option>
            </select>
            <input type="date" id="date-from" onchange="filterSignals()" style="padding: 8px;">
            <input type="date" id="date-to" onchange="filterSignals()" style="padding: 8px;">
        </div>
        
        <!-- 1m Signal Stats -->
        <div id="scalping-stats" style="background: linear-gradient(135deg, #1a0a0a 0%, #2d1010 100%); border: 1px solid #ff6b6b; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
            <h3 style="color: #ff6b6b; margin-bottom: 10px; font-size: 14px;">‚ö° 1-Minute Scalping Performance</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); gap: 10px;" id="scalping-breakdown">
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">TOTAL 1M</div>
                    <div id="scalp-total" style="color: #ff6b6b; font-size: 20px; font-weight: bold;">0</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">WIN RATE</div>
                    <div id="scalp-winrate" style="color: #26a69a; font-size: 20px; font-weight: bold;">0%</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">AVG R:R</div>
                    <div id="scalp-avgrr" style="color: #f7931a; font-size: 20px; font-weight: bold;">0:1</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">PENDING</div>
                    <div id="scalp-pending" style="color: #58a6ff; font-size: 20px; font-weight: bold;">0</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #787b86; font-size: 10px;">LAST SIGNAL</div>
                    <div id="scalp-last" style="color: #d1d4dc; font-size: 12px; font-weight: bold;">-</div>
                </div>
            </div>
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Date/Time</th>
                        <th>TF</th>
                        <th>Type</th>
                        <th>Symbol</th>
                        <th>Entry</th>
                        <th>Exit</th>
                        <th>Stop Loss</th>
                        <th>R:R</th>
                        <th>TP1</th>
                        <th>TP2</th>
                        <th>TP3</th>
                        <th>Strength</th>
                        <th>Confluence</th>
                        <th>Status</th>
                        <th>Result</th>
                        <th>Actions</th>
                    </tr>
                </thead>
                <tbody id="signals-table">
                    <tr>
                        <td colspan="17" style="text-align: center; color: #787b86; padding: 40px;">
                            No signals yet. Signals will appear here when sent to Telegram.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Fast loading with optimization
        let signals = [];
        let isLoading = true;
        
        // Session detection
        function getCurrentSession() {
            const now = new Date();
            
            // Get system UTC time for session detection
            const utcHour = now.getUTCHours();
            
            // Get local system time for display
            let localHour = now.getHours();
            const localMinute = now.getMinutes();
            const localSecond = now.getSeconds();
            
            // Convert to 12-hour format
            const ampm = localHour >= 12 ? 'PM' : 'AM';
            const displayHour = localHour % 12 || 12; // Convert 0 to 12 for midnight
            
            // Get timezone offset
            const timezoneOffset = -now.getTimezoneOffset() / 60;
            const timezoneString = timezoneOffset >= 0 ? `UTC+${timezoneOffset}` : `UTC${timezoneOffset}`;
            
            // Format: HH:MM:SS AM/PM (Timezone)
            const timeString = `${String(displayHour).padStart(2, '0')}:${String(localMinute).padStart(2, '0')}:${String(localSecond).padStart(2, '0')} ${ampm} (${timezoneString})`;
            
            let session = '';
            let sessionClass = '';
            
            // Asian: 00:00-09:00 UTC
            const isAsian = utcHour >= 0 && utcHour < 9;
            // London: 08:00-17:00 UTC
            const isLondon = utcHour >= 8 && utcHour < 17;
            // New York: 13:00-22:00 UTC
            const isNewYork = utcHour >= 13 && utcHour < 22;
            
            // Check for overlaps
            if (isLondon && isNewYork) {
                session = 'üåçüåé London-NY Overlap';
                sessionClass = 'overlap';
            } else if (isAsian && isLondon) {
                session = 'üåèüåç Asian-London Overlap';
                sessionClass = 'overlap';
            } else if (isAsian) {
                session = 'üåè Asian Session';
                sessionClass = 'asian';
            } else if (isLondon) {
                session = 'üåç London Session';
                sessionClass = 'london';
            } else if (isNewYork) {
                session = 'üåé New York Session';
                sessionClass = 'newyork';
            } else {
                session = 'üåô Off-Hours';
                sessionClass = 'asian';
            }
            
            return { session, sessionClass, timeString };
        }
        
        function getNextSessionTime(sessionStartHour) {
            const now = new Date();
            const utcHour = now.getUTCHours();
            
            let hoursUntil = sessionStartHour - utcHour;
            if (hoursUntil <= 0) {
                hoursUntil += 24; // Next day
            }
            
            const minutesUntil = 60 - now.getUTCMinutes();
            const secondsUntil = 60 - now.getUTCSeconds();
            
            let totalSeconds = (hoursUntil * 3600) + (minutesUntil * 60) + secondsUntil - 3600;
            
            if (totalSeconds < 0) totalSeconds += 86400;
            
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            
            return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        
        function updateSessionIndicator() {
            const { session, sessionClass, timeString } = getCurrentSession();
            const badge = document.getElementById('sessionBadge');
            const name = document.getElementById('sessionName');
            const time = document.getElementById('sessionTime');
            
            if (badge && name && time) {
                badge.className = `session-badge ${sessionClass}`;
                name.textContent = session;
                time.textContent = timeString;
            }
            
            // Update kill zone countdowns
            const now = new Date();
            const utcHour = now.getUTCHours();
            
            // Asian Kill Zone (00:00-04:45 UTC / 5:30-10:15 AM IST)
            const asianKZEl = document.getElementById('asianKZ');
            const utcMinute = now.getUTCMinutes();
            const isAsianActive = (utcHour >= 0 && utcHour < 4) || (utcHour === 4 && utcMinute < 45);
            
            if (isAsianActive) {
                asianKZEl.textContent = 'üü¢ ACTIVE NOW!';
                asianKZEl.style.color = '#ff6b6b';
                asianKZEl.style.fontWeight = 'bold';
            } else {
                asianKZEl.textContent = getNextSessionTime(0);
                asianKZEl.style.color = '#ffc107';
                asianKZEl.style.fontWeight = 'normal';
            }
            
            // London Kill Zone (12:00-16:00 UTC / 5:30-9:30 PM IST)
            const londonKZEl = document.getElementById('londonKZ');
            const isLondonActive = utcHour >= 12 && utcHour < 16;
            
            if (isLondonActive) {
                londonKZEl.textContent = 'üü¢ ACTIVE NOW!';
                londonKZEl.style.color = '#ff6b6b';
                londonKZEl.style.fontWeight = 'bold';
            } else {
                londonKZEl.textContent = getNextSessionTime(12);
                londonKZEl.style.color = '#2196f3';
                londonKZEl.style.fontWeight = 'normal';
            }
            
            // New York Kill Zone (06:00-09:45 UTC / 11:30 AM - 3:15 PM IST)
            const nyKZEl = document.getElementById('nyKZ');
            const isNYActive = (utcHour >= 6 && utcHour < 9) || (utcHour === 9 && utcMinute < 45);
            
            if (isNYActive) {
                nyKZEl.textContent = 'üü¢ ACTIVE NOW!';
                nyKZEl.style.color = '#ff6b6b';
                nyKZEl.style.fontWeight = 'bold';
            } else {
                nyKZEl.textContent = getNextSessionTime(6);
                nyKZEl.style.color = '#4caf50';
                nyKZEl.style.fontWeight = 'normal';
            }
        }
        
        // Load signals asynchronously
        async function loadSignals() {
            try {
                // Try loading from Supabase first
                if (typeof SupabaseDB !== 'undefined') {
                    try {
                        const supabaseSignals = await SupabaseDB.getAllSignals();
                        if (supabaseSignals && supabaseSignals.length > 0) {
                            // Convert Supabase format to local format
                            signals = supabaseSignals.map(s => ({
                                id: parseFloat(s.signal_id),
                                timestamp: new Date(s.created_at).getTime(),
                                type: s.signal_type,
                                symbol: s.symbol,
                                entry: s.entry_price,
                                stopLoss: s.stop_loss,
                                tp1: s.tp1,
                                tp2: s.tp2,
                                tp3: s.tp3,
                                strength: s.strength,
                                status: s.status,
                                exitPrice: s.exit_price,
                                exitReason: s.exit_reason,
                                trailingStopPrice: s.trailing_stop_price,
                                trailingStopActive: s.trailing_stop_active,
                                livePrice: s.live_price,
                                timeframe: s.timeframe || '15m'  // Add timeframe field
                            }));
                            console.log(`‚òÅÔ∏è Loaded ${signals.length} signals from Supabase`);
                            return;
                        }
                    } catch (error) {
                        console.warn('Supabase load failed:', error);
                        // Don't fall back to localStorage - only use Supabase
                        console.log('‚ö†Ô∏è No Supabase connection - showing empty signals');
                        signals = [];
                        return;
                    }
                }
                
                // No localStorage fallback - signals only from Supabase
                // Clear any old localStorage data
                localStorage.removeItem('tradingSignals');
                signals = [];
                console.log('üìä No signals loaded (Supabase only mode)');
            } catch (error) {
                console.error('Error loading signals:', error);
                signals = [];
            }
        }

        // Display signals
        function displaySignals(filter = 'all') {
            filterSignals();
        }

        // Update statistics
        function updateStats() {
            const total = signals.length;
            const wins = signals.filter(s => s.status === 'win').length;
            const losses = signals.filter(s => s.status === 'loss').length;
            const pending = signals.filter(s => s.status === 'pending').length;
            const closedTrades = wins + losses;
            
            // Fix NaN issue - only calculate win rate if there are closed trades
            const winRate = closedTrades > 0 ? ((wins / closedTrades) * 100).toFixed(1) : '0';
            
            // Calculate profit/loss percentages
            const winTrades = signals.filter(s => s.status === 'win' && s.exitPrice);
            const lossTrades = signals.filter(s => s.status === 'loss' && s.exitPrice);
            
            let totalWinPercent = 0;
            let totalLossPercent = 0;
            let bestTrade = 0;
            let worstTrade = 0;
            
            winTrades.forEach(s => {
                const profit = s.type === 'BUY' 
                    ? ((s.exitPrice - s.entry) / s.entry) * 100
                    : ((s.entry - s.exitPrice) / s.entry) * 100;
                totalWinPercent += profit;
                if (profit > bestTrade) bestTrade = profit;
            });
            
            lossTrades.forEach(s => {
                const loss = s.type === 'BUY' 
                    ? ((s.exitPrice - s.entry) / s.entry) * 100
                    : ((s.entry - s.exitPrice) / s.entry) * 100;
                totalLossPercent += Math.abs(loss);
                if (loss < worstTrade) worstTrade = loss;
            });
            
            const avgWin = winTrades.length > 0 ? (totalWinPercent / winTrades.length).toFixed(2) : '0';
            const avgLoss = lossTrades.length > 0 ? (totalLossPercent / lossTrades.length).toFixed(2) : '0';
            const profitFactor = totalLossPercent > 0 ? (totalWinPercent / totalLossPercent).toFixed(2) : '0.00';
            
            document.getElementById('total-signals').textContent = total;
            document.getElementById('win-count').textContent = wins;
            document.getElementById('loss-count').textContent = losses;
            document.getElementById('win-rate').textContent = winRate + '%';
            document.getElementById('profit-factor').textContent = profitFactor;
            document.getElementById('avg-win').textContent = '+' + avgWin + '%';
            document.getElementById('avg-loss').textContent = '-' + avgLoss + '%';
            document.getElementById('best-trade').textContent = '+' + bestTrade.toFixed(2) + '%';
            document.getElementById('worst-trade').textContent = worstTrade.toFixed(2) + '%';
            
            // Color code win rate
            const winRateEl = document.getElementById('win-rate');
            const winRateNum = parseFloat(winRate);
            if (winRateNum >= 60) winRateEl.style.color = '#26a69a';
            else if (winRateNum >= 50) winRateEl.style.color = '#f7931a';
            else if (winRateNum > 0) winRateEl.style.color = '#ef5350';
            else winRateEl.style.color = '#787b86';
            
            // Update timeframe breakdown
            updateTimeframeBreakdown();
            
            // Update R:R breakdown
            updateRRBreakdown();
            
            // Update scalping stats
            updateScalpingStats();
        }
        
        // Timeframe performance breakdown with progress bars and actual R:R
        function updateTimeframeBreakdown() {
            const tfBreakdown = document.getElementById('tf-breakdown');
            if (!tfBreakdown) return;
            
            const timeframes = ['1m', '3m', '5m', '15m', '1h', '2h', '4h'];
            const tfColors = {
                '1m': '#ff6b6b',
                '3m': '#ffa657',
                '5m': '#ffd93d',
                '15m': '#58a6ff',
                '1h': '#a371f7',
                '2h': '#f85149',
                '4h': '#3fb950'
            };
            
            let html = '';
            
            timeframes.forEach(tf => {
                const tfSignals = signals.filter(s => (s.timeframe || '15m') === tf);
                const tfWins = tfSignals.filter(s => s.status === 'win').length;
                const tfLosses = tfSignals.filter(s => s.status === 'loss').length;
                const tfPending = tfSignals.filter(s => s.status === 'pending').length;
                const tfTotal = tfWins + tfLosses;
                const tfWinRate = tfTotal > 0 ? ((tfWins / tfTotal) * 100).toFixed(0) : '-';
                
                const color = tfColors[tf] || '#787b86';
                const winRateColor = tfWinRate >= 60 ? '#26a69a' : tfWinRate >= 50 ? '#f7931a' : '#ef5350';
                const winRateNum = parseFloat(tfWinRate) || 0;
                
                // Calculate avg actual R:R for this timeframe
                let totalActualRR = 0;
                let actualRRCount = 0;
                tfSignals.filter(s => s.status === 'win' && s.exitPrice).forEach(s => {
                    const risk = Math.abs(s.entry - s.stopLoss);
                    const reward = Math.abs(s.exitPrice - s.entry);
                    if (risk > 0) {
                        totalActualRR += reward / risk;
                        actualRRCount++;
                    }
                });
                const avgActualRR = actualRRCount > 0 ? (totalActualRR / actualRRCount).toFixed(1) : '-';
                
                html += `
                    <div style="background: #2a2e39; padding: 10px; border-radius: 6px; text-align: center; border-left: 3px solid ${color};">
                        <div style="color: ${color}; font-weight: bold; font-size: 14px;">${tf.toUpperCase()}</div>
                        <div style="color: #d1d4dc; font-size: 12px; margin: 5px 0;">${tfSignals.length} signals</div>
                        <div style="color: ${winRateColor}; font-weight: bold; margin-bottom: 5px;">${tfWinRate}% WR</div>
                        <div style="width: 100%; height: 4px; background: #1e222d; border-radius: 2px; overflow: hidden; margin-bottom: 5px;">
                            <div style="width: ${winRateNum}%; height: 100%; background: ${winRateColor}; border-radius: 2px;"></div>
                        </div>
                        <div style="color: #787b86; font-size: 10px;">${tfWins}W / ${tfLosses}L / ${tfPending}P</div>
                        <div style="color: #58a6ff; font-size: 9px; margin-top: 3px;">Avg R:R: ${avgActualRR}:1</div>
                    </div>
                `;
            });
            
            tfBreakdown.innerHTML = html || '<div style="color: #787b86;">No data yet</div>';
        }
        
        // R:R performance breakdown - using ACTUAL R:R from exits
        function updateRRBreakdown() {
            const rrBreakdown = document.getElementById('rr-breakdown');
            if (!rrBreakdown) return;
            
            const rrRanges = [
                { label: 'R:R < 1.5', min: -999, max: 1.5, color: '#ef5350' },
                { label: '1.5 ‚â§ R:R < 2', min: 1.5, max: 2, color: '#f7931a' },
                { label: '2 ‚â§ R:R < 3', min: 2, max: 3, color: '#4caf50' },
                { label: 'R:R ‚â• 3', min: 3, max: 999, color: '#26a69a' }
            ];
            
            let html = '';
            
            rrRanges.forEach(range => {
                const rangeSignals = signals.filter(s => {
                    let rr = 0;
                    const risk = Math.abs(s.entry - s.stopLoss);
                    
                    if (s.status === 'win' && s.exitPrice) {
                        // Use ACTUAL exit price for realized R:R
                        const actualReward = Math.abs(s.exitPrice - s.entry);
                        rr = risk > 0 ? actualReward / risk : 0;
                    } else if (s.status === 'loss') {
                        rr = -1; // Loss is always -1 R:R
                    } else {
                        // For pending, use potential R:R (TP2 as realistic target)
                        const potentialReward = Math.abs(s.tp2 - s.entry);
                        rr = risk > 0 ? potentialReward / risk : 0;
                    }
                    
                    return rr >= range.min && rr < range.max;
                });
                
                const rangeWins = rangeSignals.filter(s => s.status === 'win').length;
                const rangeLosses = rangeSignals.filter(s => s.status === 'loss').length;
                const rangeTotal = rangeWins + rangeLosses;
                const rangeWinRate = rangeTotal > 0 ? ((rangeWins / rangeTotal) * 100).toFixed(0) : '-';
                
                const winRateColor = rangeWinRate >= 60 ? '#26a69a' : rangeWinRate >= 50 ? '#f7931a' : '#ef5350';
                const winRateNum = parseFloat(rangeWinRate) || 0;
                
                // Calculate avg actual R:R for this range
                let totalActualRR = 0;
                let actualRRCount = 0;
                rangeSignals.filter(s => s.status === 'win' && s.exitPrice).forEach(s => {
                    const risk = Math.abs(s.entry - s.stopLoss);
                    const reward = Math.abs(s.exitPrice - s.entry);
                    if (risk > 0) {
                        totalActualRR += reward / risk;
                        actualRRCount++;
                    }
                });
                const avgActualRR = actualRRCount > 0 ? (totalActualRR / actualRRCount).toFixed(1) : '-';
                
                html += `
                    <div style="background: #2a2e39; padding: 10px; border-radius: 6px; text-align: center; border-left: 3px solid ${range.color};">
                        <div style="color: ${range.color}; font-weight: bold; font-size: 12px;">${range.label}</div>
                        <div style="color: #d1d4dc; font-size: 12px; margin: 5px 0;">${rangeSignals.length} signals</div>
                        <div style="color: ${winRateColor}; font-weight: bold; margin-bottom: 5px;">${rangeWinRate}% WR</div>
                        <div style="width: 100%; height: 4px; background: #1e222d; border-radius: 2px; overflow: hidden; margin-bottom: 5px;">
                            <div style="width: ${winRateNum}%; height: 100%; background: ${winRateColor}; border-radius: 2px;"></div>
                        </div>
                        <div style="color: #787b86; font-size: 10px;">${rangeWins}W / ${rangeLosses}L</div>
                        <div style="color: #58a6ff; font-size: 9px; margin-top: 3px;">Avg: ${avgActualRR}:1</div>
                    </div>
                `;
            });
            
            rrBreakdown.innerHTML = html || '<div style="color: #787b86;">No data yet</div>';
        }

        // Save signals to localStorage
        function saveSignals() {
            localStorage.setItem('tradingSignals', JSON.stringify(signals));
        }

        // Debounce filter to prevent excessive updates
        let filterTimeout;
        let isFiltering = false;
        
        // Filter signals with optimized debouncing
        function filterSignals() {
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => {
                if (!isFiltering) {
                    isFiltering = true;
                    requestAnimationFrame(() => {
                        filterSignalsNow();
                        isFiltering = false;
                    });
                }
            }, 100);
        }
        
        function filterSignalsNow() {
            const filter = document.getElementById('filter').value;
            const dateFrom = document.getElementById('date-from').value;
            const dateTo = document.getElementById('date-to').value;
            const tfFilter = document.getElementById('tf-filter')?.value || 'all';
            const rrFilter = document.getElementById('rr-filter')?.value || 'all';
            
            let filtered = signals;
            
            // Filter by type/status
            if (filter === 'win') {
                filtered = filtered.filter(s => s.status === 'win');
            } else if (filter === 'loss') {
                filtered = filtered.filter(s => s.status === 'loss');
            } else if (filter === 'pending') {
                filtered = filtered.filter(s => s.status === 'pending');
            } else if (filter === 'buy') {
                filtered = filtered.filter(s => s.type === 'BUY');
            } else if (filter === 'sell') {
                filtered = filtered.filter(s => s.type === 'SELL');
            } else if (filter === 'tp1') {
                filtered = filtered.filter(s => s.exitReason === 'TP1');
            } else if (filter === 'tp2') {
                filtered = filtered.filter(s => s.exitReason === 'TP2');
            } else if (filter === 'tp3') {
                filtered = filtered.filter(s => s.exitReason === 'TP3');
            } else if (filter === 'trailing') {
                filtered = filtered.filter(s => s.exitReason === 'Trailing Stop');
            }
            
            // Filter by timeframe
            if (tfFilter !== 'all') {
                filtered = filtered.filter(s => (s.timeframe || '15m') === tfFilter);
            }
            
            // Filter by R:R ratio
            if (rrFilter !== 'all') {
                filtered = filtered.filter(s => {
                    const risk = Math.abs(s.entry - s.stopLoss);
                    const reward = Math.abs(s.tp3 - s.entry);
                    const rr = risk > 0 ? reward / risk : 0;
                    
                    if (rrFilter === '3+') return rr >= 3;
                    if (rrFilter === '2+') return rr >= 2;
                    if (rrFilter === '1.5+') return rr >= 1.5;
                    return true;
                });
            }
            
            // Filter by quality (strength)
            const qualityFilter = document.getElementById('quality-filter')?.value || 'all';
            if (qualityFilter !== 'all') {
                filtered = filtered.filter(s => {
                    const strength = s.strength || 0;
                    if (qualityFilter === 'high') return strength >= 80;
                    if (qualityFilter === 'medium') return strength >= 60 && strength < 80;
                    if (qualityFilter === 'low') return strength < 60;
                    return true;
                });
            }
            
            // Filter by date range
            if (dateFrom) {
                const fromTime = new Date(dateFrom).getTime();
                filtered = filtered.filter(s => s.timestamp >= fromTime);
            }
            if (dateTo) {
                const toTime = new Date(dateTo).getTime() + 86400000; // Add 1 day
                filtered = filtered.filter(s => s.timestamp < toTime);
            }
            
            displayFilteredSignals(filtered);
        }
        
        function displayFilteredSignals(filteredSignals) {
            const tbody = document.getElementById('signals-table');
            
            if (!tbody) {
                console.error('Table body element not found!');
                return;
            }
            
            if (filteredSignals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="16" style="text-align: center; color: #787b86; padding: 40px;">No signals found.</td></tr>';
                return;
            }
            
            // Display all signals (no limit)
            const signalsToDisplay = filteredSignals;
            
            console.log(`Displaying ${signalsToDisplay.length} signals`);
            
            try {
                const rowsHTML = signalsToDisplay.map((signal) => {
                const statusClass = signal.status === 'win' ? 'win' : signal.status === 'loss' ? 'loss' : 'pending';
                const statusText = signal.status === 'win' ? '‚úÖ WIN' : signal.status === 'loss' ? '‚ùå LOSS' : '‚è≥ PENDING';
                
                const profitPercent = signal.exitPrice ? (
                    signal.type === 'BUY' 
                        ? ((signal.exitPrice - signal.entry) / signal.entry) * 100
                        : ((signal.entry - signal.exitPrice) / signal.entry) * 100
                ) : 0;
                
                // For pending signals, show live progress with heatmap colors
                let statusDisplay = '';
                let progressDisplay = '';
                let resultDisplay = '';
                
                if (signal.status === 'pending' && signal.livePrice) {
                    const currentProfit = signal.type === 'BUY'
                        ? ((signal.livePrice - signal.entry) / signal.entry) * 100
                        : ((signal.entry - signal.livePrice) / signal.entry) * 100;
                    
                    // Status shows live price and P/L
                    const profitColor = currentProfit > 0 ? '#26a69a' : '#ef5350';
                    statusDisplay = `
                        <small>Live: ${signal.livePrice.toFixed(2)}</small><br>
                        <small style="color: ${profitColor}; font-weight: bold;">${currentProfit > 0 ? '+' : ''}${currentProfit.toFixed(2)}%</small>
                    `;
                    
                    // Determine which target we're approaching and set color
                    let progressColor = '#ef5350'; // Red (below entry)
                    let targetText = 'Entry';
                    let progressPercent = 0;
                    let targetsHit = [];
                    
                    if (signal.type === 'BUY') {
                        if (signal.livePrice >= signal.tp3) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì', 'TP3 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            progressPercent = 100;
                        } else if (signal.livePrice >= signal.tp2) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            const totalDistance = signal.tp3 - signal.tp2;
                            const currentDistance = signal.livePrice - signal.tp2;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice >= signal.tp1) {
                            targetsHit = ['TP1 ‚úì'];
                            progressColor = '#26a69a';
                            targetText = 'TP2';
                            const totalDistance = signal.tp2 - signal.tp1;
                            const currentDistance = signal.livePrice - signal.tp1;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice >= signal.entry) {
                            progressColor = '#4caf50';
                            targetText = 'TP1';
                            const totalDistance = signal.tp1 - signal.entry;
                            const currentDistance = signal.livePrice - signal.entry;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else {
                            progressColor = '#ef5350';
                            targetText = 'Entry';
                            progressPercent = 0;
                        }
                    } else { // SELL
                        if (signal.livePrice <= signal.tp3) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì', 'TP3 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            progressPercent = 100;
                        } else if (signal.livePrice <= signal.tp2) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            const totalDistance = signal.tp2 - signal.tp3;
                            const currentDistance = signal.tp2 - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice <= signal.tp1) {
                            targetsHit = ['TP1 ‚úì'];
                            progressColor = '#26a69a';
                            targetText = 'TP2';
                            const totalDistance = signal.tp1 - signal.tp2;
                            const currentDistance = signal.tp1 - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice <= signal.entry) {
                            progressColor = '#4caf50';
                            targetText = 'TP1';
                            const totalDistance = signal.entry - signal.tp1;
                            const currentDistance = signal.entry - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else {
                            progressColor = '#ef5350';
                            targetText = 'Entry';
                            progressPercent = 0;
                        }
                    }
                    
                    progressPercent = Math.max(0, Math.min(100, progressPercent));
                    
                    progressDisplay = `
                        <div style="background: #2a2e39; border-radius: 4px; height: 10px; overflow: hidden; margin: 5px 0; border: 1px solid ${progressColor};">
                            <div style="background: ${progressColor}; height: 100%; width: ${progressPercent.toFixed(0)}%; transition: all 0.3s ease;"></div>
                        </div>
                        <small style="color: ${progressColor};">${progressPercent.toFixed(1)}% to ${targetText}</small><br>
                        <small>ETA: ${signal.timeEstimate || '-'}</small>
                    `;
                    
                    // Result shows which targets hit
                    if (targetsHit.length > 0) {
                        resultDisplay = targetsHit.map(t => `<span style="color: #26a69a;">${t}</span>`).join('<br>');
                    } else {
                        resultDisplay = '-';
                    }
                } else if (signal.exitPrice) {
                    statusDisplay = statusText;
                    progressDisplay = '-';
                    
                    // Show exit reason with icon
                    let exitIcon = '';
                    if (signal.exitReason === 'TP1') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #26a69a;">${exitIcon} TP1 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'TP2') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #26a69a;">${exitIcon} TP2 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'TP3') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #ff9800;">${exitIcon} TP3 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'Trailing Stop') {
                        exitIcon = 'üîí';
                        resultDisplay = `<span style="color: #f7931a;">${exitIcon} Trailing Stop</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'Stop Loss') {
                        exitIcon = 'üõë';
                        resultDisplay = `<span style="color: #ef5350;">${exitIcon} Stop Loss</span><br><small>${profitPercent.toFixed(2)}%</small>`;
                    } else {
                        resultDisplay = `${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%`;
                    }
                } else {
                    statusDisplay = statusText;
                    progressDisplay = '-';
                    resultDisplay = '-';
                }
                
                // Trailing stop display - show calculated or saved value
                let trailingStopDisplay = '-';
                if (signal.status === 'pending') {
                    // Calculate trailing stop on the fly if we have live price
                    let calculatedTS = signal.calculatedTrailingStop || signal.trailingStopPrice;
                    
                    // If no saved trailing stop, calculate it now based on live price
                    if (!calculatedTS && signal.livePrice) {
                        if (signal.type === 'BUY' && signal.livePrice >= signal.tp1) {
                            const profitDistance = signal.livePrice - signal.entry;
                            calculatedTS = signal.entry + (profitDistance * 0.5);
                        } else if (signal.type === 'SELL' && signal.livePrice <= signal.tp1) {
                            const profitDistance = signal.entry - signal.livePrice;
                            calculatedTS = signal.entry - (profitDistance * 0.5);
                        }
                    }
                    
                    if (calculatedTS) {
                        trailingStopDisplay = `<span style="color: #f7931a;">${calculatedTS.toFixed(2)}</span><br><small style="color: #26a69a;">üîí Active</small>`;
                    } else {
                        // Show that trailing stop will activate at TP1
                        trailingStopDisplay = `<small style="color: #787b86;">Activates at TP1</small>`;
                    }
                } else if (signal.trailingStopPrice) {
                    // For closed signals, show saved trailing stop
                    trailingStopDisplay = `<span style="color: #787b86;">${signal.trailingStopPrice.toFixed(2)}</span>`;
                }
                
                const timeframe = signal.timeframe || '15m';
                // Color-coded timeframe badges
                let tfColor = '#58a6ff'; // Default blue
                if (timeframe === '1m') tfColor = '#ff6b6b';      // üî¥ Red - Ultra-fast scalping
                else if (timeframe === '3m') tfColor = '#ffa657';  // üü† Orange - Fast scalping
                else if (timeframe === '15m') tfColor = '#58a6ff'; // üîµ Blue - Day trading
                else if (timeframe === '1h') tfColor = '#a371f7';  // üü£ Purple - Swing trading
                else if (timeframe === '2h') tfColor = '#f85149';  // üî¥ Red - Best performer
                else if (timeframe === '4h') tfColor = '#3fb950';  // üü¢ Green - Position trading
                
                // Calculate ACTUAL Risk:Reward ratio based on exit or live price
                const risk = Math.abs(signal.entry - signal.stopLoss);
                const reward1 = Math.abs(signal.tp1 - signal.entry);
                const reward2 = Math.abs(signal.tp2 - signal.entry);
                const reward3 = Math.abs(signal.tp3 - signal.entry);
                
                // Calculate actual R:R based on status
                let actualRR = '-';
                let rrColor = '#787b86';
                let rrProgressHTML = '';
                
                if (signal.status === 'win' && signal.exitPrice) {
                    // Realized R:R from actual exit
                    const actualReward = Math.abs(signal.exitPrice - signal.entry);
                    const realizedRR = risk > 0 ? (actualReward / risk) : 0;
                    actualRR = realizedRR.toFixed(2);
                    
                    if (realizedRR >= 3) rrColor = '#26a69a';
                    else if (realizedRR >= 2) rrColor = '#4caf50';
                    else if (realizedRR >= 1.5) rrColor = '#f7931a';
                    else rrColor = '#ef5350';
                    
                    // Progress bar showing realized R:R
                    const rrPercent = Math.min(realizedRR / 5 * 100, 100);
                    rrProgressHTML = `
                        <div style="width: 60px; height: 4px; background: #1e222d; border-radius: 2px; margin-top: 4px;">
                            <div style="width: ${rrPercent}%; height: 100%; background: ${rrColor}; border-radius: 2px;"></div>
                        </div>
                        <small style="color: #26a69a; font-size: 9px;">‚úì Realized</small>
                    `;
                } else if (signal.status === 'loss') {
                    // Loss = -1 R:R
                    actualRR = '-1.00';
                    rrColor = '#ef5350';
                    rrProgressHTML = `
                        <div style="width: 60px; height: 4px; background: #1e222d; border-radius: 2px; margin-top: 4px;">
                            <div style="width: 0%; height: 100%; background: ${rrColor}; border-radius: 2px;"></div>
                        </div>
                        <small style="color: #ef5350; font-size: 9px;">‚úó Loss</small>
                    `;
                } else if (signal.status === 'pending') {
                    // Show current R:R progress for pending signals
                    const potentialRR = risk > 0 ? (reward3 / risk) : 0;
                    
                    if (signal.livePrice) {
                        // Calculate current unrealized R:R
                        const isBuy = signal.type === 'BUY';
                        const currentReward = isBuy 
                            ? (signal.livePrice - signal.entry) 
                            : (signal.entry - signal.livePrice);
                        const currentRR = risk > 0 ? (currentReward / risk) : 0;
                        
                        if (currentRR > 0) {
                            actualRR = `+${currentRR.toFixed(2)}`;
                            rrColor = currentRR >= 2 ? '#26a69a' : currentRR >= 1 ? '#4caf50' : '#f7931a';
                        } else {
                            actualRR = currentRR.toFixed(2);
                            rrColor = '#ef5350';
                        }
                        
                        // Progress bars for each TP
                        const tp1Progress = Math.max(0, Math.min(100, (currentReward / reward1) * 100));
                        const tp2Progress = Math.max(0, Math.min(100, (currentReward / reward2) * 100));
                        const tp3Progress = Math.max(0, Math.min(100, (currentReward / reward3) * 100));
                        
                        rrProgressHTML = `
                            <div style="display: flex; flex-direction: column; gap: 2px; margin-top: 4px;">
                                <div style="display: flex; align-items: center; gap: 3px;">
                                    <span style="font-size: 8px; color: #787b86; width: 18px;">T1</span>
                                    <div style="width: 35px; height: 3px; background: #1e222d; border-radius: 2px;">
                                        <div style="width: ${tp1Progress}%; height: 100%; background: ${tp1Progress >= 100 ? '#26a69a' : '#4caf50'}; border-radius: 2px;"></div>
                                    </div>
                                    <span style="font-size: 7px; color: ${tp1Progress >= 100 ? '#26a69a' : '#787b86'};">${tp1Progress.toFixed(0)}%</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 3px;">
                                    <span style="font-size: 8px; color: #787b86; width: 18px;">T2</span>
                                    <div style="width: 35px; height: 3px; background: #1e222d; border-radius: 2px;">
                                        <div style="width: ${tp2Progress}%; height: 100%; background: ${tp2Progress >= 100 ? '#26a69a' : '#f7931a'}; border-radius: 2px;"></div>
                                    </div>
                                    <span style="font-size: 7px; color: ${tp2Progress >= 100 ? '#26a69a' : '#787b86'};">${tp2Progress.toFixed(0)}%</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 3px;">
                                    <span style="font-size: 8px; color: #787b86; width: 18px;">T3</span>
                                    <div style="width: 35px; height: 3px; background: #1e222d; border-radius: 2px;">
                                        <div style="width: ${tp3Progress}%; height: 100%; background: ${tp3Progress >= 100 ? '#26a69a' : '#66bb6a'}; border-radius: 2px;"></div>
                                    </div>
                                    <span style="font-size: 7px; color: ${tp3Progress >= 100 ? '#26a69a' : '#787b86'};">${tp3Progress.toFixed(0)}%</span>
                                </div>
                            </div>
                        `;
                    } else {
                        // No live price, show potential R:R
                        actualRR = `~${potentialRR.toFixed(1)}`;
                        rrColor = potentialRR >= 3 ? '#26a69a' : potentialRR >= 2 ? '#4caf50' : '#f7931a';
                        rrProgressHTML = `<small style="color: #787b86; font-size: 9px;">Potential</small>`;
                    }
                }
                
                // Confluence score (from signal or calculate)
                const confluence = signal.confluence || signal.confluenceScore || '-';
                let confColor = '#787b86';
                if (confluence >= 4) confColor = '#26a69a';
                else if (confluence >= 3) confColor = '#4caf50';
                else if (confluence >= 2) confColor = '#f7931a';
                
                return `
                    <tr>
                        <td>${signals.indexOf(signal) + 1}</td>
                        <td>${new Date(signal.timestamp).toLocaleString()}</td>
                        <td><span class="badge" style="background: ${tfColor}; color: white; padding: 4px 8px; border-radius: 4px; font-weight: bold;">${timeframe.toUpperCase()}</span></td>
                        <td><span class="badge ${signal.type.toLowerCase()}">${signal.type}</span></td>
                        <td>${signal.symbol}</td>
                        <td>${signal.entry.toFixed(2)}</td>
                        <td>${signal.exitPrice ? signal.exitPrice.toFixed(2) : (signal.livePrice ? signal.livePrice.toFixed(2) : '-')}</td>
                        <td>${signal.stopLoss.toFixed(2)}</td>
                        <td style="color: ${rrColor}; font-weight: bold;">
                            <div>${actualRR}${actualRR !== '-' && !actualRR.includes('~') && !actualRR.includes('+') && !actualRR.includes('-') ? ':1' : actualRR.includes('~') ? ':1' : 'R'}</div>
                            ${rrProgressHTML}
                        </td>
                        <td>${signal.tp1.toFixed(2)}</td>
                        <td>${signal.tp2.toFixed(2)}</td>
                        <td>${signal.tp3.toFixed(2)}</td>
                        <td>${signal.strength}%</td>
                        <td style="color: ${confColor}; font-weight: bold;">${confluence}/6</td>
                        <td class="${statusClass}">${statusDisplay}</td>
                        <td>
                            ${resultDisplay}
                        </td>
                        <td>
                            ${signal.status === 'pending' ? 
                                `<button class="remove-btn" data-signal-id="${signal.id}" title="Remove this signal">üóëÔ∏è</button>` : 
                                '-'}
                        </td>
                    </tr>
                `;
                }).join('');
                
                // Use requestAnimationFrame for synchronized, lag-free updates
                requestAnimationFrame(() => {
                    // Batch DOM update for all fields simultaneously
                    tbody.innerHTML = rowsHTML;
                });
                
            } catch (error) {
                console.error('Error displaying signals:', error);
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; color: #ef5350; padding: 40px;">Error displaying signals. Check console.</td></tr>';
            }
        }

        // Remove signal function
        function removeSignal(signalId) {
            console.log('üóëÔ∏è Attempting to remove signal ID:', signalId, 'Type:', typeof signalId);
            console.log('Current signals IDs:', signals.map(s => ({ id: s.id, idType: typeof s.id, type: s.type, symbol: s.symbol })));
            
            if (!confirm('Are you sure you want to remove this pending signal?')) {
                return;
            }
            
            try {
                // Try multiple comparison methods
                let index = signals.findIndex(s => String(s.id) === String(signalId));
                
                console.log('Found index with string comparison:', index);
                
                if (index === -1) {
                    // Try numeric comparison
                    const numericId = parseFloat(signalId);
                    index = signals.findIndex(s => s.id === numericId);
                    console.log('Found index with numeric comparison:', index);
                }
                
                if (index !== -1) {
                    const removedSignal = signals[index];
                    signals.splice(index, 1);
                    
                    // Save to localStorage
                    saveSignals();
                    
                    // Refresh display
                    requestAnimationFrame(() => {
                        displaySignals(document.getElementById('filter').value);
                        updateStats();
                    });
                    
                    console.log('‚úÖ Signal removed successfully:', removedSignal);
                    
                    // Show notification
                    document.title = 'üóëÔ∏è Signal Removed - Signal Tracker';
                    setTimeout(() => {
                        document.title = 'Signal Tracker - Trading Signals';
                    }, 2000);
                } else {
                    console.error('‚ùå Signal not found with ID:', signalId);
                    console.error('Available signal IDs:', signals.map(s => s.id));
                    alert('Signal not found. The signal may have been already removed or updated. Refreshing...');
                    location.reload();
                }
            } catch (error) {
                console.error('‚ùå Error removing signal:', error);
                alert('Error removing signal: ' + error.message);
            }
        }
        
        // Event delegation for remove buttons
        document.addEventListener('click', function(e) {
            const target = e.target;
            
            // Check if clicked element or its parent is the remove button
            if (target && target.classList.contains('remove-btn')) {
                e.preventDefault();
                e.stopPropagation();
                
                const signalId = target.getAttribute('data-signal-id');
                console.log('üñ±Ô∏è Remove button clicked, signal ID:', signalId);
                
                if (signalId) {
                    removeSignal(signalId);
                } else {
                    console.error('No signal ID found on button');
                }
            }
        });
        
        // Manual refresh function
        async function manualRefresh() {
            const refreshBtn = document.getElementById('refreshBtn');
            
            if (refreshBtn.classList.contains('spinning')) {
                return; // Already refreshing
            }
            
            try {
                // Add spinning animation
                refreshBtn.classList.add('spinning');
                refreshBtn.textContent = '‚è≥ Refreshing...';
                
                console.log('üîÑ Manual refresh triggered...');
                
                // Update pending signals
                await updatePendingSignals();
                
                // Refresh display
                requestAnimationFrame(() => {
                    const filter = document.getElementById('filter').value;
                    filterSignals();
                    updateStats();
                });
                
                console.log('‚úÖ Refresh complete!');
                
                // Show success state briefly
                refreshBtn.textContent = '‚úÖ Updated!';
                
                setTimeout(() => {
                    refreshBtn.classList.remove('spinning');
                    refreshBtn.textContent = 'üîÑ Refresh';
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Refresh error:', error);
                refreshBtn.classList.remove('spinning');
                refreshBtn.textContent = '‚ùå Error';
                
                setTimeout(() => {
                    refreshBtn.textContent = 'üîÑ Refresh';
                }, 2000);
            }
        }
        
        // Add test signal
        async function addTestSignal() {
            const isBuy = Math.random() > 0.5;
            const entry = 91500 + Math.random() * 1000;
            
            const testSignal = {
                id: Date.now() + Math.random(), // Match prediction.js format
                timestamp: Date.now(),
                type: isBuy ? 'BUY' : 'SELL',
                symbol: 'BTCUSDT',
                entry: entry,
                stopLoss: isBuy ? entry - 500 : entry + 500,
                tp1: isBuy ? entry + 500 : entry - 500,
                tp2: isBuy ? entry + 1000 : entry - 1000,
                tp3: isBuy ? entry + 1500 : entry - 1500,
                strength: Math.floor(60 + Math.random() * 30),
                status: 'pending',
                exitPrice: null,
                exitReason: null,
                trailingStopPrice: null,
                trailingStopActive: false
            };
            
            // Simulate live price that has reached TP1 to show trailing stop
            const priceProgress = Math.random();
            if (priceProgress > 0.5) {
                // Price has moved past TP1
                testSignal.livePrice = isBuy ? testSignal.tp1 + 200 : testSignal.tp1 - 200;
                
                // Calculate trailing stop
                if (isBuy) {
                    const profitDistance = testSignal.livePrice - testSignal.entry;
                    testSignal.calculatedTrailingStop = testSignal.entry + (profitDistance * 0.5);
                } else {
                    const profitDistance = testSignal.entry - testSignal.livePrice;
                    testSignal.calculatedTrailingStop = testSignal.entry - (profitDistance * 0.5);
                }
                testSignal.trailingStopActive = true;
            } else {
                // Price is between entry and TP1
                testSignal.livePrice = isBuy ? 
                    testSignal.entry + (testSignal.tp1 - testSignal.entry) * priceProgress :
                    testSignal.entry - (testSignal.entry - testSignal.tp1) * priceProgress;
            }
            
            signals.unshift(testSignal);
            saveSignals();
            displaySignals(document.getElementById('filter').value);
            updateStats();
            
            console.log('‚úÖ Test signal added:', testSignal);
        }

        // Export to CSV
        function exportToCSV() {
            const csv = [
                ['#', 'Date/Time', 'Type', 'Symbol', 'Entry', 'Stop Loss', 'TP1', 'TP2', 'TP3', 'Strength', 'Status'],
                ...signals.map((s, i) => [
                    i + 1,
                    new Date(s.timestamp).toLocaleString(),
                    s.type,
                    s.symbol,
                    s.entry,
                    s.stopLoss,
                    s.tp1,
                    s.tp2,
                    s.tp3,
                    s.strength + '%',
                    s.status.toUpperCase()
                ])
            ].map(row => row.join(',')).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading-signals-${Date.now()}.csv`;
            a.click();
        }

        // Clear browser localStorage only
        function clearLocalStorage() {
            const localCount = JSON.parse(localStorage.getItem('tradingSignals') || '[]').length;
            
            if (!confirm(`Clear ${localCount} signals from browser localStorage?\n\nThis will NOT affect Supabase database.`)) {
                return;
            }
            
            localStorage.removeItem('tradingSignals');
            signals = [];
            filterSignals();
            updateStats();
            
            alert(`‚úÖ Cleared ${localCount} signals from browser localStorage!`);
            console.log('üßπ LocalStorage cleared');
        }
        
        // Clear all signals (localStorage AND Supabase)
        async function clearAllSignals() {
            // First check how many signals are in Supabase
            let supabaseCount = 0;
            try {
                if (typeof supabase !== 'undefined') {
                    const { data } = await supabase.from('trading_signals').select('id');
                    supabaseCount = data ? data.length : 0;
                }
            } catch (e) {
                console.warn('Could not count Supabase signals:', e);
            }
            
            const localCount = signals.length;
            
            if (!confirm(`DELETE ALL SIGNALS?\n\nüìä Local: ${localCount} signals\n‚òÅÔ∏è Supabase: ${supabaseCount} signals\n\nThis cannot be undone!`)) {
                return;
            }
            
            if (!confirm('‚ö†Ô∏è FINAL WARNING: Permanently delete ALL signals?')) {
                return;
            }
            
            console.log('üóëÔ∏è Starting delete...');
            let deletedFromSupabase = 0;
            
            try {
                // STEP 1: Delete from Supabase
                if (typeof supabase !== 'undefined' && supabaseCount > 0) {
                    console.log(`Deleting ${supabaseCount} signals from Supabase...`);
                    
                    // Get all signal IDs
                    const { data: allSignals } = await supabase
                        .from('trading_signals')
                        .select('id');
                    
                    if (allSignals && allSignals.length > 0) {
                        // Delete each signal individually (most reliable method)
                        for (let i = 0; i < allSignals.length; i++) {
                            const { error } = await supabase
                                .from('trading_signals')
                                .delete()
                                .eq('id', allSignals[i].id);
                            
                            if (!error) {
                                deletedFromSupabase++;
                            } else {
                                console.error(`Failed to delete ID ${allSignals[i].id}:`, error);
                            }
                            
                            // Progress log every 50
                            if ((i + 1) % 50 === 0) {
                                console.log(`Progress: ${i + 1}/${allSignals.length} deleted`);
                            }
                        }
                    }
                    
                    console.log(`‚úÖ Deleted ${deletedFromSupabase}/${supabaseCount} from Supabase`);
                    
                    // Verify deletion
                    const { data: remaining } = await supabase
                        .from('trading_signals')
                        .select('id');
                    
                    if (remaining && remaining.length > 0) {
                        console.warn(`‚ö†Ô∏è ${remaining.length} signals still remain in Supabase!`);
                        alert(`‚ö†Ô∏è Warning: ${remaining.length} signals could not be deleted from Supabase.\n\nYou may need to:\n1. Run the SQL in fix-supabase-permissions.sql\n2. Or delete manually from Supabase dashboard`);
                    }
                }
                
                // STEP 2: Clear local storage
                signals = [];
                localStorage.removeItem('tradingSignals');
                localStorage.setItem('tradingSignals', '[]');
                
                // STEP 3: Refresh display
                filterSignals();
                updateStats();
                
                const msg = `‚úÖ Delete Complete!\n\n‚Ä¢ Local: ${localCount} cleared\n‚Ä¢ Supabase: ${deletedFromSupabase}/${supabaseCount} deleted`;
                console.log(msg);
                alert(msg);
                
                // Force reload to verify
                if (confirm('Reload page to verify deletion?')) {
                    location.reload();
                }
                
            } catch (error) {
                console.error('Delete error:', error);
                
                // Clear local anyway
                signals = [];
                localStorage.removeItem('tradingSignals');
                localStorage.setItem('tradingSignals', '[]');
                filterSignals();
                updateStats();
                
                alert(`‚ö†Ô∏è Error during delete:\n${error.message}\n\nLocal signals cleared.\n\nTo delete Supabase data manually:\n1. Go to Supabase Dashboard\n2. Open Table Editor > trading_signals\n3. Select all rows and delete`);
            }
        }
        
        // Show chart
        function showChart() {
            const wins = signals.filter(s => s.status === 'win').length;
            const losses = signals.filter(s => s.status === 'loss').length;
            const pending = signals.filter(s => s.status === 'pending').length;
            
            alert(`üìä Performance Chart\n\n` +
                  `Wins: ${wins} (${((wins/(wins+losses))*100).toFixed(1)}%)\n` +
                  `Losses: ${losses} (${((losses/(wins+losses))*100).toFixed(1)}%)\n` +
                  `Pending: ${pending}\n\n` +
                  `Chart visualization coming soon!`);
        }
        
        // Show detailed statistics
        function showStats() {
            const winTrades = signals.filter(s => s.status === 'win' && s.exitPrice);
            const lossTrades = signals.filter(s => s.status === 'loss' && s.exitPrice);
            
            const tp1Exits = signals.filter(s => s.exitReason === 'TP1').length;
            const tp2Exits = signals.filter(s => s.exitReason === 'TP2').length;
            const tp3Exits = signals.filter(s => s.exitReason === 'TP3').length;
            const trailingExits = signals.filter(s => s.exitReason === 'Trailing Stop').length;
            const slExits = signals.filter(s => s.exitReason === 'Stop Loss').length;
            
            const buySignals = signals.filter(s => s.type === 'BUY');
            const sellSignals = signals.filter(s => s.type === 'SELL');
            const buyWins = buySignals.filter(s => s.status === 'win').length;
            const sellWins = sellSignals.filter(s => s.status === 'win').length;
            
            alert(`üìà Detailed Statistics\n\n` +
                  `Exit Breakdown:\n` +
                  `TP1: ${tp1Exits}\n` +
                  `TP2: ${tp2Exits}\n` +
                  `TP3: ${tp3Exits}\n` +
                  `Trailing Stop: ${trailingExits}\n` +
                  `Stop Loss: ${slExits}\n\n` +
                  `Signal Type Performance:\n` +
                  `BUY: ${buyWins}/${buySignals.length} (${buySignals.length > 0 ? ((buyWins/buySignals.length)*100).toFixed(1) : 0}%)\n` +
                  `SELL: ${sellWins}/${sellSignals.length} (${sellSignals.length > 0 ? ((sellWins/sellSignals.length)*100).toFixed(1) : 0}%)`);
        }

        // Update pending signals with live price
        // Cache for price data to reduce API calls
        let priceCache = {};
        let lastPriceFetch = 0;
        
        async function updatePendingSignals() {
            const pendingSignals = signals.filter(s => s.status === 'pending');
            
            if (pendingSignals.length === 0) return;
            
            // Rate limit: only fetch prices every 10 seconds
            const now = Date.now();
            const shouldFetchPrice = (now - lastPriceFetch) > 10000;
            
            // Fetch price once for all symbols (batch request)
            if (shouldFetchPrice) {
                try {
                    // Get unique symbols
                    const symbols = [...new Set(pendingSignals.map(s => s.symbol || 'BTCUSDT'))];
                    
                    // Fetch all prices in one request
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price`);
                    if (response.ok) {
                        const allPrices = await response.json();
                        // Update cache
                        allPrices.forEach(item => {
                            priceCache[item.symbol] = parseFloat(item.price);
                        });
                        lastPriceFetch = now;
                    }
                } catch (error) {
                    // Silently fail - use cached prices
                }
            }
            
            // Update all signals using cached prices
            pendingSignals.forEach(signal => {
                try {
                    const currentPrice = priceCache[signal.symbol || 'BTCUSDT'];
                    if (!currentPrice) return; // Skip if no price available
                // Calculate progress
                let progress = 0;
                let timeEstimate = '';
                
                if (signal.type === 'BUY') {
                    const totalDistance = signal.tp1 - signal.entry;
                    const currentDistance = currentPrice - signal.entry;
                    progress = (currentDistance / totalDistance) * 100;
                } else {
                    const totalDistance = signal.entry - signal.tp1;
                    const currentDistance = signal.entry - currentPrice;
                    progress = (currentDistance / totalDistance) * 100;
                }
                
                // Calculate trailing stop based on strategy
                let calculatedTrailingStop = null;
                let trailingActive = false;
                
                // Find signal index for updates
                const index = signals.findIndex(s => s.id === signal.id);
                if (index === -1) return;
                
                // ========== CHECK FOR WIN/LOSS CONDITIONS ==========
                let statusChanged = false;
                
                if (signal.type === 'BUY') {
                    // Check STOP LOSS hit first (priority)
                    if (currentPrice <= signal.stopLoss) {
                        signals[index].status = 'loss';
                        signals[index].exitPrice = signal.stopLoss;
                        signals[index].exitReason = 'Stop Loss';
                        statusChanged = true;
                        console.log(`‚ùå LOSS: ${signal.symbol} hit Stop Loss at ${signal.stopLoss}`);
                    }
                    // Check TP3 hit (full target)
                    else if (currentPrice >= signal.tp3) {
                        signals[index].status = 'win';
                        signals[index].exitPrice = signal.tp3;
                        signals[index].exitReason = 'TP3';
                        statusChanged = true;
                        console.log(`‚úÖ WIN: ${signal.symbol} hit TP3 at ${signal.tp3}`);
                    }
                    // Check TP2 hit
                    else if (currentPrice >= signal.tp2) {
                        signals[index].status = 'win';
                        signals[index].exitPrice = signal.tp2;
                        signals[index].exitReason = 'TP2';
                        statusChanged = true;
                        console.log(`‚úÖ WIN: ${signal.symbol} hit TP2 at ${signal.tp2}`);
                    }
                    // Check TP1 hit - activate trailing stop
                    else if (currentPrice >= signal.tp1) {
                        trailingActive = true;
                        const profitDistance = currentPrice - signal.entry;
                        calculatedTrailingStop = signal.entry + (profitDistance * 0.5);
                        
                        // Check if trailing stop was hit
                        if (signal.calculatedTrailingStop && currentPrice <= signal.calculatedTrailingStop) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.calculatedTrailingStop;
                            signals[index].exitReason = 'Trailing Stop';
                            statusChanged = true;
                            console.log(`‚úÖ WIN: ${signal.symbol} hit Trailing Stop at ${signal.calculatedTrailingStop}`);
                        }
                    }
                } else { // SELL
                    // Check STOP LOSS hit first (priority)
                    if (currentPrice >= signal.stopLoss) {
                        signals[index].status = 'loss';
                        signals[index].exitPrice = signal.stopLoss;
                        signals[index].exitReason = 'Stop Loss';
                        statusChanged = true;
                        console.log(`‚ùå LOSS: ${signal.symbol} hit Stop Loss at ${signal.stopLoss}`);
                    }
                    // Check TP3 hit (full target)
                    else if (currentPrice <= signal.tp3) {
                        signals[index].status = 'win';
                        signals[index].exitPrice = signal.tp3;
                        signals[index].exitReason = 'TP3';
                        statusChanged = true;
                        console.log(`‚úÖ WIN: ${signal.symbol} hit TP3 at ${signal.tp3}`);
                    }
                    // Check TP2 hit
                    else if (currentPrice <= signal.tp2) {
                        signals[index].status = 'win';
                        signals[index].exitPrice = signal.tp2;
                        signals[index].exitReason = 'TP2';
                        statusChanged = true;
                        console.log(`‚úÖ WIN: ${signal.symbol} hit TP2 at ${signal.tp2}`);
                    }
                    // Check TP1 hit - activate trailing stop
                    else if (currentPrice <= signal.tp1) {
                        trailingActive = true;
                        const profitDistance = signal.entry - currentPrice;
                        calculatedTrailingStop = signal.entry - (profitDistance * 0.5);
                        
                        // Check if trailing stop was hit
                        if (signal.calculatedTrailingStop && currentPrice >= signal.calculatedTrailingStop) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.calculatedTrailingStop;
                            signals[index].exitReason = 'Trailing Stop';
                            statusChanged = true;
                            console.log(`‚úÖ WIN: ${signal.symbol} hit Trailing Stop at ${signal.calculatedTrailingStop}`);
                        }
                    }
                }
                
                // If status changed, update Supabase too
                if (statusChanged && typeof SupabaseDB !== 'undefined') {
                    try {
                        SupabaseDB.updateSignalStatus(signal.id, {
                            status: signals[index].status,
                            exitPrice: signals[index].exitPrice,
                            exitReason: signals[index].exitReason,
                            profitPercent: signal.type === 'BUY' 
                                ? ((signals[index].exitPrice - signal.entry) / signal.entry) * 100
                                : ((signal.entry - signals[index].exitPrice) / signal.entry) * 100
                        });
                    } catch (e) {
                        console.warn('Failed to update Supabase:', e);
                    }
                }
                
                // Skip further updates if signal is closed
                if (statusChanged) return;
                    
                // Estimate time based on elapsed time and progress
                const elapsed = Date.now() - signal.timestamp;
                if (Math.abs(progress) > 5) {
                    const estimatedTotal = (elapsed / Math.abs(progress)) * 100;
                    const remaining = estimatedTotal - elapsed;
                    const hours = Math.floor(remaining / 3600000);
                    const minutes = Math.floor((remaining % 3600000) / 60000);
                    
                    if (hours > 0) {
                        timeEstimate = `~${hours}h ${minutes}m`;
                    } else if (minutes > 0) {
                        timeEstimate = `~${minutes}m`;
                    } else {
                        timeEstimate = '< 1m';
                    }
                } else {
                    timeEstimate = 'Calculating...';
                }
                
                // Update signal with live data
                signals[index].livePrice = currentPrice;
                signals[index].progress = progress;
                signals[index].timeEstimate = timeEstimate;
                
                // Update trailing stop if calculated
                if (trailingActive) {
                    signals[index].calculatedTrailingStop = calculatedTrailingStop;
                    signals[index].trailingStopActive = true;
                }
                } catch (error) {
                    // Silently handle errors
                }
            });
            
            // Save updated signals to localStorage in one batch
            saveSignals();
        }

        // Check all pending signals and update their results
        async function checkAllSignalResults() {
            console.log('üéØ Checking all signal results...');
            
            const pendingSignals = signals.filter(s => s.status === 'pending');
            if (pendingSignals.length === 0) {
                alert('No pending signals to check.');
                return;
            }
            
            let winsFound = 0;
            let lossesFound = 0;
            
            try {
                // Fetch current price
                const response = await fetch('https://api.binance.com/api/v3/ticker/price');
                const allPrices = await response.json();
                const priceMap = {};
                allPrices.forEach(item => {
                    priceMap[item.symbol] = parseFloat(item.price);
                });
                
                // Check each pending signal
                pendingSignals.forEach(signal => {
                    const currentPrice = priceMap[signal.symbol || 'BTCUSDT'];
                    if (!currentPrice) return;
                    
                    const index = signals.findIndex(s => s.id === signal.id);
                    if (index === -1) return;
                    
                    if (signal.type === 'BUY') {
                        // Check Stop Loss
                        if (currentPrice <= signal.stopLoss) {
                            signals[index].status = 'loss';
                            signals[index].exitPrice = signal.stopLoss;
                            signals[index].exitReason = 'Stop Loss';
                            lossesFound++;
                        }
                        // Check TP3
                        else if (currentPrice >= signal.tp3) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp3;
                            signals[index].exitReason = 'TP3';
                            winsFound++;
                        }
                        // Check TP2
                        else if (currentPrice >= signal.tp2) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp2;
                            signals[index].exitReason = 'TP2';
                            winsFound++;
                        }
                        // Check TP1
                        else if (currentPrice >= signal.tp1) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp1;
                            signals[index].exitReason = 'TP1';
                            winsFound++;
                        }
                    } else { // SELL
                        // Check Stop Loss
                        if (currentPrice >= signal.stopLoss) {
                            signals[index].status = 'loss';
                            signals[index].exitPrice = signal.stopLoss;
                            signals[index].exitReason = 'Stop Loss';
                            lossesFound++;
                        }
                        // Check TP3
                        else if (currentPrice <= signal.tp3) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp3;
                            signals[index].exitReason = 'TP3';
                            winsFound++;
                        }
                        // Check TP2
                        else if (currentPrice <= signal.tp2) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp2;
                            signals[index].exitReason = 'TP2';
                            winsFound++;
                        }
                        // Check TP1
                        else if (currentPrice <= signal.tp1) {
                            signals[index].status = 'win';
                            signals[index].exitPrice = signal.tp1;
                            signals[index].exitReason = 'TP1';
                            winsFound++;
                        }
                    }
                });
                
                // Save and refresh
                saveSignals();
                filterSignals();
                updateStats();
                
                alert(`üéØ Results Check Complete!\n\n‚úÖ Wins Found: ${winsFound}\n‚ùå Losses Found: ${lossesFound}\n‚è≥ Still Pending: ${pendingSignals.length - winsFound - lossesFound}`);
                
            } catch (error) {
                console.error('Error checking results:', error);
                alert('Error checking results. Please try again.');
            }
        }
        
        // Auto-cleanup old signals (older than 30 days)
        function cleanupOldSignals() {
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            const originalLength = signals.length;
            signals = signals.filter(s => s.timestamp > thirtyDaysAgo);
            
            if (signals.length < originalLength) {
                saveSignals();
                console.log(`üóëÔ∏è Cleaned up ${originalLength - signals.length} old signals`);
            }
        }

        // Fetch 1-minute signals from Binance and generate scalping signals
        // ‚õî DISABLED - Signals should only come from Go backend server
        async function fetch1mSignals() {
            alert('‚õî Signal generation is DISABLED\n\nSignals should only be generated by the Go backend server.\n\nStart your Go server to generate signals.');
            return;
            
            console.log('‚ö° Fetching 1m signals...');
            
            try {
                // Fetch 1m candles from Binance
                const response = await fetch('https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=100');
                const candles = await response.json();
                
                if (!candles || candles.length < 20) {
                    console.error('Not enough candle data');
                    return;
                }
                
                // Analyze for scalping signals
                const signals1m = analyze1mCandles(candles);
                
                if (signals1m.length > 0) {
                    // Add new 1m signals
                    signals1m.forEach(sig => {
                        // Check if signal already exists
                        const exists = signals.some(s => 
                            Math.abs(s.entry - sig.entry) < 10 && 
                            s.timeframe === '1m' &&
                            Date.now() - s.timestamp < 60000
                        );
                        
                        if (!exists) {
                            signals.unshift(sig);
                            console.log('‚ö° New 1m signal added:', sig);
                        }
                    });
                    
                    saveSignals();
                    filterSignals();
                    updateStats();
                    updateScalpingStats();
                    
                    // Flash notification
                    document.title = '‚ö° 1m Signal! - Signal Tracker';
                    setTimeout(() => {
                        document.title = 'Signal Tracker - Trading Signals';
                    }, 3000);
                } else {
                    console.log('No 1m signals found at this time');
                    alert('No strong 1m scalping signals found. Market may be ranging.');
                }
                
            } catch (error) {
                console.error('Error fetching 1m signals:', error);
                alert('Error fetching 1m data. Please try again.');
            }
        }
        
        // Analyze 1m candles for scalping signals
        function analyze1mCandles(candles) {
            const signals1m = [];
            const currentPrice = parseFloat(candles[candles.length - 1][4]); // Close price
            
            // Calculate indicators
            const closes = candles.map(c => parseFloat(c[4]));
            const highs = candles.map(c => parseFloat(c[2]));
            const lows = candles.map(c => parseFloat(c[3]));
            const volumes = candles.map(c => parseFloat(c[5]));
            
            // EMA calculations
            const ema9 = calculateEMA(closes, 9);
            const ema21 = calculateEMA(closes, 21);
            
            // RSI calculation
            const rsi = calculateRSI(closes, 14);
            
            // Volume analysis
            const avgVolume = volumes.slice(-20).reduce((a, b) => a + b, 0) / 20;
            const currentVolume = volumes[volumes.length - 1];
            const volumeSpike = currentVolume > avgVolume * 1.5;
            
            // Price action analysis
            const lastCandle = candles[candles.length - 1];
            const prevCandle = candles[candles.length - 2];
            const lastOpen = parseFloat(lastCandle[1]);
            const lastClose = parseFloat(lastCandle[4]);
            const lastHigh = parseFloat(lastCandle[2]);
            const lastLow = parseFloat(lastCandle[3]);
            
            const isBullishCandle = lastClose > lastOpen;
            const isBearishCandle = lastClose < lastOpen;
            const candleBody = Math.abs(lastClose - lastOpen);
            const candleRange = lastHigh - lastLow;
            const bodyRatio = candleRange > 0 ? candleBody / candleRange : 0;
            
            // Trend detection
            const shortTrend = ema9 > ema21 ? 'bullish' : 'bearish';
            const trendStrength = Math.abs(ema9 - ema21) / currentPrice * 100;
            
            // Support/Resistance levels
            const recentLows = lows.slice(-20);
            const recentHighs = highs.slice(-20);
            const support = Math.min(...recentLows);
            const resistance = Math.max(...recentHighs);
            
            // Generate BUY signal conditions
            let buyScore = 0;
            let buyReasons = [];
            
            if (shortTrend === 'bullish') { buyScore += 20; buyReasons.push('EMA Bullish'); }
            if (rsi < 40 && rsi > 20) { buyScore += 25; buyReasons.push('RSI Oversold'); }
            if (isBullishCandle && bodyRatio > 0.6) { buyScore += 20; buyReasons.push('Strong Bullish Candle'); }
            if (volumeSpike) { buyScore += 15; buyReasons.push('Volume Spike'); }
            if (currentPrice < support * 1.005) { buyScore += 20; buyReasons.push('Near Support'); }
            
            // Generate SELL signal conditions
            let sellScore = 0;
            let sellReasons = [];
            
            if (shortTrend === 'bearish') { sellScore += 20; sellReasons.push('EMA Bearish'); }
            if (rsi > 60 && rsi < 80) { sellScore += 25; sellReasons.push('RSI Overbought'); }
            if (isBearishCandle && bodyRatio > 0.6) { sellScore += 20; sellReasons.push('Strong Bearish Candle'); }
            if (volumeSpike) { sellScore += 15; sellReasons.push('Volume Spike'); }
            if (currentPrice > resistance * 0.995) { sellScore += 20; sellReasons.push('Near Resistance'); }
            
            // Create signal if score is high enough
            const minScore = 60;
            
            if (buyScore >= minScore && buyScore > sellScore) {
                const atr = calculateATR(highs, lows, closes, 14);
                const sl = currentPrice - (atr * 1.5);
                const tp1 = currentPrice + (atr * 1);
                const tp2 = currentPrice + (atr * 2);
                const tp3 = currentPrice + (atr * 3);
                
                signals1m.push({
                    id: Date.now() + Math.random(),
                    timestamp: Date.now(),
                    type: 'BUY',
                    symbol: 'BTCUSDT',
                    entry: currentPrice,
                    stopLoss: sl,
                    tp1: tp1,
                    tp2: tp2,
                    tp3: tp3,
                    strength: buyScore,
                    status: 'pending',
                    timeframe: '1m',
                    confluence: buyReasons.length,
                    reasons: buyReasons.join(', '),
                    livePrice: currentPrice
                });
            }
            
            if (sellScore >= minScore && sellScore > buyScore) {
                const atr = calculateATR(highs, lows, closes, 14);
                const sl = currentPrice + (atr * 1.5);
                const tp1 = currentPrice - (atr * 1);
                const tp2 = currentPrice - (atr * 2);
                const tp3 = currentPrice - (atr * 3);
                
                signals1m.push({
                    id: Date.now() + Math.random(),
                    timestamp: Date.now(),
                    type: 'SELL',
                    symbol: 'BTCUSDT',
                    entry: currentPrice,
                    stopLoss: sl,
                    tp1: tp1,
                    tp2: tp2,
                    tp3: tp3,
                    strength: sellScore,
                    status: 'pending',
                    timeframe: '1m',
                    confluence: sellReasons.length,
                    reasons: sellReasons.join(', '),
                    livePrice: currentPrice
                });
            }
            
            return signals1m;
        }
        
        // Helper: Calculate EMA
        function calculateEMA(data, period) {
            const k = 2 / (period + 1);
            let ema = data.slice(0, period).reduce((a, b) => a + b, 0) / period;
            
            for (let i = period; i < data.length; i++) {
                ema = data[i] * k + ema * (1 - k);
            }
            return ema;
        }
        
        // Helper: Calculate RSI
        function calculateRSI(data, period) {
            let gains = 0, losses = 0;
            
            for (let i = data.length - period; i < data.length; i++) {
                const change = data[i] - data[i - 1];
                if (change > 0) gains += change;
                else losses -= change;
            }
            
            const avgGain = gains / period;
            const avgLoss = losses / period;
            const rs = avgLoss === 0 ? 100 : avgGain / avgLoss;
            return 100 - (100 / (1 + rs));
        }
        
        // Helper: Calculate ATR
        function calculateATR(highs, lows, closes, period) {
            let trSum = 0;
            for (let i = highs.length - period; i < highs.length; i++) {
                const tr = Math.max(
                    highs[i] - lows[i],
                    Math.abs(highs[i] - closes[i - 1]),
                    Math.abs(lows[i] - closes[i - 1])
                );
                trSum += tr;
            }
            return trSum / period;
        }
        
        // Update scalping stats
        function updateScalpingStats() {
            // Check if elements exist
            const scalpTotalEl = document.getElementById('scalp-total');
            const scalpWinrateEl = document.getElementById('scalp-winrate');
            const scalpAvgrrEl = document.getElementById('scalp-avgrr');
            const scalpPendingEl = document.getElementById('scalp-pending');
            const scalpLastEl = document.getElementById('scalp-last');
            
            if (!scalpTotalEl) return; // Elements not found, skip
            
            const scalp1m = signals.filter(s => s.timeframe === '1m');
            const scalpWins = scalp1m.filter(s => s.status === 'win').length;
            const scalpLosses = scalp1m.filter(s => s.status === 'loss').length;
            const scalpPending = scalp1m.filter(s => s.status === 'pending').length;
            const scalpTotal = scalpWins + scalpLosses;
            const scalpWinRate = scalpTotal > 0 ? ((scalpWins / scalpTotal) * 100).toFixed(0) : '0';
            
            // Calculate avg R:R for 1m signals
            let totalRR = 0;
            let rrCount = 0;
            scalp1m.filter(s => s.status === 'win' && s.exitPrice).forEach(s => {
                const risk = Math.abs(s.entry - s.stopLoss);
                const reward = Math.abs(s.exitPrice - s.entry);
                if (risk > 0) {
                    totalRR += reward / risk;
                    rrCount++;
                }
            });
            const avgRR = rrCount > 0 ? (totalRR / rrCount).toFixed(1) : '0';
            
            // Last signal time
            const lastSignal = scalp1m[0];
            const lastTime = lastSignal ? new Date(lastSignal.timestamp).toLocaleTimeString() : '-';
            
            scalpTotalEl.textContent = scalp1m.length;
            scalpWinrateEl.textContent = `${scalpWinRate}%`;
            scalpAvgrrEl.textContent = `${avgRR}:1`;
            scalpPendingEl.textContent = scalpPending;
            scalpLastEl.textContent = lastTime;
            
            // Color code win rate
            const winRateNum = parseFloat(scalpWinRate);
            if (winRateNum >= 60) scalpWinrateEl.style.color = '#26a69a';
            else if (winRateNum >= 50) scalpWinrateEl.style.color = '#f7931a';
            else if (winRateNum > 0) scalpWinrateEl.style.color = '#ef5350';
            else scalpWinrateEl.style.color = '#787b86';
        }
        
        // Show loading complete animation
        function showLoadingComplete() {
            try {
                const overlay = document.getElementById('loadingOverlay');
                const spinner = document.getElementById('spinner');
                const checkmark = document.getElementById('successCheckmark');
                const loadingText = document.getElementById('loadingText');
                
                if (!overlay || !spinner || !checkmark || !loadingText) {
                    console.error('Loading elements not found');
                    return;
                }
                
                spinner.style.display = 'none';
                checkmark.classList.add('show');
                loadingText.textContent = 'Loaded successfully!';
                
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 500);
                }, 800);
            } catch (error) {
                console.error('Error in showLoadingComplete:', error);
            }
        }
        
        // Initialize with fast loading
        async function initialize() {
            try {
                console.log('üöÄ Initializing Signal Tracker...');
                isLoading = true;
                
                // Load signals
                await loadSignals();
                
                // Clean up old signals
                cleanupOldSignals();
                
                // Display signals
                displaySignals();
                updateStats();
                updateScalpingStats();
                
                // Show success animation
                showLoadingComplete();
                
                isLoading = false;
                console.log('‚úÖ Initialization complete!');
                
                // Start monitoring after load
                setTimeout(() => {
                    updatePendingSignals();
                }, 2000);
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                isLoading = false;
                showLoadingComplete();
            }
        }
        
        // Start initialization
        initialize();
        
        // Update session indicator immediately and every second for live clock
        updateSessionIndicator();
        setInterval(updateSessionIndicator, 1000);
        
        // Update pending signals every 30 seconds (reduced from 5 to prevent API overload)
        let lastUpdateTime = 0;
        setInterval(() => {
            if (!isLoading) {
                const now = Date.now();
                // Throttle updates to prevent excessive calls
                if (now - lastUpdateTime < 29000) return;
                lastUpdateTime = now;
                
                updatePendingSignals().then(() => {
                    // Use requestAnimationFrame for smooth, synchronized updates
                    requestAnimationFrame(() => {
                        const filter = document.getElementById('filter').value;
                        filterSignals();
                    });
                });
            }
        }, 5000);

        // Listen for new signals from main app with optimized updates
        let storageUpdateTimeout;
        let lastSignalCount = 0;
        window.addEventListener('storage', (e) => {
            if (e.key === 'tradingSignals') {
                clearTimeout(storageUpdateTimeout);
                storageUpdateTimeout = setTimeout(() => {
                    const newSignals = JSON.parse(e.newValue || '[]');
                    
                    // Only update if signal count actually changed
                    if (newSignals.length !== lastSignalCount) {
                        lastSignalCount = newSignals.length;
                        
                        // Use requestAnimationFrame for synchronized updates
                        requestAnimationFrame(() => {
                            // Check if there are actually new signals
                            if (newSignals.length > signals.length) {
                                console.log('üÜï New signal detected!');
                            }
                            signals = newSignals;
                            displaySignals(document.getElementById('filter').value);
                            updateStats();
                            
                            // Flash notification
                            document.title = 'üîî New Signal! - Signal Tracker';
                            setTimeout(() => {
                                document.title = 'Signal Tracker - Trading Signals';
                            }, 3000);
                        });
                    }
                }, 50);
            }
        });
        
        // Cleanup function removed - using cloud-only storage now
    </script>
    <script src="sync-service.js"></script>
</body>
</html>
