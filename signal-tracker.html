<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signal Tracker - Trading Signals</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #131722;
            color: #d1d4dc;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        /* Loading Animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #131722;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.5s ease;
        }
        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid #2a2e39;
            border-top: 4px solid #26a69a;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .loading-text {
            margin-top: 20px;
            color: #787b86;
            font-size: 14px;
        }
        .success-checkmark {
            width: 80px;
            height: 80px;
            margin: 0 auto;
            display: none;
        }
        .success-checkmark.show {
            display: block;
        }
        .check-icon {
            width: 80px;
            height: 80px;
            position: relative;
            border-radius: 50%;
            box-sizing: content-box;
            border: 4px solid #26a69a;
        }
        .check-icon::before {
            top: 3px;
            left: -2px;
            width: 30px;
            transform-origin: 100% 50%;
            border-radius: 100px 0 0 100px;
        }
        .check-icon::after {
            top: 0;
            left: 30px;
            width: 60px;
            transform-origin: 0 50%;
            border-radius: 0 100px 100px 0;
            animation: rotate-circle 4.25s ease-in;
        }
        .icon-line {
            height: 5px;
            background-color: #26a69a;
            display: block;
            border-radius: 2px;
            position: absolute;
            z-index: 10;
        }
        .icon-line.line-tip {
            top: 46px;
            left: 14px;
            width: 25px;
            transform: rotate(45deg);
            animation: icon-line-tip 0.75s;
        }
        .icon-line.line-long {
            top: 38px;
            right: 8px;
            width: 47px;
            transform: rotate(-45deg);
            animation: icon-line-long 0.75s;
        }
        @keyframes icon-line-tip {
            0% { width: 0; left: 1px; top: 19px; }
            54% { width: 0; left: 1px; top: 19px; }
            70% { width: 50px; left: -8px; top: 37px; }
            84% { width: 17px; left: 21px; top: 48px; }
            100% { width: 25px; left: 14px; top: 46px; }
        }
        @keyframes icon-line-long {
            0% { width: 0; right: 46px; top: 54px; }
            65% { width: 0; right: 46px; top: 54px; }
            84% { width: 55px; right: 0px; top: 35px; }
            100% { width: 47px; right: 8px; top: 38px; }
        }
        h1 {
            color: #26a69a;
            margin-bottom: 20px;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #1e222d;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: bold;
            margin: 10px 0;
        }
        .stat-value.profit {
            color: #26a69a;
        }
        .stat-value.loss {
            color: #ef5350;
        }
        .stat-label {
            color: #787b86;
            font-size: 12px;
            text-transform: uppercase;
        }
        .controls {
            background: #1e222d;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        button {
            background: #26a69a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover {
            background: #2bbbad;
        }
        button.secondary {
            background: #2962ff;
        }
        button.secondary:hover {
            background: #1e53e5;
        }
        button.refresh-btn {
            background: #26a69a;
            position: relative;
            transition: all 0.3s ease;
        }
        button.refresh-btn:hover {
            background: #2bbbad;
            transform: scale(1.05);
        }
        button.refresh-btn.spinning {
            pointer-events: none;
            opacity: 0.7;
        }
        button.refresh-btn.spinning::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin: -10px 0 0 -10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }
        @keyframes spin-refresh {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        select {
            background: #2a2e39;
            color: #d1d4dc;
            border: 1px solid #434651;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
        .table-container {
            background: #1e222d;
            border-radius: 8px;
            overflow-x: auto;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2a2e39;
        }
        th {
            background: #2a2e39;
            color: #787b86;
            font-weight: normal;
            font-size: 12px;
            text-transform: uppercase;
            position: sticky;
            top: 0;
        }
        tr {
            transition: background-color 0.2s ease;
        }
        tr:hover {
            background: #2a2e39;
        }
        td {
            transition: color 0.3s ease, background-color 0.3s ease;
        }
        .win {
            color: #26a69a;
            font-weight: bold;
        }
        .loss {
            color: #ef5350;
            font-weight: bold;
        }
        .pending {
            color: #f7931a;
        }
        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
        }
        .badge.buy {
            background: rgba(38, 166, 154, 0.2);
            color: #26a69a;
        }
        .badge.sell {
            background: rgba(239, 83, 80, 0.2);
            color: #ef5350;
        }
        .action-btn {
            background: #2962ff;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .action-btn:hover {
            background: #1e53e5;
        }
        .action-btn.win {
            background: #26a69a;
        }
        .action-btn.loss {
            background: #ef5350;
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="spinner" id="spinner"></div>
        <div class="success-checkmark" id="successCheckmark">
            <div class="check-icon">
                <span class="icon-line line-tip"></span>
                <span class="icon-line line-long"></span>
            </div>
        </div>
        <div class="loading-text" id="loadingText">Loading signals...</div>
    </div>

    <div class="container">
        <h1>üìä Signal Tracker</h1>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-label">Total Signals</div>
                <div class="stat-value" id="total-signals">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Winning Trades</div>
                <div class="stat-value profit" id="win-count">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Losing Trades</div>
                <div class="stat-value loss" id="loss-count">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Win Rate</div>
                <div class="stat-value" id="win-rate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Profit Factor</div>
                <div class="stat-value" id="profit-factor">0.00</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Win</div>
                <div class="stat-value profit" id="avg-win">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Avg Loss</div>
                <div class="stat-value loss" id="avg-loss">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Best Trade</div>
                <div class="stat-value profit" id="best-trade">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Worst Trade</div>
                <div class="stat-value loss" id="worst-trade">0%</div>
            </div>
        </div>

        <div class="controls">
            <button onclick="manualRefresh()" class="refresh-btn" id="refreshBtn" title="Refresh live data">
                üîÑ Refresh
            </button>
            <button onclick="addTestSignal()">‚ûï Add Test Signal</button>
            <button class="secondary" onclick="exportToCSV()">üì• Export CSV</button>
            <button class="secondary" onclick="showChart()">üìä Chart</button>
            <button class="secondary" onclick="showStats()">üìà Statistics</button>
            <button class="secondary" onclick="clearAllSignals()">üóëÔ∏è Clear All</button>
            <select id="filter" onchange="filterSignals()">
                <option value="all">All Signals</option>
                <option value="win">Wins Only</option>
                <option value="loss">Losses Only</option>
                <option value="pending">Pending Only</option>
                <option value="buy">BUY Only</option>
                <option value="sell">SELL Only</option>
                <option value="tp1">TP1 Exits</option>
                <option value="tp2">TP2 Exits</option>
                <option value="tp3">TP3 Exits</option>
                <option value="trailing">Trailing Stop Exits</option>
            </select>
            <input type="date" id="date-from" onchange="filterSignals()" style="padding: 8px;">
            <input type="date" id="date-to" onchange="filterSignals()" style="padding: 8px;">
        </div>

        <div class="table-container">
            <table>
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Date/Time</th>
                        <th>Type</th>
                        <th>Symbol</th>
                        <th>Entry</th>
                        <th>Exit</th>
                        <th>Stop Loss</th>
                        <th>Trailing SL</th>
                        <th>TP1</th>
                        <th>TP2</th>
                        <th>TP3</th>
                        <th>Strength</th>
                        <th>Status</th>
                        <th>Progress</th>
                        <th>Result</th>
                    </tr>
                </thead>
                <tbody id="signals-table">
                    <tr>
                        <td colspan="15" style="text-align: center; color: #787b86; padding: 40px;">
                            No signals yet. Signals will appear here when sent to Telegram.
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Fast loading with optimization
        let signals = [];
        let isLoading = true;
        
        // Load signals asynchronously
        function loadSignals() {
            return new Promise((resolve) => {
                try {
                    signals = JSON.parse(localStorage.getItem('tradingSignals') || '[]');
                    console.log(`üìä Loaded ${signals.length} signals from storage`);
                    resolve();
                } catch (error) {
                    console.error('Error loading signals:', error);
                    signals = [];
                    resolve();
                }
            });
        }

        // Display signals
        function displaySignals(filter = 'all') {
            filterSignals();
        }

        // Update statistics
        function updateStats() {
            const total = signals.length;
            const wins = signals.filter(s => s.status === 'win').length;
            const losses = signals.filter(s => s.status === 'loss').length;
            const winRate = total > 0 ? ((wins / (wins + losses)) * 100).toFixed(1) : 0;
            
            // Calculate profit/loss percentages
            const winTrades = signals.filter(s => s.status === 'win' && s.exitPrice);
            const lossTrades = signals.filter(s => s.status === 'loss' && s.exitPrice);
            
            let totalWinPercent = 0;
            let totalLossPercent = 0;
            let bestTrade = 0;
            let worstTrade = 0;
            
            winTrades.forEach(s => {
                const profit = s.type === 'BUY' 
                    ? ((s.exitPrice - s.entry) / s.entry) * 100
                    : ((s.entry - s.exitPrice) / s.entry) * 100;
                totalWinPercent += profit;
                if (profit > bestTrade) bestTrade = profit;
            });
            
            lossTrades.forEach(s => {
                const loss = s.type === 'BUY' 
                    ? ((s.exitPrice - s.entry) / s.entry) * 100
                    : ((s.entry - s.exitPrice) / s.entry) * 100;
                totalLossPercent += Math.abs(loss);
                if (loss < worstTrade) worstTrade = loss;
            });
            
            const avgWin = winTrades.length > 0 ? (totalWinPercent / winTrades.length).toFixed(2) : 0;
            const avgLoss = lossTrades.length > 0 ? (totalLossPercent / lossTrades.length).toFixed(2) : 0;
            const profitFactor = totalLossPercent > 0 ? (totalWinPercent / totalLossPercent).toFixed(2) : 0;
            
            document.getElementById('total-signals').textContent = total;
            document.getElementById('win-count').textContent = wins;
            document.getElementById('loss-count').textContent = losses;
            document.getElementById('win-rate').textContent = winRate + '%';
            document.getElementById('profit-factor').textContent = profitFactor;
            document.getElementById('avg-win').textContent = '+' + avgWin + '%';
            document.getElementById('avg-loss').textContent = '-' + avgLoss + '%';
            document.getElementById('best-trade').textContent = '+' + bestTrade.toFixed(2) + '%';
            document.getElementById('worst-trade').textContent = worstTrade.toFixed(2) + '%';
        }

        // Save signals to localStorage
        function saveSignals() {
            localStorage.setItem('tradingSignals', JSON.stringify(signals));
        }

        // Debounce filter to prevent excessive updates
        let filterTimeout;
        let isFiltering = false;
        
        // Filter signals with optimized debouncing
        function filterSignals() {
            clearTimeout(filterTimeout);
            filterTimeout = setTimeout(() => {
                if (!isFiltering) {
                    isFiltering = true;
                    requestAnimationFrame(() => {
                        filterSignalsNow();
                        isFiltering = false;
                    });
                }
            }, 100);
        }
        
        function filterSignalsNow() {
            const filter = document.getElementById('filter').value;
            const dateFrom = document.getElementById('date-from').value;
            const dateTo = document.getElementById('date-to').value;
            
            let filtered = signals;
            
            // Filter by type/status
            if (filter === 'win') {
                filtered = filtered.filter(s => s.status === 'win');
            } else if (filter === 'loss') {
                filtered = filtered.filter(s => s.status === 'loss');
            } else if (filter === 'pending') {
                filtered = filtered.filter(s => s.status === 'pending');
            } else if (filter === 'buy') {
                filtered = filtered.filter(s => s.type === 'BUY');
            } else if (filter === 'sell') {
                filtered = filtered.filter(s => s.type === 'SELL');
            } else if (filter === 'tp1') {
                filtered = filtered.filter(s => s.exitReason === 'TP1');
            } else if (filter === 'tp2') {
                filtered = filtered.filter(s => s.exitReason === 'TP2');
            } else if (filter === 'tp3') {
                filtered = filtered.filter(s => s.exitReason === 'TP3');
            } else if (filter === 'trailing') {
                filtered = filtered.filter(s => s.exitReason === 'Trailing Stop');
            }
            
            // Filter by date range
            if (dateFrom) {
                const fromTime = new Date(dateFrom).getTime();
                filtered = filtered.filter(s => s.timestamp >= fromTime);
            }
            if (dateTo) {
                const toTime = new Date(dateTo).getTime() + 86400000; // Add 1 day
                filtered = filtered.filter(s => s.timestamp < toTime);
            }
            
            displayFilteredSignals(filtered);
        }
        
        function displayFilteredSignals(filteredSignals) {
            const tbody = document.getElementById('signals-table');
            
            if (!tbody) {
                console.error('Table body element not found!');
                return;
            }
            
            if (filteredSignals.length === 0) {
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; color: #787b86; padding: 40px;">No signals found.</td></tr>';
                return;
            }
            
            // Limit display to 100 most recent signals for performance
            const signalsToDisplay = filteredSignals.slice(0, 100);
            
            if (filteredSignals.length > 100) {
                console.log(`Showing 100 of ${filteredSignals.length} signals for performance`);
            }
            
            try {
                const rowsHTML = signalsToDisplay.map((signal) => {
                const statusClass = signal.status === 'win' ? 'win' : signal.status === 'loss' ? 'loss' : 'pending';
                const statusText = signal.status === 'win' ? '‚úÖ WIN' : signal.status === 'loss' ? '‚ùå LOSS' : '‚è≥ PENDING';
                
                const profitPercent = signal.exitPrice ? (
                    signal.type === 'BUY' 
                        ? ((signal.exitPrice - signal.entry) / signal.entry) * 100
                        : ((signal.entry - signal.exitPrice) / signal.entry) * 100
                ) : 0;
                
                // For pending signals, show live progress with heatmap colors
                let statusDisplay = '';
                let progressDisplay = '';
                let resultDisplay = '';
                
                if (signal.status === 'pending' && signal.livePrice) {
                    const currentProfit = signal.type === 'BUY'
                        ? ((signal.livePrice - signal.entry) / signal.entry) * 100
                        : ((signal.entry - signal.livePrice) / signal.entry) * 100;
                    
                    // Status shows live price and P/L
                    const profitColor = currentProfit > 0 ? '#26a69a' : '#ef5350';
                    statusDisplay = `
                        <small>Live: ${signal.livePrice.toFixed(2)}</small><br>
                        <small style="color: ${profitColor}; font-weight: bold;">${currentProfit > 0 ? '+' : ''}${currentProfit.toFixed(2)}%</small>
                    `;
                    
                    // Determine which target we're approaching and set color
                    let progressColor = '#ef5350'; // Red (below entry)
                    let targetText = 'Entry';
                    let progressPercent = 0;
                    let targetsHit = [];
                    
                    if (signal.type === 'BUY') {
                        if (signal.livePrice >= signal.tp3) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì', 'TP3 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            progressPercent = 100;
                        } else if (signal.livePrice >= signal.tp2) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            const totalDistance = signal.tp3 - signal.tp2;
                            const currentDistance = signal.livePrice - signal.tp2;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice >= signal.tp1) {
                            targetsHit = ['TP1 ‚úì'];
                            progressColor = '#26a69a';
                            targetText = 'TP2';
                            const totalDistance = signal.tp2 - signal.tp1;
                            const currentDistance = signal.livePrice - signal.tp1;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice >= signal.entry) {
                            progressColor = '#4caf50';
                            targetText = 'TP1';
                            const totalDistance = signal.tp1 - signal.entry;
                            const currentDistance = signal.livePrice - signal.entry;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else {
                            progressColor = '#ef5350';
                            targetText = 'Entry';
                            progressPercent = 0;
                        }
                    } else { // SELL
                        if (signal.livePrice <= signal.tp3) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì', 'TP3 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            progressPercent = 100;
                        } else if (signal.livePrice <= signal.tp2) {
                            targetsHit = ['TP1 ‚úì', 'TP2 ‚úì'];
                            progressColor = '#ff9800';
                            targetText = 'TP3';
                            const totalDistance = signal.tp2 - signal.tp3;
                            const currentDistance = signal.tp2 - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice <= signal.tp1) {
                            targetsHit = ['TP1 ‚úì'];
                            progressColor = '#26a69a';
                            targetText = 'TP2';
                            const totalDistance = signal.tp1 - signal.tp2;
                            const currentDistance = signal.tp1 - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else if (signal.livePrice <= signal.entry) {
                            progressColor = '#4caf50';
                            targetText = 'TP1';
                            const totalDistance = signal.entry - signal.tp1;
                            const currentDistance = signal.entry - signal.livePrice;
                            progressPercent = (currentDistance / totalDistance) * 100;
                        } else {
                            progressColor = '#ef5350';
                            targetText = 'Entry';
                            progressPercent = 0;
                        }
                    }
                    
                    progressPercent = Math.max(0, Math.min(100, progressPercent));
                    
                    progressDisplay = `
                        <div style="background: #2a2e39; border-radius: 4px; height: 10px; overflow: hidden; margin: 5px 0; border: 1px solid ${progressColor};">
                            <div style="background: ${progressColor}; height: 100%; width: ${progressPercent.toFixed(0)}%; transition: all 0.3s ease;"></div>
                        </div>
                        <small style="color: ${progressColor};">${progressPercent.toFixed(1)}% to ${targetText}</small><br>
                        <small>ETA: ${signal.timeEstimate || '-'}</small>
                    `;
                    
                    // Result shows which targets hit
                    if (targetsHit.length > 0) {
                        resultDisplay = targetsHit.map(t => `<span style="color: #26a69a;">${t}</span>`).join('<br>');
                    } else {
                        resultDisplay = '-';
                    }
                } else if (signal.exitPrice) {
                    statusDisplay = statusText;
                    progressDisplay = '-';
                    
                    // Show exit reason with icon
                    let exitIcon = '';
                    if (signal.exitReason === 'TP1') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #26a69a;">${exitIcon} TP1 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'TP2') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #26a69a;">${exitIcon} TP2 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'TP3') {
                        exitIcon = 'üéØ';
                        resultDisplay = `<span style="color: #ff9800;">${exitIcon} TP3 Hit</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'Trailing Stop') {
                        exitIcon = 'üîí';
                        resultDisplay = `<span style="color: #f7931a;">${exitIcon} Trailing Stop</span><br><small>${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%</small>`;
                    } else if (signal.exitReason === 'Stop Loss') {
                        exitIcon = 'üõë';
                        resultDisplay = `<span style="color: #ef5350;">${exitIcon} Stop Loss</span><br><small>${profitPercent.toFixed(2)}%</small>`;
                    } else {
                        resultDisplay = `${profitPercent > 0 ? '+' : ''}${profitPercent.toFixed(2)}%`;
                    }
                } else {
                    statusDisplay = statusText;
                    progressDisplay = '-';
                    resultDisplay = '-';
                }
                
                // Trailing stop display - show calculated or saved value
                let trailingStopDisplay = '-';
                if (signal.status === 'pending') {
                    // Calculate trailing stop on the fly if we have live price
                    let calculatedTS = signal.calculatedTrailingStop || signal.trailingStopPrice;
                    
                    // If no saved trailing stop, calculate it now based on live price
                    if (!calculatedTS && signal.livePrice) {
                        if (signal.type === 'BUY' && signal.livePrice >= signal.tp1) {
                            const profitDistance = signal.livePrice - signal.entry;
                            calculatedTS = signal.entry + (profitDistance * 0.5);
                        } else if (signal.type === 'SELL' && signal.livePrice <= signal.tp1) {
                            const profitDistance = signal.entry - signal.livePrice;
                            calculatedTS = signal.entry - (profitDistance * 0.5);
                        }
                    }
                    
                    if (calculatedTS) {
                        trailingStopDisplay = `<span style="color: #f7931a;">${calculatedTS.toFixed(2)}</span><br><small style="color: #26a69a;">üîí Active</small>`;
                    } else {
                        // Show that trailing stop will activate at TP1
                        trailingStopDisplay = `<small style="color: #787b86;">Activates at TP1</small>`;
                    }
                } else if (signal.trailingStopPrice) {
                    // For closed signals, show saved trailing stop
                    trailingStopDisplay = `<span style="color: #787b86;">${signal.trailingStopPrice.toFixed(2)}</span>`;
                }
                
                return `
                    <tr>
                        <td>${signals.indexOf(signal) + 1}</td>
                        <td>${new Date(signal.timestamp).toLocaleString()}</td>
                        <td><span class="badge ${signal.type.toLowerCase()}">${signal.type}</span></td>
                        <td>${signal.symbol}</td>
                        <td>${signal.entry.toFixed(2)}</td>
                        <td>${signal.exitPrice ? signal.exitPrice.toFixed(2) : (signal.livePrice ? signal.livePrice.toFixed(2) : '-')}</td>
                        <td>${signal.stopLoss.toFixed(2)}</td>
                        <td>${trailingStopDisplay}</td>
                        <td>${signal.tp1.toFixed(2)}</td>
                        <td>${signal.tp2.toFixed(2)}</td>
                        <td>${signal.tp3.toFixed(2)}</td>
                        <td>${signal.strength}%</td>
                        <td class="${statusClass}">${statusDisplay}</td>
                        <td>${progressDisplay}</td>
                        <td>
                            ${resultDisplay}
                        </td>
                    </tr>
                `;
                }).join('');
                
                // Use requestAnimationFrame for synchronized, lag-free updates
                requestAnimationFrame(() => {
                    // Batch DOM update for all fields simultaneously
                    tbody.innerHTML = rowsHTML;
                    console.log(`‚úÖ Displayed ${signalsToDisplay.length} signals`);
                });
                
            } catch (error) {
                console.error('Error displaying signals:', error);
                tbody.innerHTML = '<tr><td colspan="15" style="text-align: center; color: #ef5350; padding: 40px;">Error displaying signals. Check console.</td></tr>';
            }
        }

        // Manual refresh function
        async function manualRefresh() {
            const refreshBtn = document.getElementById('refreshBtn');
            
            if (refreshBtn.classList.contains('spinning')) {
                return; // Already refreshing
            }
            
            try {
                // Add spinning animation
                refreshBtn.classList.add('spinning');
                refreshBtn.textContent = '‚è≥ Refreshing...';
                
                console.log('üîÑ Manual refresh triggered...');
                
                // Update pending signals
                await updatePendingSignals();
                
                // Refresh display
                requestAnimationFrame(() => {
                    const filter = document.getElementById('filter').value;
                    filterSignals();
                    updateStats();
                });
                
                console.log('‚úÖ Refresh complete!');
                
                // Show success state briefly
                refreshBtn.textContent = '‚úÖ Updated!';
                
                setTimeout(() => {
                    refreshBtn.classList.remove('spinning');
                    refreshBtn.textContent = 'üîÑ Refresh';
                }, 1000);
                
            } catch (error) {
                console.error('‚ùå Refresh error:', error);
                refreshBtn.classList.remove('spinning');
                refreshBtn.textContent = '‚ùå Error';
                
                setTimeout(() => {
                    refreshBtn.textContent = 'üîÑ Refresh';
                }, 2000);
            }
        }
        
        // Add test signal
        async function addTestSignal() {
            const isBuy = Math.random() > 0.5;
            const entry = 91500 + Math.random() * 1000;
            
            const testSignal = {
                id: Date.now(),
                timestamp: Date.now(),
                type: isBuy ? 'BUY' : 'SELL',
                symbol: 'BTCUSDT',
                entry: entry,
                stopLoss: isBuy ? entry - 500 : entry + 500,
                tp1: isBuy ? entry + 500 : entry - 500,
                tp2: isBuy ? entry + 1000 : entry - 1000,
                tp3: isBuy ? entry + 1500 : entry - 1500,
                strength: Math.floor(60 + Math.random() * 30),
                status: 'pending',
                exitPrice: null,
                exitReason: null,
                trailingStopPrice: null,
                trailingStopActive: false
            };
            
            // Simulate live price that has reached TP1 to show trailing stop
            const priceProgress = Math.random();
            if (priceProgress > 0.5) {
                // Price has moved past TP1
                testSignal.livePrice = isBuy ? testSignal.tp1 + 200 : testSignal.tp1 - 200;
                
                // Calculate trailing stop
                if (isBuy) {
                    const profitDistance = testSignal.livePrice - testSignal.entry;
                    testSignal.calculatedTrailingStop = testSignal.entry + (profitDistance * 0.5);
                } else {
                    const profitDistance = testSignal.entry - testSignal.livePrice;
                    testSignal.calculatedTrailingStop = testSignal.entry - (profitDistance * 0.5);
                }
                testSignal.trailingStopActive = true;
            } else {
                // Price is between entry and TP1
                testSignal.livePrice = isBuy ? 
                    testSignal.entry + (testSignal.tp1 - testSignal.entry) * priceProgress :
                    testSignal.entry - (testSignal.entry - testSignal.tp1) * priceProgress;
            }
            
            signals.unshift(testSignal);
            saveSignals();
            displaySignals(document.getElementById('filter').value);
            updateStats();
            
            console.log('‚úÖ Test signal added:', testSignal);
        }

        // Export to CSV
        function exportToCSV() {
            const csv = [
                ['#', 'Date/Time', 'Type', 'Symbol', 'Entry', 'Stop Loss', 'TP1', 'TP2', 'TP3', 'Strength', 'Status'],
                ...signals.map((s, i) => [
                    i + 1,
                    new Date(s.timestamp).toLocaleString(),
                    s.type,
                    s.symbol,
                    s.entry,
                    s.stopLoss,
                    s.tp1,
                    s.tp2,
                    s.tp3,
                    s.strength + '%',
                    s.status.toUpperCase()
                ])
            ].map(row => row.join(',')).join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `trading-signals-${Date.now()}.csv`;
            a.click();
        }

        // Clear all signals
        function clearAllSignals() {
            if (confirm('Are you sure you want to clear all signals?')) {
                signals = [];
                saveSignals();
                displaySignals();
                updateStats();
            }
        }
        
        // Show chart
        function showChart() {
            const wins = signals.filter(s => s.status === 'win').length;
            const losses = signals.filter(s => s.status === 'loss').length;
            const pending = signals.filter(s => s.status === 'pending').length;
            
            alert(`üìä Performance Chart\n\n` +
                  `Wins: ${wins} (${((wins/(wins+losses))*100).toFixed(1)}%)\n` +
                  `Losses: ${losses} (${((losses/(wins+losses))*100).toFixed(1)}%)\n` +
                  `Pending: ${pending}\n\n` +
                  `Chart visualization coming soon!`);
        }
        
        // Show detailed statistics
        function showStats() {
            const winTrades = signals.filter(s => s.status === 'win' && s.exitPrice);
            const lossTrades = signals.filter(s => s.status === 'loss' && s.exitPrice);
            
            const tp1Exits = signals.filter(s => s.exitReason === 'TP1').length;
            const tp2Exits = signals.filter(s => s.exitReason === 'TP2').length;
            const tp3Exits = signals.filter(s => s.exitReason === 'TP3').length;
            const trailingExits = signals.filter(s => s.exitReason === 'Trailing Stop').length;
            const slExits = signals.filter(s => s.exitReason === 'Stop Loss').length;
            
            const buySignals = signals.filter(s => s.type === 'BUY');
            const sellSignals = signals.filter(s => s.type === 'SELL');
            const buyWins = buySignals.filter(s => s.status === 'win').length;
            const sellWins = sellSignals.filter(s => s.status === 'win').length;
            
            alert(`üìà Detailed Statistics\n\n` +
                  `Exit Breakdown:\n` +
                  `TP1: ${tp1Exits}\n` +
                  `TP2: ${tp2Exits}\n` +
                  `TP3: ${tp3Exits}\n` +
                  `Trailing Stop: ${trailingExits}\n` +
                  `Stop Loss: ${slExits}\n\n` +
                  `Signal Type Performance:\n` +
                  `BUY: ${buyWins}/${buySignals.length} (${buySignals.length > 0 ? ((buyWins/buySignals.length)*100).toFixed(1) : 0}%)\n` +
                  `SELL: ${sellWins}/${sellSignals.length} (${sellSignals.length > 0 ? ((sellWins/sellSignals.length)*100).toFixed(1) : 0}%)`);
        }

        // Update pending signals with live price
        async function updatePendingSignals() {
            const pendingSignals = signals.filter(s => s.status === 'pending');
            
            if (pendingSignals.length === 0) return;
            
            const promises = pendingSignals.map(async (signal) => {
                try {
                    const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${signal.symbol}`);
                    const data = await response.json();
                    const currentPrice = parseFloat(data.price);
                    
                    // Calculate progress
                    let progress = 0;
                    let timeEstimate = '';
                    
                    if (signal.type === 'BUY') {
                        const totalDistance = signal.tp1 - signal.entry;
                        const currentDistance = currentPrice - signal.entry;
                        progress = (currentDistance / totalDistance) * 100;
                    } else {
                        const totalDistance = signal.entry - signal.tp1;
                        const currentDistance = signal.entry - currentPrice;
                        progress = (currentDistance / totalDistance) * 100;
                    }
                    
                    // Calculate trailing stop based on strategy
                    let calculatedTrailingStop = null;
                    let trailingActive = false;
                    
                    if (signal.type === 'BUY') {
                        // Check if TP1 hit - activate trailing stop
                        if (currentPrice >= signal.tp1) {
                            trailingActive = true;
                            // Lock in 50% of profit from entry to current price
                            const profitDistance = currentPrice - signal.entry;
                            calculatedTrailingStop = signal.entry + (profitDistance * 0.5);
                        }
                    } else { // SELL
                        // Check if TP1 hit - activate trailing stop
                        if (currentPrice <= signal.tp1) {
                            trailingActive = true;
                            // Lock in 50% of profit from entry to current price
                            const profitDistance = signal.entry - currentPrice;
                            calculatedTrailingStop = signal.entry - (profitDistance * 0.5);
                        }
                    }
                    
                    // Estimate time based on elapsed time and progress
                    const elapsed = Date.now() - signal.timestamp;
                    if (Math.abs(progress) > 5) {
                        const estimatedTotal = (elapsed / Math.abs(progress)) * 100;
                        const remaining = estimatedTotal - elapsed;
                        const hours = Math.floor(remaining / 3600000);
                        const minutes = Math.floor((remaining % 3600000) / 60000);
                        
                        if (hours > 0) {
                            timeEstimate = `~${hours}h ${minutes}m`;
                        } else if (minutes > 0) {
                            timeEstimate = `~${minutes}m`;
                        } else {
                            timeEstimate = '< 1m';
                        }
                    } else {
                        timeEstimate = 'Calculating...';
                    }
                    
                    // Update signal with live data
                    const index = signals.findIndex(s => s.id === signal.id);
                    if (index !== -1) {
                        signals[index].livePrice = currentPrice;
                        signals[index].progress = progress;
                        signals[index].timeEstimate = timeEstimate;
                        
                        // Update trailing stop if calculated
                        if (trailingActive) {
                            signals[index].calculatedTrailingStop = calculatedTrailingStop;
                            signals[index].trailingStopActive = true;
                        }
                    }
                } catch (error) {
                    console.error('Error updating signal:', error);
                }
            });
            
            // Wait for all updates to complete, then save once
            await Promise.all(promises);
            
            // Save updated signals to localStorage in one batch
            saveSignals();
        }

        // Auto-cleanup old signals (older than 30 days)
        function cleanupOldSignals() {
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            const originalLength = signals.length;
            signals = signals.filter(s => s.timestamp > thirtyDaysAgo);
            
            if (signals.length < originalLength) {
                saveSignals();
                console.log(`üóëÔ∏è Cleaned up ${originalLength - signals.length} old signals`);
            }
        }

        // Show loading complete animation
        function showLoadingComplete() {
            try {
                const overlay = document.getElementById('loadingOverlay');
                const spinner = document.getElementById('spinner');
                const checkmark = document.getElementById('successCheckmark');
                const loadingText = document.getElementById('loadingText');
                
                if (!overlay || !spinner || !checkmark || !loadingText) {
                    console.error('Loading elements not found');
                    return;
                }
                
                spinner.style.display = 'none';
                checkmark.classList.add('show');
                loadingText.textContent = 'Loaded successfully!';
                
                setTimeout(() => {
                    overlay.classList.add('hidden');
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 500);
                }, 800);
            } catch (error) {
                console.error('Error in showLoadingComplete:', error);
            }
        }
        
        // Initialize with fast loading
        async function initialize() {
            try {
                console.log('üöÄ Initializing Signal Tracker...');
                isLoading = true;
                
                // Load signals
                await loadSignals();
                
                // Clean up old signals
                cleanupOldSignals();
                
                // Display signals
                displaySignals();
                updateStats();
                
                // Show success animation
                showLoadingComplete();
                
                isLoading = false;
                console.log('‚úÖ Initialization complete!');
                
                // Start monitoring after load
                setTimeout(() => {
                    updatePendingSignals();
                }, 2000);
            } catch (error) {
                console.error('‚ùå Initialization error:', error);
                isLoading = false;
                showLoadingComplete();
            }
        }
        
        // Start initialization
        initialize();
        
        // Update pending signals every 5 seconds with optimized rendering
        setInterval(() => {
            if (!isLoading) {
                updatePendingSignals().then(() => {
                    // Use requestAnimationFrame for smooth, synchronized updates
                    requestAnimationFrame(() => {
                        const filter = document.getElementById('filter').value;
                        filterSignals();
                    });
                });
            }
        }, 5000);

        // Listen for new signals from main app with optimized updates
        let storageUpdateTimeout;
        window.addEventListener('storage', (e) => {
            if (e.key === 'tradingSignals') {
                clearTimeout(storageUpdateTimeout);
                storageUpdateTimeout = setTimeout(() => {
                    const newSignals = JSON.parse(e.newValue || '[]');
                    
                    // Use requestAnimationFrame for synchronized updates
                    requestAnimationFrame(() => {
                        // Check if there are actually new signals
                        if (newSignals.length > signals.length) {
                            console.log('üÜï New signal detected!');
                            signals = newSignals;
                            displaySignals(document.getElementById('filter').value);
                            updateStats();
                            
                            // Flash notification
                            document.title = 'üîî New Signal! - Signal Tracker';
                            setTimeout(() => {
                                document.title = 'Signal Tracker - Trading Signals';
                            }, 3000);
                        } else {
                            signals = newSignals;
                            displaySignals(document.getElementById('filter').value);
                            updateStats();
                        }
                    });
                }, 50);
            }
        });
    </script>
</body>
</html>
